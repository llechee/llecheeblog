<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ubuntu20的vscode设置</title>
      <link href="/posts/9c7668f5/"/>
      <url>/posts/9c7668f5/</url>
      
        <content type="html"><![CDATA[<h1 id="我的ubuntu20的vscode设置"><a class="markdownIt-Anchor" href="#我的ubuntu20的vscode设置"></a> 我的ubuntu20的vscode设置</h1><h2 id="launchjson"><a class="markdownIt-Anchor" href="#launchjson"></a> launch.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerArgs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-q -ex quit; wait() &#123; fg &gt;/dev/null; &#125;; /bin/gdb -q --interpreter=mi&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Launch&quot;</span><span class="punctuation">,</span> <span class="comment">// 配置名称</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span><span class="comment">// 配置类型</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span> <span class="comment">// 请求配置类型,launch或者attach</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span><span class="comment">// 进行调试程序的路径，程序生成文件.out</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="comment">// 传递给程序的命令行参数，一般为空</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="comment">// 调试器是否在目标的入口点停止，</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span><span class="comment">// 项目目录</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="comment">// 调试时是否显示控制台窗口，一般为true显示控制台</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span><span class="comment">// 指定连接的调试器</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="tasksjson"><a class="markdownIt-Anchor" href="#tasksjson"></a> tasks.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span><span class="comment">// 任务名</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span><span class="comment">// 指令</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-g&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-std=c++17&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT</title>
      <link href="/posts/9454662e/"/>
      <url>/posts/9454662e/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1><h1 id="信号和槽"><a class="markdownIt-Anchor" href="#信号和槽"></a> 信号和槽</h1><p>信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p><p>QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</p><p>参数 1、信号的发送者</p><p>参数 2、发送的信号</p><p>参数 3、信号的接收者</p><p>参数 4、处理函数（槽函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QMetaObject::Connection ret = <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;QWidget::close);</span><br><span class="line">    <span class="comment">//sendr.btn signal.clicked点击 recvier.this widget.close事件 把click信号和槽关联起来</span></span><br></pre></td></tr></table></figure><p>信号与槽（Signal &amp; Slot）是 Qt 编程的基础，也是 Qt 的一大创新。因为有了信号与槽的</p><p>编程机制，在 Qt 中处理界面各个组件的交互操作时变得更加直观和简单。它可以让应用</p><p>程序编程人员把这些互不了解的对象绑定在一起。</p><p><strong>信号（Signal）</strong></p><p>信号（Signal）就是在特定情况下被发射的事件，例如 PushButton 最常见的信号就是鼠标</p><p>单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射</p><p>的 CurrentIndexChanged() 信号。</p><p>GUI 程序设计的主要内容就是对界面上各组件的信号的响应，只需要知道什么情况下发射</p><p>哪些信号，合理地去响应和处理这些信号就可以了。</p><p><strong>槽（Slot）</strong></p><p>就是对信号响应的函数。槽就是一个函数，与一般的 C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。</p><h2 id="qt-中自定义信号和槽函数"><a class="markdownIt-Anchor" href="#qt-中自定义信号和槽函数"></a> Qt 中自定义信号和槽函数</h2><p>自定义信号和槽的区别，<strong>信号和槽都为 void 类型</strong>，信号只需要定义，<strong>不需要实</strong></p><p><strong>现</strong>，而槽函数<strong>既需要定义，也需要实现</strong>，<strong>信号和槽都可以有参数也都可以重载</strong>。emit</p><p>是出发信号的标志，可要可不要。</p><p>注意<strong>信号重载函数指针</strong>指向哪一个函数的问题，对于重载函数的信号连接，要指</p><p>明到底连接的是哪一个</p><h2 id="信号和槽的扩展"><a class="markdownIt-Anchor" href="#信号和槽的扩展"></a> 信号和槽的扩展</h2><p><strong>多个信号可以连接同一个槽函数</strong></p><p>这个就不用实例了，我们的按钮和窗口上的 xx 都可以关闭窗口。</p><p><strong>信号和槽的参数必须一一对应。</strong></p><p>信号的发送什么，槽就接收什么，类型必须一致。但信号的参数个数可以多余槽的参数的个</p><p>数，但前面相同数量的参数类型必须一一对应。反之则不可以</p><h1 id="lambda-函数"><a class="markdownIt-Anchor" href="#lambda-函数"></a> Lambda 函数</h1><p>Lambda 函数也叫 Lambda 表达式，是匿名函数，就是没有名字的函数，和传统的函数不一样。Lambda 表达式是 C++11 中引入的新概念，用于定义并创建匿名的函数对象。首先看</p><p>下 Lambda 表达式的基本结构。</p><p><code>[捕捉列表] (参数) mutable -&gt;返回值类型 &#123;函数体&#125; </code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[]()&#123;</span><br><span class="line"><span class="built_in">qDebug</span>( <span class="string">&quot;Lambda&quot;</span> );</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、 [ ]，标识一个，Lambda 匿名函数的开始，这个必须有，不能省略，函数对象参数是传 递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用到 Lambda 定 义为止 Lambda 所在的作用域范围内可见的局部变量，包括 Lambda 所在类的 <span class="keyword">this</span>。函 数对象参数有以下形式 </span><br><span class="line">    a) 空，没有使用任何的函数对象参数 </span><br><span class="line">    b) =，函数体内使用 Lambda 所在范围内的可见局部变量包括所在类的 <span class="keyword">this</span> 的传值方 式，相当于编译器给 Lambda 所在地的所有局部变量复制一份给 Lambda 函数 </span><br><span class="line">    c) &amp;，函数体内使用 Lambda 所在范围内的可见局部变量包括所在类的 <span class="keyword">this</span> 的引用方 式，相当于编译器给 Lambda 所在地的所有局部变量引用一份给 Lambda 函数 </span><br><span class="line">    d) <span class="keyword">this</span>，函数体内可以使用 Lambda 所在内的成员变量 </span><br><span class="line">    e) a,不是字母，而是指具体一个变量 a，那么 Lambda 内拷贝一个 a 使用 </span><br><span class="line">    f) &amp;a，Lambda 内引用 a </span><br><span class="line">    g) a,&amp;b,拷贝 a，引用 b </span><br><span class="line">    h) =，&amp;a，&amp;b，除 ab 引用，其余拷贝 </span><br><span class="line">    i) &amp;，a，b。除 ab 拷贝，其余引用 </span><br><span class="line"><span class="number">2</span>、 函数参数，这个跟常规函数一样。 </span><br><span class="line"><span class="number">3</span>、 mutatble，修改关键字，再对应位置 mutatble 关键字，才能修改函数对象参数。否则报 错。可以有，也可以没有，但有才能修改。lambda 默认是 <span class="type">const</span>，也就是不能修改本地 变量。 <span class="number">4</span>、 -&gt;<span class="keyword">return</span>-type 返回值的方式，既然是函数就可能有返回值，那么-&gt;就是有返回值的函 数标志。 </span><br><span class="line"><span class="number">5</span>、 函数体，跟常规函数一样。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;222&quot;</span>,<span class="keyword">this</span>); </span><br><span class="line">QPushButton * btn3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;333&quot;</span>,<span class="keyword">this</span>); </span><br><span class="line">btn2-&gt;<span class="built_in">move</span>(<span class="number">0</span>,<span class="number">20</span>); </span><br><span class="line">btn3-&gt;<span class="built_in">move</span>(<span class="number">0</span>,<span class="number">50</span>); </span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">connect</span>(btn2,&amp;QPushButton::clicked,<span class="keyword">this</span>,[a]()<span class="keyword">mutable</span>&#123; a += <span class="number">100</span>;<span class="built_in">qDebug</span>()&lt;&lt;a; &#125;); </span><br><span class="line"><span class="built_in">connect</span>(btn3,&amp;QPushButton::clicked,<span class="keyword">this</span>,[=]()<span class="keyword">mutable</span>&#123; <span class="built_in">qDebug</span>()&lt;&lt;a; &#125;); <span class="built_in">qDebug</span>()&lt;&lt;a;</span><br></pre></td></tr></table></figure><p>新建两个按钮分别写入以上 Lambda 函数，再连接函数中直接可以写上 Lambda 函数体，消</p><p>息触发的时候，就直接调用，btn2，中只是将 a 传值，有关键字 mutable 可以在函数中修改</p><p>a 的值，但不会影响外面的值。</p><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ret=<span class="number">100</span>;</span><br><span class="line">ret=[&amp;ret]()<span class="keyword">mutable</span>-&gt;<span class="type">int</span>&#123;ret*=<span class="number">2</span>;<span class="keyword">return</span> ret;&#125;();</span><br><span class="line">cout&lt;&lt;ret;</span><br><span class="line"><span class="comment">//retx2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>;</span><br><span class="line">[](<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b,<span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">        ret=a+b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=ret;</span><br><span class="line">        cout&lt;&lt;ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(a,b,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//循环20次输出斐波那契数列(后一项是前俩项的和)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2><p>无参按钮调用有参的槽函数</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 项目 </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络编程基础</title>
      <link href="/posts/30335c15/"/>
      <url>/posts/30335c15/</url>
      
        <content type="html"><![CDATA[<h1 id="libevent-c高并发网络编程"><a class="markdownIt-Anchor" href="#libevent-c高并发网络编程"></a> Libevent C++高并发网络编程</h1><h2 id="31-课程内容概述"><a class="markdownIt-Anchor" href="#31-课程内容概述"></a> 3.1 课程内容概述</h2><ol><li>Libevent源码的跨平台编译和测试</li><li>Libevent原理和网络模型设置</li><li>event事件处理原理和实战</li><li>bufferevent缓冲IO</li><li>bufferevent、zlib实现过滤器中压缩和解压缩</li><li>libevent的http接口实现服务端和客户端</li><li>搭建基于libevent的C++跨平台线程池</li><li>基于libevent和线程池完成FTP服务器开发</li></ol><h1 id="大并发服务器架构学习"><a class="markdownIt-Anchor" href="#大并发服务器架构学习"></a> 大并发服务器架构学习</h1><h2 id="第一章-高性能的服务器架构"><a class="markdownIt-Anchor" href="#第一章-高性能的服务器架构"></a> 第一章 高性能的服务器架构</h2><ul><li>网络I/O + 服务器高性能编程技术 + 数据库</li><li>超出数据库连接数</li><li>超出时限（队列+连接池，缓冲更新，缓冲换页，数据库读写分离进行负载均衡-replication机制）</li></ul><p>服务器性能四大杀手：</p><ul><li>数据拷贝-缓存技术解决</li><li>环境切换-有理性创建线程，单线程还是多线程好，单核服务器（采用状态机编程，效率最佳，减少线程间的切换开销），多线程能够充分发挥多核服务器的性能。</li><li>内存分配-内存池</li><li>锁竞争</li></ul><h2 id="第二章-大型网站架构演变过程"><a class="markdownIt-Anchor" href="#第二章-大型网站架构演变过程"></a> 第二章 大型网站架构演变过程</h2><ol><li><p>web动静资源分离</p></li><li><p>缓存处理</p><ul><li>减少对网站的访问-客户端（浏览器）缓存</li><li>减少对Web应用服务器的请求-前端页面缓存（squid）</li><li>减少对数据库的查询-页面片段缓存ESI（Edge Side Includes）</li><li>减少对文件系统I/O操作-本地数据缓存</li></ul></li><li><p>Web server集群+读写分离（负载均衡）</p><ul><li>前端负载均衡：DNS负载均衡、反向代理、基于NAT的负载均衡技术、LVS、F5硬件负载均衡</li><li>应用服务器负载均衡</li><li>数据库负载均衡</li></ul></li><li><p>CDN、分布式缓存、分库分表</p></li><li><p>多数据中心+分布式存储与计算（技术点DFS分布式文件系统、Key-Value DB、Map/Reduce算法）</p></li></ol><h2 id="第三章-poll"><a class="markdownIt-Anchor" href="#第三章-poll"></a> 第三章 poll</h2><p>Linux下有三种I/O复用模型：select、poll、epoll。</p><h1 id="linux网络编程基础"><a class="markdownIt-Anchor" href="#linux网络编程基础"></a> Linux网络编程基础</h1><h2 id="网络基础-综述"><a class="markdownIt-Anchor" href="#网络基础-综述"></a> 网络基础-综述</h2><h3 id="1-协议的概念"><a class="markdownIt-Anchor" href="#1-协议的概念"></a> 1. <strong>协议的概念</strong></h3><p>TCP协议注重数据的传输，HTTP协议注重数据的解释。</p><h3 id="2-bs浏览器服务端模式-cs客户端服务端模式"><a class="markdownIt-Anchor" href="#2-bs浏览器服务端模式-cs客户端服务端模式"></a> 2. b/s（浏览器/服务端模式） c/s（客户端/服务端模式）</h3><ul><li><code>C/S模式优点</code>：协议选用灵活，提前对数据进行缓存</li><li>C/S模式缺点：对用户安全构成威胁，开发任务工作量大</li><li><code>B/S模式优点</code>：安全性高，跨平台</li><li>B/S模式缺点：协议选用不灵活，数据加载不缓存</li><li>两者使用场景不同。</li></ul><h3 id="3-分层模型osi七层模型-tcpip四层模型"><a class="markdownIt-Anchor" href="#3-分层模型osi七层模型-tcpip四层模型"></a> 3. <strong>分层模型：OSI七层模型-TCP/IP四层模型</strong></h3><ul><li><code>OSI七层模型</code>: 物理层-&gt;数据链路层-&gt;网络层（IP协议）-&gt;传输层（TCP/UDP协议）-&gt;会话层-&gt;表示层-&gt;应用层</li><li><code>TCP/IP四层模型</code>：网络接口层------&gt;网络层（IP协议）-&gt;传输层（TCP/UDP协议）---------------&gt;应用层（FTP协议）</li></ul><h3 id="4-协议格式"><a class="markdownIt-Anchor" href="#4-协议格式"></a> 4. <strong>协议格式</strong></h3><ul><li><code>数据包基本格式</code>：操作系统封装数据和解析数据包；路由器寻路（寻找下一路由节点）的一般思想。</li><li><code>以太网帧格式</code>：|目的地址(6字节)|源地址6字节|类型2字节|数据|CRC校应2字节|</li><li><code>arp数据包格式</code>:|目的地址(6字节)|源地址6字节|帧类型0806|硬件类型-协议类型-硬件地址长度-协议地址长度-op-发送端以太网地址-发送端IP地址目的以太网地址-目的IP地址（28字节ARP请求/应答）|PAD填充18字节|。<code>arp数据报的目的：获取下一跳mac的地址</code>。</li><li><code>IP段格式</code>：在网络层。|4位版本号|4位首部长度|8位服务类型（TOS）|16位总长度（字节数）|</li><li><code>TCP/UDP数据报格式</code></li></ul><h3 id="5-nat映射-打洞机制"><a class="markdownIt-Anchor" href="#5-nat映射-打洞机制"></a> 5. <strong>NAT映射 打洞机制</strong></h3><ul><li><code>NAT（Network Address Translation，网络地址转换）</code>，也叫做网络掩蔽或者IP掩蔽。NAT是一种网络地址翻译技术，主要是将内部的私有IP地址（private IP）转换成可以在公网使用的公网IP（public IP）。</li><li>NAT可以同时让多个计算机同时联网，并隐藏其内网IP，因此也增加了内网的网络安全性；此外，NAT对来自外部的数据查看其NAT映射记录，对没有相应记录的数据包进行拒绝，提高了网络安全性。</li><li>打洞机制需要借助公网 <code>IP</code> 实现；</li><li>公-公通信（局域网内IP通信）：直接访问；公-私：NAT映射；私-公：NAT映射；私-私：NAT映射、打洞机制。</li></ul><h3 id="6-套接字socket通信原理概念"><a class="markdownIt-Anchor" href="#6-套接字socket通信原理概念"></a> 6. <strong>套接字socket通信原理概念</strong></h3><ul><li>IP地址：在网络环境中唯一标识一台主机</li><li>端口号：在主机中唯一标识一个进程</li><li><code>IP地址 + 端口</code>：唯一标识网络通讯中的一个进程，对应一个socket。</li><li><code>socket</code> 成对出现、必须绑定IP+端口、一个文件描述符指向两个缓冲区（一个读一个写）。</li></ul><h4 id="61-网络字节序列化"><a class="markdownIt-Anchor" href="#61-网络字节序列化"></a> 6.1 网络字节序列化</h4><ul><li>大端存储：低地址–高位(高地址存低位)</li><li>小端存储：高地址–低位</li></ul><p>TCP/IP协议规定，<code>网络数据流应采用大端字节序</code>。为了使网络程序具有可移植性，使同样的 c 代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做<strong>网络字节序和主机字节序的转换</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><p><code>h</code> 标识<code>host</code>， <code>n</code> 表示 <code>network</code>， <code>I</code> 表示 32 位长整数， <code>s</code> 表示 <code>16</code>位短整数。</p><h4 id="62-ip地址转换函数"><a class="markdownIt-Anchor" href="#62-ip地址转换函数"></a> 6.2 ip地址转换函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span> <span class="comment">//字符串ip转换网络字节序;</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af,<span class="type">const</span> <span class="type">void</span> *src,<span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span> <span class="comment">//网络字节序转换字符串ip;</span></span></span><br></pre></td></tr></table></figure><h4 id="63-socketaddr数据结构"><a class="markdownIt-Anchor" href="#63-socketaddr数据结构"></a> 6.3 socketaddr数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sockaddr_in 结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="64-网络套接字函数"><a class="markdownIt-Anchor" href="#64-网络套接字函数"></a> 6.4 网络套接字函数</h4><p>1，创建套接字<code>socket</code>函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回指向创建的socket的文件描述符，失败：返回<span class="number">-1</span>，设置errno。</span><br></pre></td></tr></table></figure><p>2，绑定 <code>ip</code> 和端口号函数 <code>bind</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> cockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">sockfd:</span><br><span class="line">    socket 文件描述符</span><br><span class="line">addr:</span><br><span class="line">    构造出IP地址+端口号</span><br><span class="line">addrlen：</span><br><span class="line">    <span class="built_in">sizeof</span>(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">    成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure><h3 id="7-tcp-cs模型serverc-clientc"><a class="markdownIt-Anchor" href="#7-tcp-cs模型serverc-clientc"></a> 7. <strong>TCP C/S模型</strong>：server.c client.c</h3>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unbuntu </tag>
            
            <tag> 高并发 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础</title>
      <link href="/posts/fa1802cb/"/>
      <url>/posts/fa1802cb/</url>
      
        <content type="html"><![CDATA[<p>基础算法</p><p><code>scanf(&quot;%[^\n]&quot;,a);</code> 载入space</p><p>[TOC]</p><h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1><h2 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h2><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><p>1 确定分界点 左 右或者中间<br />2 调整区间 划分成俩部分 大于的和小于的<br />3 递归处理左右俩段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>求最大值</strong></p><p>例:<br /><img src="https://i0.hdslb.com/bfs/album/17f1d4f8c7e56194d948cc1b1a6009827b4c7021.png" alt="" /></p><p><img src="https://i0.hdslb.com/bfs/album/fe2f9a1aa4f38dbf589b216a96e3d38ba628e7e1.jpg" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickfind</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前半部分和快排完全相同</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> a[r];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = a[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求出 SL 的长度（分界点 - 左边界 + 1）</span></span><br><span class="line">    <span class="type">int</span> SL = j - l + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 情况 A</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SL) <span class="keyword">return</span> <span class="built_in">quickfind</span>(l, j, k);</span><br><span class="line">    <span class="comment">// 情况 B</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quickfind</span>(j + <span class="number">1</span>, r, k - SL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3><p>主要思想:分治 (双指针算法)</p><p>1.找分界点(中间) mid=(l+r&gt;&gt;1)递归排序左右</p><p>2.归并 把俩个有序的数组合并※</p><p><code>分开后有俩个序列,首先递归将俩个序列各自排序,排序完之后分别有一个指针指向俩个序列的最小值,以第一个序列开始的话,对比俩个序列的值哪一个小,小的就放在新建的res数组里去,然后第一个序列的指针往后移动一位(当俩个数字相同时,随便将一个指针后移).重复,直到一个序列的指针在结尾,那么把另一个序列的数全部放在res后面去即可.</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, left, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = left, l = left, r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt;= right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r &gt; right) || (l &lt;= mid &amp;&amp; nums[l] &lt;= nums[r])) tmp[k++] = nums[l++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = nums[r++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; ++i) nums[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l+r &gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chekc</span>(mid))r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数"><a class="markdownIt-Anchor" href="#整数"></a> 整数</h3><h3 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数</h3><h2 id="高精度"><a class="markdownIt-Anchor" href="#高精度"></a> 高精度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度加法 a,b均为非负整数,下同</span></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">    string c;</span><br><span class="line">    <span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>,j = b.<span class="built_in">size</span>()<span class="number">-1</span>,t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>||t!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) t += a[i--]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) t += b[j--]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c += t%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(c.<span class="built_in">rbegin</span>(),c.<span class="built_in">rend</span>());<span class="comment">// or reverse(c.begin(),c.end());</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高精度减法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">sub</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(a,b)==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(a,b)==<span class="number">-1</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sub</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    string c;</span><br><span class="line">    <span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>,j = b.<span class="built_in">size</span>()<span class="number">-1</span>,t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>||t!=<span class="number">0</span>) &#123;</span><br><span class="line">        t = a[i--] - t - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) t-=b[j--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c += (t+<span class="number">10</span>)%<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t = t&lt;<span class="number">0</span>? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;*c.<span class="built_in">rbegin</span>()==<span class="string">&#x27;0&#x27;</span>) c.<span class="built_in">erase</span>(c.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(c.<span class="built_in">rbegin</span>(),c.<span class="built_in">rend</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高精度乘法</span></span><br><span class="line"><span class="function">string <span class="title">mul</span><span class="params">(string a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&quot;0&quot;</span>||b==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string c;</span><br><span class="line">    <span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>,t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||t!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) t+= (a[i--]-<span class="string">&#x27;0&#x27;</span>)*b;</span><br><span class="line">        c += t%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(c.<span class="built_in">rbegin</span>(),c.<span class="built_in">rend</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高精度除法</span></span><br><span class="line"><span class="function">string <span class="title">div</span><span class="params">(string a, <span class="type">int</span> b, <span class="type">int</span>&amp; r)</span> </span>&#123;</span><br><span class="line">    string c;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c += r / b + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; c[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) c.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a==b?<span class="number">0</span>:a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>()?<span class="number">1</span>:a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()?<span class="number">-1</span>:a&gt;b?<span class="number">1</span>:<span class="number">-1</span>; <span class="comment">// 这句话和下面注释内容等价</span></span><br><span class="line">    <span class="comment">// if(a==b) return 0;</span></span><br><span class="line">    <span class="comment">// if(a.size()&gt;b.size()) return 1;</span></span><br><span class="line">    <span class="comment">// if(a.size()&lt;b.size()) return -1;</span></span><br><span class="line">    <span class="comment">// return a&gt;b? 1 : -1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前缀和与差分"><a class="markdownIt-Anchor" href="#前缀和与差分"></a> 前缀和与差分</h2><h3 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h3><p><strong>一维</strong></p><p><code>前缀和类似于高中的数组,在求数组前n项和,n~m项和的时候,我们可以使用Sn(前n项和的方式去求出我们所需要部分的长度)</code></p><p><code>S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1]</code></p><p><strong>二维</strong></p><p><code>意思同一维 代表求一个面积内某个坐标所对应点的面积</code></p><p><code>S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</code></p><h3 id="差分"><a class="markdownIt-Anchor" href="#差分"></a> 差分</h3><p><strong>-一维-二维</strong></p><p><img src="https://i0.hdslb.com/bfs/album/fedd83b37088c87dadc1738166f1f32314690503.png" alt="" /></p><h2 id="双指针算法"><a class="markdownIt-Anchor" href="#双指针算法"></a> 双指针算法</h2><h2 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h2><h2 id="离散化"><a class="markdownIt-Anchor" href="#离散化"></a> 离散化</h2><p>补</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="区间合并"><a class="markdownIt-Anchor" href="#区间合并"></a> 区间合并</h2><h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1><h2 id="链表与邻接表树与图的存储"><a class="markdownIt-Anchor" href="#链表与邻接表树与图的存储"></a> 链表与邻接表:树与图的存储</h2><h2 id="栈和队列"><a class="markdownIt-Anchor" href="#栈和队列"></a> 栈和队列</h2><h2 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> kmp</h2><h2 id="trie树"><a class="markdownIt-Anchor" href="#trie树"></a> Trie树</h2><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220320114715.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h2><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220320153552.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)维护size的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], size[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], d[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">            d[x] += d[p[x]];</span><br><span class="line">            p[x] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hash表"><a class="markdownIt-Anchor" href="#hash表"></a> Hash表</h2><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220320171935.png" alt="" /></p><p>模拟散列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line">    <span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line">    <span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串哈希"><a class="markdownIt-Anchor" href="#字符串哈希"></a> 字符串哈希</h3><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220320180401.png" alt="" /></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220320173908.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stl技巧"><a class="markdownIt-Anchor" href="#stl技巧"></a> STL技巧</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, string&gt;</span><br><span class="line">    p=<span class="built_in">make_pair</span>(x,xx);<span class="comment">//可以是数字也可以是字符串</span></span><br><span class="line">    pair&lt;<span class="type">int</span> , pair&lt;<span class="type">int</span> , <span class="type">int</span>&gt;&gt;p;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    string a=<span class="string">&quot;lzzzzzz&quot;</span>;</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; q=<span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    [] <span class="comment">//随机选取</span></span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱(前一个数)和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">    exp:map&lt;string,int&gt;a</span></span><br><span class="line"><span class="function">        a[<span class="string">&quot;lzz&quot;</span>]=</span><span class="number">1</span>; cout&lt;&lt;a[<span class="string">&quot;lzz&quot;</span>] -&gt;<span class="number">1</span></span><br><span class="line">        <span class="built_in">insert</span>()  插入的数是一个<span class="function">pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure><h3 id="vector遍历"><a class="markdownIt-Anchor" href="#vector遍历"></a> vector遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220320191604.png" alt="" /></p><h1 id="搜索与图论"><a class="markdownIt-Anchor" href="#搜索与图论"></a> 搜索与图论</h1><h2 id="dfs与bfs"><a class="markdownIt-Anchor" href="#dfs与bfs"></a> DFS与BFS</h2><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220324031504.png" alt="" /></p><h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h3><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220323195446.png" alt="" /></p><h4 id="n皇后问题"><a class="markdownIt-Anchor" href="#n皇后问题"></a> N皇后问题</h4><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220324013225.png" alt="" /></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220324013309.png" alt="" /></p><p><strong>第一种解法dfs</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220324013057.png" alt="" /></p><h3 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h3><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220324030031.png" alt="" /></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220324031557.png" alt="" /></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220324031715.png" alt="" /></p><h2 id="树与图"><a class="markdownIt-Anchor" href="#树与图"></a> 树与图</h2><h3 id="存储"><a class="markdownIt-Anchor" href="#存储"></a> 存储</h3><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220325005124.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// n个链表的链表头  结点的值是多少  每个节点的next值是多少  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure><h3 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h3><h4 id="dfs-2"><a class="markdownIt-Anchor" href="#dfs-2"></a> dfs</h4><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220325015944.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];<span class="comment">//当前链表里的节点对应图里的编号</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bfs-2"><a class="markdownIt-Anchor" href="#bfs-2"></a> bfs</h4><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220325022329.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路"><a class="markdownIt-Anchor" href="#最短路"></a> 最短路</h2><h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h2><h2 id="二分图染色法-匈牙利算法"><a class="markdownIt-Anchor" href="#二分图染色法-匈牙利算法"></a> 二分图：染色法、匈牙利算法</h2><h1 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h1><h3 id="more"><a class="markdownIt-Anchor" href="#more"></a> More</h3><p>质数<br />约数<br />欧拉函数<br />快速幂<br />扩展欧几里得算法<br />中国剩余定理<br />高斯消元<br />组合计数<br />容斥原理<br />简单博弈论</p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><h2 id="背包问题"><a class="markdownIt-Anchor" href="#背包问题"></a> 背包问题</h2><h3 id="01背包"><a class="markdownIt-Anchor" href="#01背包"></a> 01背包</h3><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220325163423.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//所有物品个数</span></span><br><span class="line"><span class="type">int</span> m;<span class="comment">//背包容量</span></span><br><span class="line"><span class="type">int</span> v[N], w[N];<span class="comment">//v表示体积,w表示价值</span></span><br><span class="line"><span class="type">int</span> f[N][N];<span class="comment">//表示所有的状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化成一维</span></span><br><span class="line"><span class="comment">//f(i)只用到了f(i-1)这层 </span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a class="markdownIt-Anchor" href="#完全背包"></a> 完全背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素做法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][n];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt; v[i] &gt;&gt;w[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k =<span class="number">0</span>; k * v[i] &lt;= j; k ++ )</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j]，f[i - <span class="number">1</span>][j - v[i]* k] + w[i] * k);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化成二维</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt; v[i] &gt;&gt;w[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i])</span><br><span class="line">                    f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化成一维</span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                    f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包-2"><a class="markdownIt-Anchor" href="#完全背包-2"></a> 完全背包</h3><p>暴力</p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220325204453.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 线性DP</span><br><span class="line"></span><br><span class="line">### 数字三角形</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p><pre><code>    7  3   88   1   0</code></pre><p>2   7   4   4<br />4   5   2   6   5</p><p>输入格式<br />第一行包含整数n，表示数字三角形的层数。</p><p>接下来n行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。</p><p>输出格式<br />输出一个整数，表示最大的路径数字和。</p><p>数据范围<br />1 ≤ n ≤ 500,<br />−10000 ≤ 三角形中的整数 ≤ 10000</p><p>输入样例：<br />5<br />7<br />3 8<br />8 1 0<br />2 7 4 4<br />4 5 2 6 5</p><p>输出样例：<br />30</p><pre class="highlight"><code class="">![](https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220326165232.png)### 最长上升子序列![](https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220326165740.png)![](https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220327011837.png)## 区间DP### 石子合并![](https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220327022354.png)![](https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220327024625.png)## 计数类DP## 数位统计DP## 状态压缩DP## 树形DP## 记忆化搜索# 贪心# 时空复杂度</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/posts/f9a964a9/"/>
      <url>/posts/f9a964a9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基础more"><a class="markdownIt-Anchor" href="#基础more"></a> 基础More</h1><p><code>size_t : typedef unsigned int</code></p><p>C++的静态转换: b为要转换的内容</p><p><code>int a=static_cast&lt;int 目标类型&gt;(b);</code></p><p>查看变量类型: <code>typeid(变量).name();</code></p><p>格式化输出流:</p><p><img src="https://i0.hdslb.com/bfs/album/8d5b7f9235bba470a9211975f9add9c31a30009c.jpg" alt="" /></p><p>运算优先级:(优先级从上到下)</p><p><img src="https://i0.hdslb.com/bfs/album/4a20c75c88cde2b4aec77070eaf610af643576aa.jpg" alt="" /></p><h3 id="枚举变量"><a class="markdownIt-Anchor" href="#枚举变量"></a> 枚举变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">xx</span>:<span class="type">int</span> <span class="comment">//自动递增1,从上往下</span></span><br><span class="line">&#123;</span><br><span class="line">    normal,</span><br><span class="line">    high,</span><br><span class="line">    low=xx,</span><br><span class="line">    other, other1=other<span class="comment">//多个情况</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">xx use_xxn&#123;xx::normal&#125;;</span><br><span class="line">xx use_xxh&#123;xx::high&#125;;</span><br></pre></td></tr></table></figure><p>1.提高代码的可读性和安全性</p><p>2.枚举类型默认int型</p><p>3.枚举类型成员只能是整数类型</p><p>4.枚举类型和其他类型转换需要强制转换</p><h3 id="自定义变量名称"><a class="markdownIt-Anchor" href="#自定义变量名称"></a> 自定义变量名称</h3><p>三种方式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A Typename <span class="comment">//</span></span></span><br><span class="line"><span class="keyword">typedef</span> Typename A; <span class="comment">//Typename被A替换</span></span><br><span class="line"><span class="keyword">using</span> A=Typename; <span class="comment">//同上</span></span><br></pre></td></tr></table></figure><p><strong>自定义命名空间:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> yournamespace</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ...</span><br><span class="line">    <span class="function">string</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">xx</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>变量的声明周期:</strong></p><p>变量生命在代码块结束后死亡.</p><p>全局变量的生命程序运行一直存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::xx <span class="comment">//定义后使用双冒号使用</span></span><br></pre></td></tr></table></figure><p><strong>位运算:</strong></p><p>输出二进制文件.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引用 bitset头文件</span><br><span class="line">std::<span class="built_in">bitset</span>&lt;要显示的二进制位数&gt;(要显示的变量);</span><br></pre></td></tr></table></figure><p><code>std::boolalpha 可以将流的输出控制为bool类型</code></p><p><strong>字符处理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_111853.jpg" alt="" /></p><p><strong>判断</strong></p><p>C++17语法</p><p>if(int a; check() ) {}</p><p>switch(变量声明 ；条件（）) {}</p><p><code>goto的使用 ： input&#123;代码段&#125;  ... goto input；</code></p><h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1><p>数组的地址连续</p><p>求大小</p><p><code>sizeof(a[])/sizeof(a[0])</code>  or <code>sizeof(数组名/sizeof(类型名))</code></p><p><strong>基于数组的循环</strong></p><p><code>for(变量类型 变量名称 : 数组) &#123;&#125;</code></p><p><code>for(auto 变量名称 : 数组) &#123;&#125;</code></p><h2 id="array容器"><a class="markdownIt-Anchor" href="#array容器"></a> array容器</h2><p>#include <array></p><p><code>std::array&lt; 变量类型 , 元素数量&gt; 变量名;</code></p><p><code>exp: std::array&lt;int ,5&gt;stuID; //五个学生的学号</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stuID.size();</span><br><span class="line">stuID.fill(x); //将所有元素都设置为x</span><br><span class="line">stuID.at(1); //返回stu[1]里的内容</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vector容器"><a class="markdownIt-Anchor" href="#vector容器"></a> vector容器</h2><p>array的优点基本都具备 size fill at</p><p>#include <vector></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_155716.jpg" alt="" /></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220309_160124.jpg" alt="" /></p><h1 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h1><p>c++声明指针需要初始化</p><h2 id="指针数组"><a class="markdownIt-Anchor" href="#指针数组"></a> 指针数组</h2><p><code>int* array[10] 数组里面存了10个指针</code></p><p><strong>指针详细 {待补充}</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态内存分配"><a class="markdownIt-Anchor" href="#动态内存分配"></a> 动态内存分配</h2><h3 id="c内存分配"><a class="markdownIt-Anchor" href="#c内存分配"></a> c内存分配</h3><p><code>void*  malloc</code> ： 用法{ }</p><p><code>nullptr 相当于0 （c++17新）</code></p><p><code>void* calloc(size_t count , size_t size);</code> : 为用户分配count*size字节个内存</p><p><code>void* realloc(void* _Block,size_t_size)</code> : 为用户重新分配内存，_Block是用户已经分配好的内存，Size是要求重新分配的大小</p><p><code>void* free(void* _Block)</code> : 释放内存</p><h3 id="c内存分配-2"><a class="markdownIt-Anchor" href="#c内存分配-2"></a> c++内存分配</h3><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_002002.jpg" alt="" /></p><p><strong>释放内存：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>  )  <span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">if</span> (<span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[x]) <span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure><p><strong>风险</strong></p><ul><li><p>悬挂指针：释放了还在继续使用释放掉的地址</p></li><li><p>内存碎片：频繁申请和释放小块内存会造成内存碎片，原则上可以使用，实际上使得我们无法分配新的内存.但是new和delete的算法会帮助我们尽量规避</p></li></ul><p><strong>复制内存</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220310012821.png" alt="" /></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_013233.jpg" alt="" /></p><h3 id="malloc和new本质区别"><a class="markdownIt-Anchor" href="#malloc和new本质区别"></a> malloc和new本质区别</h3><p>对于普通的数据类型来说malloc和new没什么区别,但是对于类来说,malloc仅仅是分配内存而new除了分配内存以外还会调用构造函数!</p><h3 id="free和delete本质区别"><a class="markdownIt-Anchor" href="#free和delete本质区别"></a> free和delete本质区别</h3><p>对于普通的数据类型来说free和delete没有什么区别,但是对于类来说,free仅仅是释放内存空间,而delete不仅释放内存空间,还会调用类的析构函数</p><h3 id="delete和delete本质区别"><a class="markdownIt-Anchor" href="#delete和delete本质区别"></a> delete和delete[]本质区别</h3><p>对于普通的数据类型来说deletc和delete[]没有什么区别,但是对于类来说,delete仅仅是释放内存空间,且调用第一个元素的析构函数,而delete[]不仅释放内存空间,还会调用每一个元素的析构函数</p><p>对普通数据类型无所谓</p><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><p><code>引用的本质其实就是一种被阉割了的指针，虽然我们取址引用变量得到的是原地址的内存地址，但是引用变量也是占用内存的</code></p><p>引用需要初始化</p><p>提高代码效率，{个人觉得类似于软连接}</p><p>语法： <code>数据类型&amp;变量名称&#123;引用对象的名称&#125;；</code></p><p><code>exp： int a&#123;500&#125;;  int&amp; la&#123;a&#125;;</code> la=500即a=5200.</p><h2 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h2><h3 id="stdunique_ptr"><a class="markdownIt-Anchor" href="#stdunique_ptr"></a> std::unique_ptr</h3><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_015706.jpg" alt="" /></p><p>第一种声明不允许用数组方式访问，第二种可以。</p><p>智能指针不允许指向别的智能指针。具有唯一性。</p><p><strong>用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reset();</span><br><span class="line">//reset将会释放std::unique_ptr的内存空间，并且设置为nullptr</span><br><span class="line">get();</span><br><span class="line">//get返回std::unique_ptr的指针</span><br><span class="line">release();</span><br><span class="line">//release返回std::unique_ptr的指针,并且设置为nullptr，但是不会释放占用的内存空间</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_021212.jpg" alt="" /></p><h3 id="stdshared_ptr"><a class="markdownIt-Anchor" href="#stdshared_ptr"></a> std::shared_ptr</h3><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220310_021553_edit_658178805450610.jpg" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr的复制</span><br><span class="line">std::shared_ptr&lt;int&gt; ptrA&#123;&#125;</span><br><span class="line">std::shared_ptr&lt;int&gt; ptrB&#123;std::make_shared&lt;int&gt;(5)&#125;;</span><br><span class="line">ptrA=ptrB;</span><br><span class="line">··························································</span><br><span class="line">//获得计数</span><br><span class="line">long std::shared_ptr.use_count();</span><br><span class="line">.use_count();会返回当前指针共有多少个对象调用</span><br><span class="line"></span><br><span class="line">bool std::shared_ptr.unique();</span><br><span class="line">//unique()会返回以一个bool值，if当前智能指针是唯一拥有该指针的人，返回true</span><br><span class="line"></span><br><span class="line">std::shared_ptr.reset();</span><br><span class="line">//将当前共享指针设置为nullptr，如果是最后一个拥有该指针的对象，释放内存</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>特性</strong></p><p>可以有多个std::shared_ptr指向同一地址，同一地址下只有最后一个std::shared_ptr释放的时候，才会释放其所占用的空间，std::shared_ptr会记录当前有多少个智能指针调用</p><h2 id="c原生字符串"><a class="markdownIt-Anchor" href="#c原生字符串"></a> C原生字符串</h2><p>字符串就是指针，数组</p><p>&lt;! 待补充 --&gt;</p><p><code>wchar_t str[0xff]&#123;L&quot;HEllo&quot;&#125;;</code> 宽字节常量</p><p>（使用utf-16实现UNICODE）</p><p><code>使用UNICODE标准 ： setlocale(LC_ALL,&quot;chs&quot;)</code>  <code>使用wcout输出</code></p><p>std::cout 默认输出char类型的值时会当作字符串进行处理。</p><h2 id="联合体-union"><a class="markdownIt-Anchor" href="#联合体-union"></a> 联合体 union</h2><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 联合体名称</span><br><span class="line">&#123;</span><br><span class="line">    变量类型 变量名称;</span><br><span class="line">    变量类型 变量名称;</span><br><span class="line">&#125;</span><br><span class="line">exp:</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">user</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">short</span> shp;</span><br><span class="line">    <span class="type">int</span>   xhp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过union可以创建一个联合体，union中的成员变量共享内存，因此 <strong>union的数据类型大小由其最大的成员变量决定</strong></p><p>union中任意一成员变量发生改变都可能影响别的变量</p><p><strong>匿名联合体、结构体</strong></p><p>顾名思义，没有名字的联合体和结构体</p><p>一般只用一次</p><h2 id="c字符串string"><a class="markdownIt-Anchor" href="#c字符串string"></a> C++字符串string</h2><p><code>#include &lt;string&gt;</code></p><p>定义： <code>std::string str&#123;&quot;wow!&quot;&#125;;</code></p><p><code>std::string 变量名称&#123; &quot;字符串&quot; , 要截取的长度&#125;</code></p><p>exp：<code>string str&#123;&quot;1234&quot;,2&#125;; str=&quot;12&quot;</code></p><p><code>std::string 变量名称&#123; &quot;字符串&quot; ，起始位置 ， 要截取的长度&#125;</code></p><p><code>std::string 变量名称(要复制的个数，'字符')</code></p><p><strong>连接字符串</strong> <code>std::string str(6,'a');   str=str+&quot;123;  str=&quot;aaa123&quot;</code></p><p><strong>连接字符串和数字</strong> <code>std::string str = std::to_string(数字)；</code></p><p><strong>字符串连接字符串</strong></p><p>字符串不能直接和别的字符串连接，可以使用临时变量解决(std::string(xx));</p><p>可以 <code>&quot;变量&quot;&quot;变量&quot;  变成&quot;变量变量&quot;</code></p><p>也可以<code>str.append(&quot;你要拼接的内容&quot;)</code> 可以无限加</p><p><strong>字符串连接字符</strong>  直接+‘字符’  即可</p><p><strong>截取字符串</strong> <code>.substr(起始位置，要截取的长度); or .substr(起始位置)</code></p><p><strong>长度</strong> <code>std::string.length();</code> 得到长度</p><p><strong>字符串比较</strong> <code>.compare()   比如： str.compare(&quot;abcd&quot;);</code> 大于返回正数，相等等于0；</p><p>扩展： <code>.compare(起始位置,参与比较的长度,被比较的字符串);</code></p><p><strong>字符串搜索</strong></p><p><code>.find()</code> 用来搜素字符串的内容,并返回内容所在的位置,当返回值是<code>std::string::npos</code>表示未找到</p><p><code>.find(要搜索的内容 , 开始搜索的位置)</code></p><p><code>.find(要搜索的内容,开始搜素的位置,要纳入的字符串长度[注:是搜索内容的字符串])</code></p><p><code>.rfind()</code> 用法和<code>find</code>一样,从字符串尾部<strong>倒叙搜索</strong></p><p><strong>插入字符串</strong></p><p><code>.insert()</code> 可以在一个string字符串的指定位置插入另一个字符串</p><p><code>.insert(要插入的位置 , 要插入的字符串)</code></p><p><code>.insert(要插入的位置,要插入的字符个数,要插入的字符)</code> exp:id.insert(3,6,‘x’);</p><p><code>.insert(要插入的位置,要插入的字符串,要插入的字符串的起始位置,要插入的大小)</code></p><p><code>.insert(要插入的位置,要插入的字符串,要插入的大小)</code></p><p><strong>替换字符串</strong></p><p><code>.replace</code> 可以替换string字符串中的内容</p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot;)</code></p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot; ,'字符') </code>对单字符</p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot; ,替换后内容节选长度[此处是替换的字符串的])</code></p><p><code>.replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot;,替换后的起始位置,替换后内容的节选长度</code></p><p><strong>删除字符串</strong></p><p>``.erase()` 删除字符串中的内容</p><p><code>.erase(要删除的起始位置,要删除的起始长度)</code></p><p><code>.erase(要删除的起始位置)</code> exp: 从起始位置删除所有的内容</p><p><code>str.clear();</code></p><h3 id="指针数组字符串内存学习"><a class="markdownIt-Anchor" href="#指针数组字符串内存学习"></a> 指针数组字符串内存学习</h3><p>{待补充}</p><p><strong>想得到放字符串这段内存的区域</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220311_164550.jpg" alt="" /></p><p>不能修改!</p><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><p>exp：输入中文英文等字符串，正确返回字符个数</p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_012145.jpg" alt="" /></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_012436.jpg" alt="" /></p><p>待补充</p><h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><p><strong>指针参数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_025458.jpg" alt="" /></p><p><strong>数组参数</strong></p><p>建议用数组方式引用</p><p><strong>引用参数</strong></p><p>指针可以传入nullptr，而引用不可以</p><p><strong>默认实参</strong></p><p>exp： <code>void func(int a,int&amp; b,int* c,bool x=true)</code></p><p>此时用户根据需要调用func时x可写可不写，不写默认是true</p><p>！<strong>默认实参只能放在最后</strong> 引用定义的时候不能瞎指</p><p><strong>不定量参数</strong></p><p><code>mian（int argc,char** argc）&#123;&#125;</code> C语言也常用</p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220312_224012_edit_807927517925156.jpg" alt="" /></p><p><strong>函数返回：返回指针和引用</strong></p><p>{知识很多 待补充}</p><p>比如返回结构体 ，返回指针，返回引用，传递引用参数时的类型转换</p><p>数组的引用：</p><p>exp： <code>int a[100]  int(&amp;b)[100]=a</code></p><p>传递数组引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> (&amp;array)[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sizeof</span>(ary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数参数右值引用"><a class="markdownIt-Anchor" href="#函数参数右值引用"></a> 函数参数：右值引用</h2><p>ps：函数使用引用会节约内存消耗</p><p>左值就是一般左边定义的东西有明确的内存空间 可以读取写入，右值是存放在临时空间内</p><p>exp：<code>*(a+1)=2</code>  此事a+1仍然是一个右值</p><p><code>int&amp;&amp;</code> 右值引用 exp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; e = <span class="number">100</span>+<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123; std::cout&lt;&lt;a; &#125;</span><br><span class="line"><span class="built_in">Add</span>(e+<span class="number">320</span>+<span class="number">329</span>);</span><br></pre></td></tr></table></figure><p>设计字符串类的时候会感受到…</p><p>exp: 创建一个临时的角色信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Role <span class="title">createmonster</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Role rt&#123;<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(Role&amp;&amp; rl)</span><span class="comment">//没有分配内存空间却达到了同样的效果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;rl.hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220313_022431_edit_817161374477392.jpg" alt="" /></p><h2 id="函数的本质"><a class="markdownIt-Anchor" href="#函数的本质"></a> 函数的本质</h2><p>loading</p><h2 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h2><p>可以指向特定类型函数的指针</p><p>函数返回类型 (*函数指针变量名)(参数类型 参数名称, …参数类型 参数名称);</p><p><strong>转类型</strong> <code>char (*myadd)(int,int)=(char (*)(int,int)Add);</code></p><p>强转太长了怎么办:</p><p><code>typedef函数返回类型 (*函数指针变量名)(参数类型 参数名称,....参数类型 参数名称);</code></p><p>也可以: <code>using pfadd=char (*)(int,int);</code></p><h2 id="函数重载"><a class="markdownIt-Anchor" href="#函数重载"></a> 函数重载</h2><p>C++有，c语言需要自己实现，不自带此功能</p><p>尽管函数名称相同,但是在我们调用函数时,通过函数参数的不同,编译器还是能够确定我们调用的是哪一个函数,因此程序能够准确的编译</p><p>！ 是参数的不同可以确定是哪个函数。</p><p>但是编译器无法单纯通过返回值来确定你要返回的函数,参数要不同!</p><p>exp: <code>float ave()    和    int ave()</code>   无法重载</p><p>exp: 同样的函数,用指针和数组写法不能重载,引用也不行</p><p>Tips:为什么俩个函数,有一个int&amp; 一个float ,我定义了char变量去调用,强转为(int)x型,去调用函数却仍然是float函数,因为<strong>强转只是声明了一个临时的变量,而引用需要已经定义的(真实存在的)变量</strong></p><p>同样的函数,一个int 一个const int也不行(会出现歧义)</p><p>但是一个是int的引用int&amp;  一个是 const int&amp; 常量引用,那就可以重载</p><p>函数重载的时候不可以设置默认参数</p><h2 id="函数模板"><a class="markdownIt-Anchor" href="#函数模板"></a> 函数模板</h2><p>除了类型不同外,函数的运算逻辑都一样,这样的函数我们就可以利用函数模板技术来生成对应的函数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b)</span><span class="comment">//ave求平均值的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//ave相当于int ave(int a,int b)</span></span><br><span class="line"><span class="type">char</span> a=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//ave相当于char ave(cahr a,char b)</span></span><br><span class="line">exp:</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b,type1 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    type1 a;<span class="comment">//可以定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (a+b+c)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以指定一个函数模板</span></span><br><span class="line">exp： <span class="built_in">ave</span>&lt;<span class="type">int</span>&gt;(<span class="number">192.0f</span>,<span class="number">159.3f</span>); <span class="comment">// 执行int ave</span></span><br></pre></td></tr></table></figure><h3 id="函数模板和重载"><a class="markdownIt-Anchor" href="#函数模板和重载"></a> 函数模板和重载</h3><p>函数模板的例外处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1&gt; <span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="type">float</span> <span class="title">ave</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b<span class="number">-100.0f</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">我们可以利用<span class="keyword">template</span>&lt;&gt;定义一种函数模板的例外情况</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数重载优先于函数模板,但是函数模板的例外情况要优先于函数重载</strong></p><p>函数模板的重载 函数模板的重载也是通过参数来区分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="推断函数模板返回类型多不同类型"><a class="markdownIt-Anchor" href="#推断函数模板返回类型多不同类型"></a> 推断函数模板返回类型(多不同类型)</h3><p>返回值,传入参数都不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">temp1ate &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b+c)/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同时调用的时候可以 ave&lt;int,int&gt;();类似于这样强行更改类型</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">type1 <span class="title">ave</span><span class="params">(type1 a,type2 b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a+b+c)/<span class="number">2</span>;</span><br><span class="line">M</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> typeR,<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">typeR <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line"><span class="built_in">bigger</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>,<span class="number">120.2f</span>);</span><br><span class="line"><span class="built_in">bigger</span>&lt;<span class="type">int</span>,<span class="type">float</span>,<span class="type">int</span>&gt;(<span class="number">100</span>,<span class="number">120.2f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//### 如何更加智能的推断-&gt; (c++14后)</span></span><br><span class="line">temp1ate &lt;<span class="keyword">typename</span> typeR,<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function">typeR <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以利用auto来推断返回值的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(type1 a,type2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ab?a:b;)</span><br><span class="line">&#125;</span><br><span class="line">注*<span class="keyword">auto</span>做返回类型推断是在C++<span class="number">14</span>之后引入的</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(type1 a,type2 b-&gt;<span class="keyword">decltype</span>(a&gt;b?a:b)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> a&gt;b?a:b;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) bigger(type1 a,type2 b) <span class="comment">//decltype(auto)可以通过引用更改值</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> a&gt;b?a:b;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//decltype(auto)为C++14后的写法</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br></pre></td></tr></table></figure><h3 id="函数模板参数"><a class="markdownIt-Anchor" href="#函数模板参数"></a> 函数模板参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充 很多</span><br></pre></td></tr></table></figure><h3 id="函数模板本质"><a class="markdownIt-Anchor" href="#函数模板本质"></a> 函数模板本质</h3><p>待补充</p><h2 id="auto-and-decltype"><a class="markdownIt-Anchor" href="#auto-and-decltype"></a> auto and decltype</h2><p>c++11之后出现</p><p>auto可以声明一个变量,让编译器根据变量的值来推断变量的类型</p><p>例如<br /><code>auto a&#123;123&#125;;</code> 相当于``int a{123;<code> </code><br />利用auto的这一特性我们可以利用auto来创建一个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">注*以上都并非<span class="keyword">auto</span>的最恰当用法,不管是函数还是变量,都不推荐使用<span class="keyword">auto</span>来声明</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="auto"><a class="markdownIt-Anchor" href="#auto"></a> auto</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>不能保留<span class="type">const</span>属性</span><br><span class="line">比如</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> c = a;</span><br><span class="line">c是<span class="type">int</span>类型而非<span class="type">const</span>类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> 会优先推断为值类型而非引用类型</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; la=a;</span><br><span class="line"><span class="keyword">auto</span> d=a;</span><br><span class="line">d为<span class="type">int</span>类型而非<span class="type">int</span>&amp;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span>利用函数返回值来确定类型的时候,函数会执行</span><br><span class="line"><span class="keyword">auto</span> x=<span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//ave(1,2)会执行x的类型依据ave函数的返回类型来确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span>会优先把值匹配成值类型而非引用类型,就以本例来说</span><br><span class="line">假设我们希望bigger函数返回的是<span class="type">int</span>&amp; 用<span class="keyword">auto</span>声明达不到这样的效果,为了达到这种目的,我们可以使用另外一种技术:  拖尾函数</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bigger</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span>-&gt;<span class="type">int</span>&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="decltype"><a class="markdownIt-Anchor" href="#decltype"></a> decltype</h3><p>decltype关键字可以得出一个表达式的类型;</p><p>语法:decltype(表达式)<br /><code>int a&#123;&#125;;</code><br /><code>unsigned b;</code><br /><code>decltype(a-b) x;相当于unsigned x;</code></p><p>如果decltype内的表达式没经历任何运算,那么得出的数据类型同表达式内的数据类型,并且<strong>decltype可以保留const和引用类型</strong> .</p><p>编译器依处理decltype关键字时的原则:</p><p>如果decltype内的表达式经历了运算,那么得出的数据类型是根据运算结果是否有固定的内存地址(左值)来决定的,如果有固定的内存地址则得出的类型为该类型的引用类型,如果没有固定的内存地址,则得出的类型为该结果的类型.</p><p>如果decltype内的表达式是一个函数,那么得出的数据类型是根据函数的返回类型来确定的;(decltype不会执行函数)</p><h2 id="staticonly变量-and-inline"><a class="markdownIt-Anchor" href="#staticonly变量-and-inline"></a> static(only变量) and inline</h2><h3 id="static"><a class="markdownIt-Anchor" href="#static"></a> static</h3><p>利用static可以声明一个静态变量    static类型变量名称;<br />例如:<br />static int a;<br />static的变量,如果没有指定初始化的值,那么会初始化为0,无论有没有指定初始值,都只会初始化一次!</p><p>exp: count不会只会在函数被初始化一次,生命周期很长,值会保留</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inline"><a class="markdownIt-Anchor" href="#inline"></a> inline</h3><p>inline int Add(int a,int b){<br />return a+b;<br />}<br />我们可以用inline声明一个内联函数<br />内联函数将会建议编译器把这个函数处理成内联代码以提升性能<br />始终是建议,具体编译器是否采纳,由编译器决定</p><p>[有些过时了]</p><h2 id="extern"><a class="markdownIt-Anchor" href="#extern"></a> extern</h2><h2 id="函数一些理论"><a class="markdownIt-Anchor" href="#函数一些理论"></a> 函数一些理论</h2><h3 id="理解定义和声明"><a class="markdownIt-Anchor" href="#理解定义和声明"></a> 理解定义和声明</h3><p>我们写的函数就是函数的定义</p><p>因为函数的定义是我们要告诉计算机具体如何来执行我们的命令,所以这个命令必须是明确的,你不能告诉它同时往东并且往右,这就说明我们编写代码的时候,你不能多次定义一个函数!<br />因此函数的定义只能有一次!<br />但是函数的声明是我们和编译器的对话,在某些特殊的场景下,我们可以多次声明一个函数!<br />虽然编译器觉得我们啰嗦,但是并不影响我们之前的感情。</p><p>声明的本质是与编译器的对话,单纯的声明并不存在内存的分配,只是给编译器一个大体的概念，既然是对话,我们可以多次对话,所以对于同一个事物,我们可以多次声明;<br />而定义的本质是要通过编译器与计算机对话,这就涉及到内存的分配和访问,因此同一事物,不管声明多少次,但是只能有一次定义;<br />变量其实也适用这个规则,我们可以通过关键字extern声明一个变量,而把变量的声明和定义分开;<br />我们写函数的声明的时候,没有写extern关键字,是因为函数的声明本身就是extern的,因此不需要我们手动指出;<br />extern 的作用也是告诉编译器,此处只是一个声明,你去别处找定义,因此extern是针对的全局变量，因为局部变量不存在去别U找的可能性!而函数的声明自带extern属性,因此函数本身也是全局的!<br />例如: <code>extern int a;</code></p><p>函数名是内存地址</p><h3 id="头文件和源文件"><a class="markdownIt-Anchor" href="#头文件和源文件"></a> 头文件和源文件</h3><p>多个源码共用一个全局变量<br />在头文件中声明多个源文件中要共用的全局变量<br />察<br />比如<br /><code>extern int verId;</code><br />至于verld的定义你可以放到任何源文件中,但是不可以放到头文件中,因为这样就违背了乎个事物只能定义一次的原则!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">放在头文件中的第一行,可以防止头文件被多次调用</span><br><span class="line"></span><br><span class="line">#ifndef</span><br><span class="line">#define</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="创建自己的sdk"><a class="markdownIt-Anchor" href="#创建自己的sdk"></a> 创建自己的SDK</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION <span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">xx</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">namespace</span> my_sdk</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Getversion</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤:(vs环境) 做成静态库</p><p>右键属性-&gt;配置类型.静态库 .lib-&gt;右键属性 . 生成-&gt;打开文件夹 库做好了 .lib</p><p>使用时:<br />右键属性-&gt;包含目录 放入自己的lib-&gt;库目录 加入自己的.h目录-&gt;</p><p>几种方法: 1: <code>#pragma comment(lib,&quot;xxx.lib&quot;)</code></p><p>2: 右键属性-&gt;链接器-&gt;输入-&gt;附加依赖项(库目录需要有)</p><h3 id="创建项目类型"><a class="markdownIt-Anchor" href="#创建项目类型"></a> 创建项目类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### 函数调用约定</span><br><span class="line"></span><br><span class="line">函数调用约定是函数调用与被调用者之间的一种协议,这个协议主要规定了以下两个内容:</span><br><span class="line"></span><br><span class="line">`如何传递参数` `如何恢复栈平衡`</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">函数调用约定_cdecl:</span><br><span class="line">__cdecl参数入栈顺序从右到左</span><br><span class="line">堆栈平衡:谁调用谁平衡</span><br><span class="line">正因为__cdecl这种堆栈平衡方式,能够支持不定量参数</span><br><span class="line"></span><br><span class="line">函数调用约定_stdcall</span><br><span class="line">___stdcall参数入栈顺序从右到左次</span><br><span class="line">堆栈乎衡:函数自己恢复栈平衡</span><br><span class="line">Windows编程中WINAPICA1LBACK都是__stdcall的宏</span><br><span class="line">生成的函数名会加下划线,后面跟@和参数尺寸</span><br><span class="line">int _stdcallave(int a, int b)</span><br><span class="line"></span><br><span class="line">函数调用约定__fastcall</span><br><span class="line">第一个参数通过ecs传递第二个参数通过edx传递</span><br><span class="line">剩余参数入栈顺序从右到左</span><br><span class="line">堆栈乎衡:函数自己恢复栈平衡</span><br><span class="line">fastcall的函数执行速度比较快</span><br><span class="line"></span><br><span class="line">_thiscall 用作C++中类的访问,我们将在类的底层时讲这种callnaked call是一个不常用的调用约定,一般用于实模式驱动开发</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归函数"><a class="markdownIt-Anchor" href="#递归函数"></a> 递归函数</h3><p>套娃&gt;&gt;&gt;</p><p>a调用b,b调用a称为互递归函数</p><p>递归会造成栈溢出</p><p>内联函数不能递归</p><h1 id="编译器"><a class="markdownIt-Anchor" href="#编译器"></a> 编译器</h1><h2 id="理论"><a class="markdownIt-Anchor" href="#理论"></a> 理论</h2><h3 id="转换单元"><a class="markdownIt-Anchor" href="#转换单元"></a> 转换单元</h3><p>我们写好的每个源文件(.cpp,.c)将其所包含的头文件(#include &lt;xxx.h&gt;)合并后,称为一个转换单元;<br />编译器单独的将每一个转换单元生成为对应的对象文件(.obj),对象文件包含了转换单元的机器码和转换单元的引用信息(不在转换单元中定义的对象);<br />最后<strong>链接器将各个转换单元的对象文件链接起来,生成我们的目标程序;</strong><br />比如在对象文件A中包含了定义在其他转换单元的引用,那么就去其他转换单元的对象文件中寻找这个引用的定义来建立链接,如果在所有的对象文件中都找不到这个定义,那么就会生成一个链接错误.</p><h3 id="未定义行为"><a class="markdownIt-Anchor" href="#未定义行为"></a> 未定义行为</h3><p>即我们在编写代码中,C<ins>标准未作规定的行为,称为未定义行为,未定义行为的结果是不确定的,具体在不同的编译器下会有不向的效果; 比如<br /><code>c=2*a++ + ++a*6;</code><br />这里先算a</ins>还是先算++a就是一个未定义行为<br />比如:<br /><code>int x=-25602;×=x&gt;2;</code><br />x的结果在不同的编译器下是不确定的,因为这也属于未定义行为</p><h3 id="one-definition-rule"><a class="markdownIt-Anchor" href="#one-definition-rule"></a> One Definition Rule</h3><p><strong>单一性规则</strong></p><p>ODR是一系列规则,而不是一个规则,程序中定义的每个对象都对应着自己的规则;<br />但是基本上来讲任何的变量,函数,类,枚举,模板,概念(C<ins>20)在每个转换单元中都只允许有一个定义;非inline的函数或变量(C</ins>17),在整个程序中,有且仅有一个定义;</p><p>总结: 有多个声明 , 只能有一个定义</p><h3 id="名称的链接属性"><a class="markdownIt-Anchor" href="#名称的链接属性"></a> 名称的链接属性</h3><p>程序中的变量,函数,结构等都有着自己的名字,这些名字具有不同的链接属性,链接器就是根据这些链接属性来把各个对象文件链接起来的;<br />链接属性分为以下三种:<br />内部链接属性:该名称仅仅在本转换单元中有效<br />外部链接属性:该名称在其他的转换单元中也有效<br />无链接属性:该名称仅仅能够用于该名称的作用域内访问</p><h2 id="define"><a class="markdownIt-Anchor" href="#define"></a> define</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A B</span></span><br><span class="line">将标识符A定义为B的别名</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>整数int</span></span><br><span class="line">整数a&#123;&#125;;</span><br><span class="line"></span><br><span class="line">取消定义： <span class="meta">#<span class="keyword">undef</span></span></span><br><span class="line">    </span><br><span class="line">定义复杂表达式的宏：</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUM(X,Y)  X+Y</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AVE(X,Y)  (X+Y)/2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIGGER(X,Y)  ((X)&gt;(Y)?(X):(Y))</span></span><br><span class="line"><span class="built_in">SUM</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"><span class="built_in">AVE</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"><span class="built_in">BIGGER</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">#可以将一个标识符参数字符串化</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW(X) std:cout&lt;&lt;#X <span class="comment">//字符串</span></span></span><br><span class="line"><span class="built_in">SHOW</span>(<span class="number">1234f</span>g);=&gt;std:cout&lt;&lt;<span class="string">&quot;12345fg&quot;</span></span><br><span class="line">##可以连接两个标识符</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T1(X,Y) void X##Y()&#123;std:cout&lt;&lt;#Y;&#125; <span class="comment">//连接字符串</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用#define 的方式定义常量并不安全.</p><h2 id="namespace"><a class="markdownIt-Anchor" href="#namespace"></a> namespace</h2><p>有时候为了方便管理,把相关的函数,变量,结构体等会附加到一个命名空间中<br /><code>namespace t  &#123;int value;&#125;</code><br />访问这个命名空间的变量<br /><code>t:value</code></p><p>所有具有链接属性的对象,只要没有定义命名空间,就默认定义在<code>全局命名空间</code>中,全局命名空间中成员的访问不用显示的指定,当局部名称覆盖了全局名称时才需要显式的指定全局命名空间;<br /><code>int a;  ::a=250</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局命名空间的扩展</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> weight &#123;<span class="number">1980</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> height&#123;<span class="number">1080</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">第二个htd属于对htd命名空间的扩展,weight和height同属一个命名空间</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间拓展</span></span><br><span class="line"><span class="function"><span class="keyword">namespace</span> htd</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="type">void</span> htd:<span class="built_in">sendSms</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间的嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">namespace</span> hack</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hackServer</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> htd::hack::<span class="built_in">hackServer</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">htd::sendSms</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未命名空间</span></span><br><span class="line">不给命名空间指定名称,将会声明一个未命名的命名空间</span><br><span class="line"><span class="keyword">namespace</span> &#123;&#125;</span><br><span class="line">未命名的命名空间中声明的内容一律为内部链接属性,包括用<span class="keyword">extern</span>声明的内容,未命名的命名空间仅仅在本转换单元中有效</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间的别名</span></span><br><span class="line"><span class="keyword">namespace</span> htd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSms</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">namespace</span> hack&#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hackServer</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> hServer=htd::hack;</span><br><span class="line">hSever:<span class="built_in">hackServer</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="预处理逻辑指令"><a class="markdownIt-Anchor" href="#预处理逻辑指令"></a> 预处理逻辑指令</h2><p><code>#ifndef    #if    #elif     </code></p><h2 id="预定义宏"><a class="markdownIt-Anchor" href="#预定义宏"></a> 预定义宏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//标准预定义宏</span><br><span class="line">__func__</span><br><span class="line">编译器支持ISO C99和ISO C++11指定的预定义标识符</span><br><span class="line">函数的名称</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_025308.jpg" alt="" /></p><p>//下面是微软公司做的宏</p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_025523.jpg" alt="" /></p><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><p>为了方便调试,在编码风格上:</p><p>1 模块化<br />2 使用能够体现出具体意义的函数名和变量名</p><p>3 使用正确的缩进和代码块<br />4 良好的注释习惯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补充。。。</span><br></pre></td></tr></table></figure><h2 id="assert调试-断言"><a class="markdownIt-Anchor" href="#assert调试-断言"></a> assert调试 （断言）</h2><p>语法:<br />assert(bool表达式);<br />如果括号内的bool表达式为false<br />则会调用std:abort()函数<br />弹出对话框<br />assert宏需要头文件 cassert</p><p>可以通过 <code>#define NDEBUG</code> 关闭 要放在include前</p><p>static_assert用于编译时检查条件<br />static_assert(bool表达式,“错误信息”);<br />C++17新语法：<br />static_assert(bool表达式);<br />与assert不同,static_assert主要是用来在编译时检查重要的条件</p><p>因此检查的bool表达式中,只能用于常量</p><h1 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h1><p><a href="https://blog.csdn.net/u010183728/article/details/81913729?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164728551916780271586411%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164728551916780271586411&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-81913729.142%5Ev2%5Epc_search_insert_es_download,143%5Ev4%5Econtrol&amp;utm_term=stl&amp;spm=1018.2226.3001.4187">STL介绍</a></p><h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1><h2 id="oop"><a class="markdownIt-Anchor" href="#oop"></a> OOP</h2><p>00P(Object Oriented Programming)即面向对象编程,本质上是一种编程思想,通过把我们编程中遇到的事物来抽象成对象来编程;与OOP相关的还有OOD(面向对象设计),00A(面向对分析)等;<br />OOP应当遵循OOD的原则,所有坏的OOP代码基本都是违反了OOD原则</p><p>SOLID原则 { 待百度 }</p><h3 id="面向对象的特点"><a class="markdownIt-Anchor" href="#面向对象的特点"></a> 面向对象的特点</h3><p>封装：</p><p>继承：</p><p>多态：</p><h2 id="定义类"><a class="markdownIt-Anchor" href="#定义类"></a> 定义类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:<span class="comment">//影响后面出现的内容 只能类中使用</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//公开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数"><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hpRecover;-&gt;&gt;成员变量</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> -&gt;&gt;成员函数</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    hpRecover=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;-&gt;&gt;成员变量</span><br><span class="line">    <span class="type">int</span> damage; -&gt;&gt;成员变量</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span>-&gt;&gt;成员函数</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    role.hp-=damage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>;<span class="comment">//外部定义后需要定义成这样</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类的外部定义成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ROLE::Act</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>空class默认一个内存空间</p><p>inline成员函数： （推荐写在头文件里）</p><h3 id="this指针"><a class="markdownIt-Anchor" href="#this指针"></a> this指针</h3><p>成员函数的指针 ， 代表定义的成员本身</p><h2 id="const"><a class="markdownIt-Anchor" href="#const"></a> const</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetHP</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Role::GetHP</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const对象只能调用const成员函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const对象不能以任何方式改变,这是const的原则,在这个基本原则下,产生了一些列效应,比如const对象只能调用const成员函数; const对象无法调用别的成员<br />另外一个我们不注意的变化是,在const成员函数下,this指针也变成了const指针</p><p><strong>const类型转换</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220315_174156.jpg" alt="" /></p><p><strong>mutable</strong></p><p>mutable声明的成员变量可以被const成员函数修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> getHPCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> GetHP0 <span class="type">const</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> Role:GetHP0 <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">getHPCont++;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h2><p>在类的定义中有一种特殊的成员函数叫做构造函数.构造函数在类被创建时自动被调用,一般用来创建新的类实例时执行初始化操作构造函数与它所在的类同名,并且没有返回值,任何类都至少有一个构造函数;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hpRecover;</span><br><span class="line">    <span class="type">void</span> lnit0</span><br><span class="line">    &#123;</span><br><span class="line">        hpRecover=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ROLE</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Act</span><span class="params">(ROLE&amp; role)</span></span>&#123;</span><br><span class="line">        role.hp-=damage;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//跟java一样 ， 构造函数和类同名</span></span><br><span class="line">如果什么都不做 推荐<span class="built_in">Role</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><h3 id="explicit关键字"><a class="markdownIt-Anchor" href="#explicit关键字"></a> explicit关键字</h3><p>被explicit关键字修饰的构造函数会禁用类型转换</p><h3 id="成员初始化列表"><a class="markdownIt-Anchor" href="#成员初始化列表"></a> 成员初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ROLE</span>(<span class="type">int</span> _lv,<span class="type">int</span> _damage):lv&#123;_lv&#125;, damage&#123;_damage&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>初始化时，初始化可以这样写快速初始化</p><p>效率更高，有时候只能这样去初始化</p><p><strong>使用成员初始化列表这样的方式构造类,要注意一个问题,即为成员赋值的顺序不是依据代码的顺序,而是成员变量在类的出现顺序;</strong></p><p><strong>委托构造函数初始化列表里不能初始化成员变量且只能调用一次同一个类的构造函数</strong></p><p><code>ROLE(int _lv,int xx):ROLE(_lv)</code> 这种是委托构造，关于lv的都在ROLE这个构造函数里</p><p>副本构造函数</p><p>编译器为类指定了一个默认的副本构造函数,我们也可以手动指定副本构造函数</p><p><code>Role role1;   Role role2(role1);</code></p><h2 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h2><p>在类中还有一种特殊的成员函数,叫做析构函数,析构函数在类的生命周结束时,被自动调用,一般用来做 扫尾工作 比如释放内存,关闭句柄等等,如果一个类没有定义析构函数,那么编译器会自动添加一个空的析构函数,析构函数只能有一个;<br />析构函数没有参数,没有返回类型,一般不会手动调用,如果类的析构函数为空,最好使用关键字default来定义,例如:<br /><code>~ROLE()=default;</code></p><h2 id="静态成员变量"><a class="markdownIt-Anchor" href="#静态成员变量"></a> 静态成员变量</h2><p>我们可以在类中通过static关键字声明一个类的静态成员变量,类的静态成员变量的特点:<br />1 所有类的实例中,共享类中的静态成员变量</p><p>2 类的静态成员变量在没有类的实例的情况下,依然可以访问</p><p>3 类的静态成员变量并不完全属于类 内存空间不属于类</p><p>实例类不管多少个，static都不变，被所有实例共享一个内存空间</p><p>c++17后 可以 <code>inline static int count&#123;20&#125;</code> 来定义</p><p><code>const static int count&#123;20&#125;</code></p><h2 id="静态成员函数"><a class="markdownIt-Anchor" href="#静态成员函数"></a> 静态成员函数</h2><p>我们可以利用static关键字声明一个类的静态成员函数,类的静态成员函数有如下特点:</p><p>(1)不管有没有创建类的实例,都可以访问类的静态成员函数<br />(2类的静态成员函数不能访问非静态的成员变量<br />(3)类的静态成员函数不能是const<br />(4)类的静态成员函数不能使用this指针</p><h2 id="友元"><a class="markdownIt-Anchor" href="#友元"></a> 友元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">可以通过<span class="keyword">friend</span>关键字声明一个函数为某个类的友元函数,友元函数可以访问该类中的所有成员</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ResetHP</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetHP</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t.<span class="built_in">ResetHP</span>();</span><br><span class="line">    t.hp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>俩个类交朋友的话 在另一个类上面声明 <code>class 类名</code> 即可</p><p>友元 不建议用</p><h2 id="嵌套类"><a class="markdownIt-Anchor" href="#嵌套类"></a> 嵌套类</h2><p>把一个类写在一个类里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Weapon</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> lv;</span><br><span class="line">    &#125;;</span><br><span class="line">我们可以在类的声明中再声明一个类,在类中声明的类称为嵌套类,而声明嵌套类的类称为外层类</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>作用域</strong></p><p>嵌套类的声明在外层类中,因此嵌套类的作用域受外层类限定</p><p>假如要在类外声明女个Weapon对象<br /><code>Role::Weapon mWpon;</code><br />嵌套类的作用域受封装属性管辖,即private封装的嵌套类是无法在类外使用的</p><p><strong>在类外定义嵌套类</strong></p><p><code>class ROLE::Weapen</code> 在外的类要这么写 。  函数、对象同理</p><p>函数指针情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span>;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>::Weapon&#123;</span><br><span class="line"><span class="function">Weapon*<span class="title">CreateWeapon</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Role::Weapon* Role::Weapon::<span class="built_in">CreateWeapon</span>()&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>嵌套类可以访问外层类的所有成员<br />外层类仅能访问嵌套类的公有成员</p><p><strong>局部类</strong></p><p>定义在函数内的类称为局部类</p><p>局部类的定义必须写在类内</p><p>局部类中不允许使用静态成员变量</p><p>局部类可以访问全局变量</p><p><strong>嵌套类模块化问题</strong></p><p>多文件时。嵌套头文件，类出错  注意头文件</p><h2 id="类的成员函数的函数指针"><a class="markdownIt-Anchor" href="#类的成员函数的函数指针"></a> 类的成员函数的函数指针</h2><h2 id="从底层理解类逆向"><a class="markdownIt-Anchor" href="#从底层理解类逆向"></a> 从底层理解类（逆向）</h2><p>{待补充}</p><h1 id="重载"><a class="markdownIt-Anchor" href="#重载"></a> 重载</h1><h2 id="运算符重载"><a class="markdownIt-Anchor" href="#运算符重载"></a> 运算符重载</h2><p>在OOP编程中,万物皆对象,我们如何让这些对象也能够像普通类型一样实现加减乘除呢?比如我们学习过的std:string对象<br /><code>std:string str=&quot;大家好!&quot;;</code><br /><code>str=str+”才是真的好!&quot;;</code><br />要实现这个功能我们就要对运算符+重新进行设计,当我们的对象进行+运算时不再是编译器默认的+预算,而是进入我们指定的函数,这种重新设计运算符规则的技术就称为运算符重载!<br />语法:<code>返回类型operator运算符0</code><br />//例如 <code>bool operator&lt;(const Role&amp; role);</code></p><p>非类成员函数实现需要使用友元定义</p><p>即： <code>man&lt;woman == man.operator&lt;(woman) == man&lt;woman</code></p><h3 id="原则和时机"><a class="markdownIt-Anchor" href="#原则和时机"></a> 原则和时机</h3><p><strong>意义</strong></p><p>(1）让类也支持原生的运算比如＋-*/<br />(2）提升对程序的控制权比如重载new delete newdelete[<br />备注:<br />运算符重载的主要目的是为了让目标代码更方便使用和维护，而不是提升开发效率，重载运算符未必能提升开发效率</p><p><strong>限制</strong></p><p>(1)不能自创运算符比如=== ,=&lt;&gt;=只能重载现有运算符</p><p>(2)以下运算符不能重载<br />(a)对象访问运算符．例如 user.hp</p><p>(b)作用域解析运算符::例如std::cout</p><p>©求大小的运算符sizeof 例如sizeof(int)</p><p>(d)条件运算符?:例如b=a&gt;c?100:200<br />(3)不能修改运算符本身的优先级,相关性<br />(4)在C<ins>17后，也不能修改运算符的操作数的计算顺序，在C</ins>17前，编译器可以自由选择如何计算（未定义行为)</p><p>(5)除了delete/delete和new/new外,不能对原生数据类型的其他运算符进行重载，比如把char类型的+定义为-</p><p>(6)除了new和delete以为，其他运算符的arity(运算符关联的操作数的个数或者是关联的参数）一律不能修改</p><p><strong>原则</strong></p><p>(1)不要改变运算符本身的意义,比如把加法重载为减法<br />(2)不建议重载逻辑运算符&amp;&amp; ||,取址运算符&amp; 逗号运算符，<br />备注:重载后的逻辑运算符将不会进行短路测试，在C<ins>17标准前，编译器可以自由决定先计算左操作数还是右操作数,在C</ins>17后计算的顺序规定为先计算左再计算右</p><p><strong>语法</strong><br />二元运算符的重载<br />利用全局函数<br /><code>返回类型 operator 运算符(类型 左操作数,类型 右操作数）</code><br />利用类的成员函数<br /><code>返回类型 operator 运算符(类型 右操作数)</code><br />一元运算符的重载<br />利用全局函数返回<br /><code>返回类型 operator 运算符(类型 操作数)</code><br />利用类的成员函数<br /><code>返回类型 operator 运算符()</code></p><p>有的运算符只能重载为类的成员函数,有些运算符只能重载为全局函数,有些运算符既可以重载为类的成员函数又可以重载为全局函数,如果一个运算符既可以重载为成员函数又可以重载为全局函数,我们一般推荐重载为类的成员函数,因为类的成员函数可以是虚函数,单全局函数不能是虚函数,如果这个运算符不修改对象,应该将这个成员函数限定为const<br />运算符重载的参数一般可以传递值或者引用,大部分情况下,能够传递引用就不要传递值,对于不会修改的值最好是限定为const,某些时候要擅用使用右值引用&amp;&amp;作为参数<br />运算符重载的返回值一般来说可以是任何类型,但是尽量要符合运算符的原意,比如把&gt;运算符返回指针类型,把+返回bool类型,都不是很好的选择</p><h2 id="重载运算符"><a class="markdownIt-Anchor" href="#重载运算符"></a> 重载运算符</h2><p>{待补充}</p><p>很多符号</p><h2 id="重载类型转换"><a class="markdownIt-Anchor" href="#重载类型转换"></a> 重载类型转换</h2><p>1 类型转换运算符只能重载为类的成员函数</p><p>2 类型转换运算符没有返回值。它的返回值由类型转换的类型来决定</p><p>3 语法 ``</p><p>4 <code>operator 类型() const</code></p><p>{待补充}</p><p><code>什么是隐试类型转换： float x=2  此时2是int型 这是就是隐式类型转换转成float型</code></p><h2 id="重载内存分配"><a class="markdownIt-Anchor" href="#重载内存分配"></a> 重载内存分配</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure><h1 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h1><p>假设有一个类animal现在我们基于animal类创造一个新类monkey,那么我们说类animal</p><p>monkey类的基类(父类),moneky类是anima类的派生类(子类),子类自动继承包含了父类的成员变量以及成员函数!</p><p>子类不能继承父类的构造函数,析构函数,重载赋值运算符,虽然不能继承,但是这些内容依然是存在于父类中的。</p><p>如果我们继续基于monkey创造一个新类bigMonkey,那么monkey是bigMonkey的直接基类,animal是bigMonkey的间接基类</p><p><code>class 类名:访问属性[public|private|protected] 父类名称</code></p><p>protected: 只有子类和友元可以访问</p><p>不想被别人继承的话 后面加 <code>final</code></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220316202707.png" alt="" /></p><p><strong>修改继承成员的访问属性</strong></p><p>可以用<code>using 基类名::成员名</code> 来修改继承来的成员的访问属性</p><p><strong>使用proteted和private访问属性有几个好处</strong></p><p>可以更好的封装父类成员</p><p>可以在子类作为基础进行派生类的时候提供继承控制</p><p>将保护属性为private的父类产生的子类作为基类的时候,派生类继承但不能访问构建其父类的基类成员</p><p>将保护属性为protected的父类产生的子类作为基类的时候,派生类继承且可以访问其非私有成员</p><p><strong>继承访问属性的选择</strong></p><p>一般来说,尽量射击类的成员变量为private,如果需要访问这些成员变量,应该提供setter以及getter函数</p><h2 id="继承中的构造函数"><a class="markdownIt-Anchor" href="#继承中的构造函数"></a> 继承中的构造函数</h2><p><strong>派生类</strong></p><p>构造顺序:先构造基类再构造派生类 (父亲-&gt;儿子)</p><p><strong>父本构造函数</strong></p><p>一个由另一个来复制.  执行时就不会调用原本的构造函数了</p><p>exp: <code>actObject(const actObject&amp; obj)</code></p><p><strong>继承构造函数</strong></p><p>通过 <code>using 基类::基类构造函数</code> 可以继承基类构造函数,但是默认构造函数与副本构造函数不会被继承</p><h2 id="继承析构函数"><a class="markdownIt-Anchor" href="#继承析构函数"></a> 继承析构函数</h2><p>先释放派生类,再释放基类  , 与构造顺序相反</p><p>当基类和派生类的成员函数同名时,要分俩种情况:</p><p>1 函数名相同,参数不同  <code>using 基类::函数名</code></p><p>2 函数名相同,参数相同 <code>基类::函数名</code></p><p>exp: <code>obj.lastObject::lastlastObject::show();</code></p><h2 id="多重继承"><a class="markdownIt-Anchor" href="#多重继承"></a> 多重继承</h2><p>一个类可以拥有多个父类,并且可以继承各个父类的成员 (不推荐用)</p><p><code>class xx: public x1 , public x2 &#123;&#125;;</code></p><p><strong>多重继承带来的重复继承问题</strong></p><p>问题时继承来的东西重复继承</p><p>首先可以强制指定解决√</p><p>另一方法: <strong>虚基类</strong>  <code>class xx:public virtual x&#123;&#125;;</code></p><p>意思时只引入一次,第二次不引入</p><h2 id="内存角度理解"><a class="markdownIt-Anchor" href="#内存角度理解"></a> 内存角度理解</h2><p>{深入理解 待补充}</p><h1 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h1><h2 id="对象多态"><a class="markdownIt-Anchor" href="#对象多态"></a> 对象多态</h2><p>exp: 人是动物√  动物是人×</p><p>即第一个第向上转型(父类=&gt;子类 父类表达子类), 第二个是向下转型(子类=&gt;父类 子类表达父类)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> money;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    peole  lz;</span><br><span class="line">    lz.age = <span class="number">22</span>;</span><br><span class="line">    lz.monry=<span class="number">1</span>;</span><br><span class="line">    animal* anm1=&amp;lz;</span><br><span class="line">    people* humn=(people*)anm1;</span><br><span class="line">    <span class="comment">//不推荐这样用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存切片</strong></p><p>exp: 人类转成动物类的时候, 有些东西会丢掉(比如钱), 这就是内存切片</p><h3 id="对象多态详解"><a class="markdownIt-Anchor" href="#对象多态详解"></a> 对象多态详解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">moveobj</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">monstermove</span>:<span class="keyword">public</span> moveobj</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">monstermove monster;</span><br><span class="line">moveobj* _move=&amp;monster;<span class="comment">//隐式类型转换 向上转型</span></span><br><span class="line"></span><br><span class="line">monstermove* _pmove=&amp;_move; <span class="comment">//隐式 向下转型 不允许!  可以强制</span></span><br><span class="line">monstermove* _pmove=(monstermove*)_move;</span><br><span class="line">monstermove* _pmove=<span class="keyword">static_cast</span>&lt;monstermove*&gt;_move; <span class="comment">//会检测</span></span><br><span class="line">待补充...</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="动态强制转换"><a class="markdownIt-Anchor" href="#动态强制转换"></a> 动态强制转换</h3><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/IMG_20220317_022820.jpg" alt="" /></p><p>只能用于多态类</p><h2 id="方法多态多态类"><a class="markdownIt-Anchor" href="#方法多态多态类"></a> 方法多态(多态类)</h2><p><strong>静态多态</strong></p><p>①函数重载  <code>函数(&amp;类实例化的对象)</code> 从而判断执行哪一个函数</p><p>②函数模板</p><p><strong>动态多态</strong></p><h3 id="virtual虚函数"><a class="markdownIt-Anchor" href="#virtual虚函数"></a> virtual虚函数</h3><p>告诉派生类 我这个函数是虚的 你需要重写</p><p>virtual 放在定义函数的前面</p><p><strong>使用条件</strong></p><p>virtual只能写在类的内部声明或者定义,不能把virtual写在类的外部定义中</p><p>调用类的对象是无法使用虚函数的,必须使用基类指针来实现虚函数的调用</p><p>虚函数在派生类和基类中必须具有相同的及参数列表</p><p>虚函数在派生类和基类中返回值要求基本一致,但是当返回类型为类类型的指针和引用时除外</p><p>虚函数不能是函数模板</p><p><code>类名* 函数名() override</code> 代表我这个函数是继承来的</p><p>final 代表不再被继承.</p><ul><li><p>虚函数的执行也是遵循类的生成和销毁的(自我理解)</p></li><li><p>可以使用 <code>基类::基类函数()</code> 强行调用基类函数</p></li><li><p>默认实参在基类已经定义了那么派生类的修改是无效的,即使执行派生类的函数</p></li><li><p>当你通过基类声明派生类对象 <code>基类* p=new 派生类();</code> 然后释放内存调用析构函数的时候,调用的是基类的析构函数(因为派生函数不是虚函数,你是通过基类声明的对象)  容易造成内存泄漏,所以需要 进行 虚析构函数 , 即可正常.</p></li></ul><h2 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h2><h3 id="纯虚函数"><a class="markdownIt-Anchor" href="#纯虚函数"></a> 纯虚函数</h3><p>在实际的项目设计中,可能出现一种情况,父类有N个派生类<br />比如Animal类派生出Dog和Cat<br />此时我们在Animal类中是无法确定Move函数的内容的,这个时候为Animal类设计Move函数的内容是无意义的,这种情况下我们可以将Move函数设计为纯虚函数<br /><code>void virtual Move(=0;</code><br />=0可以将指定的函数设置为纯虚函数</p><p><strong>为什么要定义成纯虚函数</strong>  为了利用它的多态性,实现多态</p><h3 id="抽象类-2"><a class="markdownIt-Anchor" href="#抽象类-2"></a> 抽象类</h3><p>有纯虚函数的类  不能用于实体</p><p>拥有纯虚函数的类称为抽象类,因为该类的函数没有实现,因此不能创建抽象类的实例,但是却可以使用抽象类的指针和引用作为返回或者参数!<br />抽象类的构造函数因为不能实际使用,所以一般推荐把抽象类的构造函数定义为protected<br />抽象类的派生类如果没有定义纯虚函数,则该派生类依然是抽象类</p><h3 id="接口类"><a class="markdownIt-Anchor" href="#接口类"></a> 接口类</h3><p>类中所有(极大部分)函数定义为纯虚函数的类成为接口类</p><h2 id="调试-2"><a class="markdownIt-Anchor" href="#调试-2"></a> 调试</h2><p><code>typeid(类型).name</code></p><p>输出类型名字 但是必须要有多态</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>c++ 的基础还是有些没有总结好,后面补充</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu20.04美化</title>
      <link href="/posts/7eea43f6/"/>
      <url>/posts/7eea43f6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>主题<a href="https://www.pling.com/s/Gnome">https://www.pling.com/s/Gnome</a><br />扩展<a href="https://extensions.gnome.org/">https://extensions.gnome.org/</a></p><h1 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h1><h2 id="登陆-ubuntu-账号开启-livepatch-功能"><a class="markdownIt-Anchor" href="#登陆-ubuntu-账号开启-livepatch-功能"></a> 登陆 Ubuntu 账号，开启 Livepatch 功能</h2><p><img src="https://i0.hdslb.com/bfs/album/ab4a30e9e73b39cb5b8750f8f869d677bcda32a7.png" alt="" /></p><p>点击 Ubuntu Single-On 就会弹出登陆页面了，这里也可以先不登陆，直接点击跳过，后面再登陆。</p><p>也可以通过在已安装软件列表里面搜索 Software &amp; Updates 软件，如下图，打开后登陆 Ubuntu 账号。</p><p>这里有问题,先不看</p><h1 id="美化"><a class="markdownIt-Anchor" href="#美化"></a> 美化</h1><h3 id="安装必要软件"><a class="markdownIt-Anchor" href="#安装必要软件"></a> 安装必要软件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gnome-tweak-tool</span><br><span class="line">sudo apt-get install gnome-shell-extensions</span><br><span class="line"></span><br><span class="line">删掉原来的ubuntu-dock (emmmm)</span><br><span class="line">sudo apt-get autoremove --purge gnome-shell-extension-ubuntu-dock -y</span><br></pre></td></tr></table></figure><p>用浏览器打开扩展插件商店，地址：<a href="https://extensions.gnome.org/">https://extensions.gnome.org/</a></p><p><img src="https://i0.hdslb.com/bfs/album/b1a2f8621f7162ac6e8005dd6b0cbfeb47f354ba.png" alt="" /></p><p>下载主题McMojave <a href="https://www.gnome-look.org/p/1275087/">https://www.gnome-look.org/p/1275087/</a></p><p>icon theme <a href="https://www.gnome-look.org/s/Gnome/p/1348081">https://www.gnome-look.org/s/Gnome/p/1348081</a></p><p>自己找 然后解压放在/usr/share/themes和icons下面</p><p>然后在gnome里面使用就可以</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS1</title>
      <link href="/posts/f85532d9/"/>
      <url>/posts/f85532d9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="小记"><a class="markdownIt-Anchor" href="#小记"></a> 小记</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line">如何移植别人的工程:</span><br><span class="line">在根目录 catkin_make 后 ,会报错,然后修改的地方在build里,需要更改Cmake.txt以及 Makefile ,再补上所需要的依赖,就可以了</span><br><span class="line">安装依赖:</span><br><span class="line">rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y #自己修改</span><br><span class="line">rosdep install --from-paths ~/catkin_ws/src --ignore-src -r</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br><span class="line">-</span><br></pre></td></tr></table></figure><h1 id="new"><a class="markdownIt-Anchor" href="#new"></a> NEW</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/noetic/setup.bash</span><br><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="常见操作指令"><a class="markdownIt-Anchor" href="#常见操作指令"></a> 常见操作指令</h1><p><strong>查找：</strong><br />rosc/roscd：切换当前工作目录到ros的某个程序包<br />rosls：按程序包的名称执行ls命令<br />catkin_ctreate_pkg：创建功能包<br />catkin_make：编译ROS工作空间，该src空间下所有程序包以及其子包都会被编译</p><ul><li></li></ul><p>roscore：启动管理器<br />rosrun：运行ROS程序包中的可执行文件<br />roslaunch：启动roscore，本地结点和远程结点，设置服务器参数（ssh）<br />roslaunch package_name filename.launch：启动包中的一个文件<br />rospack：获取程序包有关信息<br />rospack find：返回程序包的路径<br />rospack list：获取所有的程序包<br />rosdep：rosdep install package_name 可以下载安装ROS 程序包所需要的系统依赖项<br />roswtf：可以检查ROS系统并尝试发现问题<br />rostopic -h：查看所有Topic操作<br />rostopic list：获取所有的Topic列表<br />rosrun rqt_plot rqt_plot：图形化显示Topic<br />rostopic echo ‘topic namae’：查看某个Topic的信息</p><h1 id="video"><a class="markdownIt-Anchor" href="#video"></a> video</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg usb_cam std_msgs roscpp cv_bridge sensor_msgs image_transport</span><br><span class="line">    </span><br><span class="line">img_publisher.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/calib3d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;img_publisher&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="function">image_transport::ImageTransport <span class="title">it</span><span class="params">(nh)</span></span>;</span><br><span class="line">  image_transport::Publisher pub = it.<span class="built_in">advertise</span>(<span class="string">&quot;camera/image&quot;</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">  cv::VideoCapture cap;</span><br><span class="line">  cv::Mat frame;</span><br><span class="line">  <span class="type">int</span> deviceID=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)</span><br><span class="line">    deviceID=argv[<span class="number">1</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="type">int</span> apiID=cv::CAP_ANY;</span><br><span class="line">  cap.<span class="built_in">open</span>(deviceID+apiID);</span><br><span class="line">  <span class="keyword">if</span>(!cap.<span class="built_in">isOpened</span>())&#123;</span><br><span class="line">    std::cerr&lt;&lt;<span class="string">&quot;ERROR! Unable to open camera&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (nh.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    cap.<span class="built_in">read</span>(frame);</span><br><span class="line">    <span class="keyword">if</span>(!frame.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        sensor_msgs::ImagePtr msg = cv_bridge::<span class="built_in">CvImage</span>(std_msgs::<span class="built_in">Header</span>(), <span class="string">&quot;bgr8&quot;</span>, frame).<span class="built_in">toImageMsg</span>();</span><br><span class="line">        pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img_viewer.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;image_transport/image_transport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">imageCallback</span><span class="params">(<span class="type">const</span> sensor_msgs::ImageConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;view&quot;</span>, cv_bridge::<span class="built_in">toCvShare</span>(msg, <span class="string">&quot;bgr8&quot;</span>)-&gt;image);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (cv_bridge::Exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Could not convert from &#x27;%s&#x27; to &#x27;bgr8&#x27;.&quot;</span>, msg-&gt;encoding.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;img_viewer&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;view&quot;</span>);</span><br><span class="line">  cv::<span class="built_in">startWindowThread</span>();</span><br><span class="line">  <span class="function">image_transport::ImageTransport <span class="title">it</span><span class="params">(nh)</span></span>;</span><br><span class="line">  image_transport::Subscriber sub = it.<span class="built_in">subscribe</span>(<span class="string">&quot;camera/image&quot;</span>, <span class="number">1</span>, imageCallback);</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  cv::<span class="built_in">destroyWindow</span>(<span class="string">&quot;view&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  cv_bridge</span><br><span class="line">  image_transport</span><br><span class="line">  roscpp</span><br><span class="line">  sensor_msgs</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">include_directories</span>(</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">  $&#123;OpenCV_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">add_executable</span>(img_publisher src/img_publisher.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(img_viewer src/img_viewer.cpp)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">target_link_libraries</span>(img_publisher $&#123;catkin_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(img_viewer $&#123;catkin_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&lt;build_depend&gt;opencv2&lt;/build_depend&gt;</span><br><span class="line">&lt;build_export_depend&gt;opencv2&lt;/build_export_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;opencv2&lt;/exec_depend&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://github.com/thinkexist1989/ROS-Academy-for-Beginners/tree/noetic">https://github.com/thinkexist1989/ROS-Academy-for-Beginners/tree/noetic</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> ROS机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础再学习</title>
      <link href="/posts/fd31ca55/"/>
      <url>/posts/fd31ca55/</url>
      
        <content type="html"><![CDATA[<p>C<ins>基础再学习<br />PS:之前学了一点,不过只在opencv简单使用,算法题和面试题,包括ROS等,随着python的不断壮大,python似乎是更好用的工具.不过C</ins>还是挺重要的,对于嵌入式领域还是需要的.</p><p>[TOC]</p><h3 id="枚举类型"><a class="markdownIt-Anchor" href="#枚举类型"></a> 枚举类型</h3><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p><p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓&quot;枚举&quot;是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p><p>创建枚举，需要使用关键字 enum。枚举类型的一般形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名&#123; </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><p>如果枚举没有初始化, 即省掉&quot;=整型常数&quot;时, 则从第一个标识符开始。</p><p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green, blue &#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure><p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。<br /><code>enum color &#123; red, green=5, blue &#125;;</code><br />在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p><h3 id="整数常量"><a class="markdownIt-Anchor" href="#整数常量"></a> 整数常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">// 八进制 </span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">// 十六进制 </span></span><br><span class="line"><span class="number">30</span>         <span class="comment">// 整数 </span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">// 无符号整数 </span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">// 长整数 </span></span><br><span class="line"><span class="number">30ul</span>       <span class="comment">// 无符号长整数</span></span><br></pre></td></tr></table></figure><h3 id="类型限定符"><a class="markdownIt-Anchor" href="#类型限定符"></a> 类型限定符</h3><table><thead><tr><th>限定符</th><th>含义</th></tr></thead><tbody><tr><td>const</td><td><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td></tr><tr><td>volatile</td><td>修饰符 <strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td></tr><tr><td>restrict</td><td>由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td></tr></tbody></table><h1 id="c存储类"><a class="markdownIt-Anchor" href="#c存储类"></a> C++存储类</h1><h2 id="autoc17开始弃用"><a class="markdownIt-Anchor" href="#autoc17开始弃用"></a> auto(c++17开始弃用)</h2><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p><p>C<ins>98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C</ins>17 中已删除这一用法。</p><p>根据初始化表达式自动推断被声明的变量的类型，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">&#x27;r&#x27;</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure><h2 id="registerc17开始弃用"><a class="markdownIt-Anchor" href="#registerc17开始弃用"></a> register(c++17开始弃用)</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><p><code>&#123;   register int  miles; &#125;</code></p><p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h2 id="static存储类"><a class="markdownIt-Anchor" href="#static存储类"></a> static存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p><p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数声明 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">10</span>; <span class="comment">/* 全局变量 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">5</span>; <span class="comment">// 局部静态变量</span></span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;变量 i 为 &quot;</span> &lt;&lt; i ;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; , 变量 count 为 &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p><img src="https://i0.hdslb.com/bfs/album/1219357fb4b425f30463c902c44f32c55a51b8e6.png" alt="" /></p><h2 id="extern存储类"><a class="markdownIt-Anchor" href="#extern存储类"></a> extern存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p><p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p><p>第一个文件：main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   <span class="built_in">write_extern</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个文件：support.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_extern</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cpp support.cpp -o write</span><br></pre></td></tr></table></figure><p>这会产生 <strong>write</strong> 可执行程序，尝试执行 <strong>write</strong>，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./write</span><br><span class="line">Count is 5</span><br></pre></td></tr></table></figure><h2 id="mutable存储类"><a class="markdownIt-Anchor" href="#mutable存储类"></a> mutable存储类</h2><p><strong>mutable</strong> 说明符仅适用于类的对象.它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p><h2 id="thread_local-c11存储类"><a class="markdownIt-Anchor" href="#thread_local-c11存储类"></a> thread_local (C++11)存储类</h2><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p><p>thread_local 说明符可以与 static 或 extern 合并。</p><p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p><p>以下演示了可以被声明为 thread_local 的变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> x;  <span class="comment">// 命名空间下的全局变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">thread_local</span> std::string X::s;  <span class="comment">// X::s 是需要定义的</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 本地变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lambda-函数与表达式"><a class="markdownIt-Anchor" href="#lambda-函数与表达式"></a> Lambda 函数与表达式</h1><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p><p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y)&#123; <span class="keyword">return</span> x &lt; y ; &#125;</span><br></pre></td></tr></table></figure><p>如果没有返回值可以表示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]&#123; ++global_x; &#125; </span><br></pre></td></tr></table></figure><p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="type">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure><p>本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。</p><p>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</p><p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure><p>另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1><h2 id="数组类型"><a class="markdownIt-Anchor" href="#数组类型"></a> 数组类型</h2><p>字符串实际上是使用 <strong>null</strong> 字符 <strong>\0</strong> 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p><p>其实，不需要把 <strong>null</strong> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 <strong>\0</strong> 放在字符串的末尾。</p><p>C++ 中有大量的函数用来操作以 null 结尾的字符串:</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">函数 &amp; 目的</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 <strong>+</strong> 号，例如: <code>string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2;</code></td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><p><code>#include  &lt;cstring&gt;</code></p><h2 id="string类型"><a class="markdownIt-Anchor" href="#string类型"></a> String类型</h2><p>关于面向对象:</p><p>exampl:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   string str1 = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">   string str2 = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">   string str3;</span><br><span class="line">   <span class="type">int</span>  len ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 复制 str1 到 str3</span></span><br><span class="line">   str3 = str1;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 连接 str1 和 str2</span></span><br><span class="line">   str3 = str1 + str2;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str1 + str2 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 连接后，str3 的总长度</span></span><br><span class="line">   len = str3.<span class="built_in">size</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;str3.size() :  &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str3 : runoob</span><br><span class="line">str1 + str2 : runoobgoogle</span><br><span class="line">str3.size() :  12</span><br></pre></td></tr></table></figure><h1 id="c引用"><a class="markdownIt-Anchor" href="#c引用"></a> C++引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><p><strong>和指针的区别:</strong></p><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = 17;</span><br></pre></td></tr></table></figure><p>我们可以为 i 声明引用变量，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int&amp;  r = i;</span><br><span class="line">double&amp; s = d;</span><br></pre></td></tr></table></figure><p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 声明简单的变量</span></span><br><span class="line">   <span class="type">int</span>    i;</span><br><span class="line">   <span class="type">double</span> d;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 声明引用变量</span></span><br><span class="line">   <span class="type">int</span>&amp;    r = i;</span><br><span class="line">   <span class="type">double</span>&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = <span class="number">5</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = <span class="number">11.7</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value of i : 5</span><br><span class="line">Value of i reference : 5</span><br><span class="line">Value of d : 11.7</span><br><span class="line">Value of d reference : 11.7</span><br></pre></td></tr></table></figure><p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：</p><table><thead><tr><th style="text-align:left">概念</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html">把引用作为参数</a></td><td style="text-align:left">C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html">把引用作为返回值</a></td><td style="text-align:left">可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</td></tr></tbody></table><h1 id="io"><a class="markdownIt-Anchor" href="#io"></a> I/O</h1><table><thead><tr><th style="text-align:left">头文件</th><th style="text-align:left">函数和描述</th></tr></thead><tbody><tr><td style="text-align:left"><iostream></td><td style="text-align:left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr><tr><td style="text-align:left"><iomanip></td><td style="text-align:left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td></tr><tr><td style="text-align:left"><fstream></td><td style="text-align:left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td></tr></tbody></table><p><strong>延申待补充…</strong></p><h1 id="c面向对象"><a class="markdownIt-Anchor" href="#c面向对象"></a> C++面向对象</h1><h1 id="c高级"><a class="markdownIt-Anchor" href="#c高级"></a> C++高级</h1>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常效率Tips</title>
      <link href="/posts/6c0c8dda/"/>
      <url>/posts/6c0c8dda/</url>
      
        <content type="html"><![CDATA[<h1 id="github"><a class="markdownIt-Anchor" href="#github"></a> Github</h1><p><strong><a href="http://xn--github-2w8lv2v.com">替换github.com</a> 为 <a href="http://hub.fastgit.org">hub.fastgit.org</a></strong></p><hr /><h1 id="vim"><a class="markdownIt-Anchor" href="#vim"></a> Vim</h1><hr /><p>批量替换:<br />:%s/abc/123/g c (用c可以确认是否替换)</p><p>编辑文件:(默认模式下)</p><table><thead><tr><th>指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>i</td><td style="text-align:center">在当前光标所在字符的前面，转为编辑模式。</td></tr><tr><td>I</td><td style="text-align:center">在当前光标所在行的行首转换为编辑模式。</td></tr><tr><td>a</td><td style="text-align:center">在当前光标所在字符的后面，转为编辑模式。</td></tr><tr><td>A</td><td style="text-align:center">在光标所在行的行尾，转换为编辑模式。</td></tr><tr><td>o</td><td style="text-align:center">在当前光标所在行的下方，新建一行，并转为编辑模式。</td></tr><tr><td>O</td><td style="text-align:center">在当前光标所在行的上方，新建一行，并转为编辑模式。</td></tr></tbody></table><p>查找: /xxx       <code>n  在同一个方向重复上一次搜索命令   N 在反方向重复上一次搜索命令</code></p><hr /><p>选中 单词开头或者结尾 (在v模式下) 按e进行选择</p><h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h1><p><strong>配置ssh</strong></p><p><code>sudo apt install openssh-server </code></p><p><code>service ssh start</code></p><p><strong>重新连接Ubuntu联网指令：</strong></p><p><code>sudo /etc/init.d/network-manager restart</code></p><p><strong>重新挂载共享文件夹</strong></p><p><code>sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000</code></p><p><strong>搜wifi:</strong></p><p><code>sudo iw dev wlan0 scan | grep SSID</code></p><p><strong>交叉编译树莓派gcc：</strong></p><p><code>arm-linux-gnueabihf-gcc</code></p><p><strong>树莓派安全关机：</strong></p><p><code>sudo shutdown -h now</code></p><p><strong>树莓派重启：</strong></p><p><code>sudo reboot</code><br /><strong>树莓派传输文件使用fillzeila：前面加上</strong> <code>sftp://</code></p><p><strong>树莓派拍照：</strong> <code>raspistill -o image.jpg</code><br />监控   :8080</p><p><strong>安装软件</strong>: ``sudo  dpkg  -itar xvf xxx<code> **Linux查看pdf：**</code>zathura<code> **LINUX解压文件：**</code>tar xvf xxx`</p><p><strong>摄像头推流：</strong></p><p><code>/usr/local/bin/mjpg_streamer -i &quot;/usr/local/lib/mjpg-streamer/input_uvc.so -n -f 30 -r 1280x720&quot; -o &quot;/usr/local/lib/mjpg-streamer/output_http.so -p 8080 -w /usr/local/share/mjpg-streamer/www&quot;</code></p><p><strong>临时路径：</strong></p><p><code>export LD_LIBRARY_PATH=/home/lz/face/samplecode/ASFTestDemo/linux_so/:$LD_LIBRARY_PATH</code></p><p><strong>opencv:</strong><br />编译时 加 <code>pkg-config --cflags --libs opencv</code></p><h1 id="云服务器"><a class="markdownIt-Anchor" href="#云服务器"></a> 云服务器</h1><p><strong>防火墙操作</strong></p><p>firewall-cmd --list-all                                              列出所有端口号白名单<br />firewall-cmd --add-port=8888/tcp --permanent              添加一个8888端口为白名单<br />firewall-cmd --reload                                             更新防火墙操作</p><hr /><h1 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h1><p><strong>百度文库下载:</strong></p><p>网址baidu后面加三个v</p><hr /><p><strong>Typora+七牛云配置:</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qiniu&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;qiniu&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;accessKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;secretKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;bucket&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储空间名</span></span><br><span class="line">        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义域名</span></span><br><span class="line">        <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// 存储区域编号</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// 网址后缀，比如？imgslim</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/&quot;</span> <span class="comment">// 自定义存储路径，比如 img/</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="pyhton"><a class="markdownIt-Anchor" href="#pyhton"></a> pyhton</h1><p><strong>conda install 问题</strong></p><p>终端中输入代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels conda-forge</span><br></pre></td></tr></table></figure><p>再通过conda或者pip安装自己需要的包就不会再出问题了。</p><p>注意channel不一定是conda-forge，根据你需要安装包的类型，具体包属于那个类型可以通过代码来查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anaconda search -t conda 要安装的包</span><br></pre></td></tr></table></figure><p>当然啦如果你需要安装的包比较少也可以直接按照上面给出链接的博客方法进行操作</p><p><code>conda activate tensorflow</code></p><p><code>conda create -n tensorflow python=3.8.5</code></p><p><strong>Windows pip install</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名 -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h1 id="下载问题"><a class="markdownIt-Anchor" href="#下载问题"></a> 下载问题</h1><p><strong>CSDN</strong><br />使用: f12 conslo 输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将主要内容移动到 body</span></span><br><span class="line">$(<span class="string">&quot;body&quot;</span>).<span class="title function_">prepend</span>($(<span class="string">&quot;main&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 移除掉body中的其他节点</span></span><br><span class="line"><span class="comment">// 不移除脚本和 style 是因为要保持样式</span></span><br><span class="line">$.<span class="title function_">each</span>($(<span class="string">&quot;body&quot;</span>).<span class="title function_">children</span>(), <span class="keyword">function</span>(<span class="params">index, obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tag = obj.<span class="property">tagName</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(tag==<span class="string">&quot;MAIN&quot;</span> || tag==<span class="string">&quot;SCRIPT&quot;</span> || tag==<span class="string">&quot;STYLE&quot;</span>)) &#123;</span><br><span class="line">        obj.<span class="title function_">remove</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 内容宽度为页面的100% </span></span><br><span class="line">$(<span class="string">&quot;main&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;width&quot;</span>, <span class="string">&quot;100%&quot;</span>);</span><br><span class="line"><span class="comment">// 移除掉用户信息工具栏</span></span><br><span class="line">$(<span class="string">&quot;#toolBarBox&quot;</span>).<span class="title function_">remove</span>();</span><br><span class="line"><span class="comment">//如果有专栏，去掉专栏</span></span><br><span class="line"><span class="keyword">if</span> ( $(<span class="string">&quot;#blogColumnPayAdvert&quot;</span>).<span class="property">length</span> &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    $(<span class="string">&quot;#blogColumnPayAdvert&quot;</span>).<span class="title function_">remove</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去掉作者栏</span></span><br><span class="line">$(<span class="string">&quot;.article-info-box&quot;</span>).<span class="title function_">remove</span>();</span><br><span class="line"><span class="comment">//除去相关推荐对你有帮助吗栏</span></span><br><span class="line">$(<span class="string">&quot;#recommendNps&quot;</span>).<span class="title function_">remove</span>();</span><br><span class="line"><span class="comment">//除去评价栏</span></span><br><span class="line">$(<span class="string">&quot;#pcCommentBox&quot;</span>).<span class="title function_">remove</span>();</span><br><span class="line"><span class="comment">//除去底部</span></span><br><span class="line">$(<span class="string">&quot;.template-box&quot;</span>).<span class="title function_">remove</span>();</span><br><span class="line">$(<span class="string">&quot;.blog-footer-bottom&quot;</span>).<span class="title function_">remove</span>();</span><br><span class="line">$(<span class="string">&quot;.recommend-box&quot;</span>).<span class="title function_">remove</span>();</span><br><span class="line"><span class="comment">//如果有链接元素，循环点击图片链接</span></span><br><span class="line"><span class="keyword">if</span> ( $(<span class="string">&quot;.look-more-preCode&quot;</span>).<span class="property">length</span> &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    $.<span class="title function_">each</span>($(<span class="string">&quot;.look-more-preCode&quot;</span>), <span class="keyword">function</span>(<span class="params">index, obj</span>) &#123;</span><br><span class="line">    obj.<span class="title function_">click</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 进行打印，保存PDF</span></span><br><span class="line"><span class="comment">// 设置 500 毫秒等待时间是因为要等待页面设置完成</span></span><br><span class="line"><span class="comment">// 否则页面可能会有部分样式没有加载出来</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">window</span>.<span class="title function_">print</span>()&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Tips </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客文章Title</title>
      <link href="/posts/57b0fba5/"/>
      <url>/posts/57b0fba5/</url>
      
        <content type="html"><![CDATA[<p>Front-matter 是markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</p><p>Page Front-matter 用于頁面配置<br />Post Front-matter 用于文章頁配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220120000604.png" alt="" /></p><h1 id="笔记"><a class="markdownIt-Anchor" href="#笔记"></a> 笔记</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:缩略图</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">---</span><br><span class="line">another:::::::::::::::::::</span><br><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">author: </span><br><span class="line">img: /medias/banner/7.jpg</span><br><span class="line">coverImg: /medias/banner/7.jpg</span><br><span class="line">top: true</span><br><span class="line">cover: true</span><br><span class="line">toc: true</span><br><span class="line">password: 5f15b28ffe43f8be4f239bdd9b69af9d80dbafcb20a5f0df5d1677a120ae9110</span><br><span class="line">mathjax: true</span><br><span class="line">summary: 自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Github</span><br><span class="line">- </span><br><span class="line">categories:</span><br><span class="line">- </span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220120000809.png" alt="" /></p><h3 id="新md"><a class="markdownIt-Anchor" href="#新md"></a> <a href="http://xn--efv.md">新.md</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Copyright-beautify # 文章名称</span><br><span class="line">date: 2021-03-02 13:52:46 # 文章发布日期</span><br><span class="line">updated: 2021-03-02 13:52:46 # 文章更新日期</span><br><span class="line">copyright_author: Nesxc # 作者覆写</span><br><span class="line">copyright_url: #https://www.nesxc.com/post/hexocc.html # 原文链接覆写</span><br><span class="line">license: # 许可协议名称覆写</span><br><span class="line">license_url: # 许可协议链接覆写</span><br><span class="line">author: </span><br><span class="line">img: </span><br><span class="line">coverImg: </span><br><span class="line">top: false</span><br><span class="line">cover: false</span><br><span class="line">toc: true</span><br><span class="line">mathjax: false</span><br><span class="line">password:</span><br><span class="line">summary:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">sticky: 1 #置顶用 越大置顶优先级越大</span><br><span class="line">aside: false    &lt;-- 关闭侧边栏</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 创建日期</span><br><span class="line">updated: 更新日期</span><br><span class="line">cover: 文章封面</span><br><span class="line">description: 文章描述</span><br><span class="line">swiper_index: 1 #置顶轮播图顺序，需填非负整数，数字越大越靠前</span><br><span class="line">comments: false #关闭评论</span><br><span class="line">subtitle: 左上角显示</span><br><span class="line">description: 提示-&gt;左上角</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><p>给 js 脚本加上 <code>defer</code> 和 <code>ansyc</code> 属性来实现异步加载，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bottom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">defer</span> <span class="string">https://unpkg.zhimg.com/vue@2.6.11&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">async</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/gh/zjwo/CDN/js/pyq/pyq.min.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HexoPost </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> post </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程控制项目一些问题</title>
      <link href="/posts/8d1f2d1/"/>
      <url>/posts/8d1f2d1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="项目开发"><a class="markdownIt-Anchor" href="#项目开发"></a> <strong>项目开发</strong></h1><p>配置启动项为mianCRTstartup , 子系统为控制窗口格式</p><h2 id="网络编程"><a class="markdownIt-Anchor" href="#网络编程"></a> <strong>网络编程</strong></h2><p>初始Windows socket</p><p>设计类,main之前单线程执行</p><p><strong>问题</strong></p><p>如果声明的类被拿去声明变量怎么办? -&gt;单例 通过单例,很多初始化不用管,封装在单例里</p><p>类 静态成员 方法</p><p>需要this 静态方法没有this指针 因为是全局访问的 public 静态成员也一样 都是公用的(必须通过显式方式进行初始化)</p><p>网络: 包的封装</p><ul><li>包的设计 : 很多个数据, 设定一到俩个字节的包头,用四个字节作为长度(太长的话保留四个字节),后面就是数据,一般用一到俩个字节作为一个命令,在包的最后保留俩个字节做一个校验 . 包头:固定的,比如FFFF \ FFFE (因为不太常见) , 收到时,开始一个个去找,如果找不到就跳过 , (如果缓冲区有残留,那么残留的数据需要被跳过,就需要包头) , (嗅探包的原因,数据杂乱,渗透测试用) , (其他应用的误发). 然后读包长度,为了安全可以加校验(比如和校验,将包头和长度以外的数据都加起来,溢出的部分不要了,另外的比如CRC这种).</li><li>具体做法:</li></ul><h2 id="命令设计"><a class="markdownIt-Anchor" href="#命令设计"></a> <strong>命令设计</strong></h2><h2 id="驱动信息"><a class="markdownIt-Anchor" href="#驱动信息"></a> <strong>驱动信息</strong></h2><h2 id="目录信息"><a class="markdownIt-Anchor" href="#目录信息"></a> <strong>目录信息</strong></h2><h2 id="屏幕图像"><a class="markdownIt-Anchor" href="#屏幕图像"></a> <strong>屏幕图像</strong></h2><h2 id="鼠标处理"><a class="markdownIt-Anchor" href="#鼠标处理"></a> <strong>鼠标处理</strong></h2><h2 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> <strong>打开文件</strong></h2><h2 id="下载文件"><a class="markdownIt-Anchor" href="#下载文件"></a> <strong>下载文件</strong></h2><h2 id="锁机"><a class="markdownIt-Anchor" href="#锁机"></a> <strong>锁机</strong></h2><h2 id="解锁"><a class="markdownIt-Anchor" href="#解锁"></a> <strong>解锁</strong></h2><h2 id="显示文字"><a class="markdownIt-Anchor" href="#显示文字"></a> <strong>显示文字</strong></h2><h2 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> <strong>删除文件</strong></h2><h1 id="客户端开发"><a class="markdownIt-Anchor" href="#客户端开发"></a> <strong>客户端开发</strong></h1><h2 id="项目创建"><a class="markdownIt-Anchor" href="#项目创建"></a> <strong>项目创建</strong></h2><h2 id="控件布局"><a class="markdownIt-Anchor" href="#控件布局"></a> <strong>控件布局</strong></h2><h2 id="网络编程-2"><a class="markdownIt-Anchor" href="#网络编程-2"></a> <strong>网络编程</strong></h2><h2 id="消息设计"><a class="markdownIt-Anchor" href="#消息设计"></a> <strong>消息设计</strong></h2><h2 id="文件展示"><a class="markdownIt-Anchor" href="#文件展示"></a> <strong>文件展示</strong></h2><h2 id="图像显示"><a class="markdownIt-Anchor" href="#图像显示"></a> <strong>图像显示</strong></h2><h2 id="鼠标控制"><a class="markdownIt-Anchor" href="#鼠标控制"></a> <strong>鼠标控制</strong></h2><h2 id="其他功能"><a class="markdownIt-Anchor" href="#其他功能"></a> <strong>其他功能</strong></h2><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p>单例模式:   RALL机制</p><p>打包问题:</p><p>#prama pack(push)问题 :</p><p>exp: FFFE  07000000  0100   432C44  B300</p><p>包头:FFFE  07000000:整个长度  0100:命令俩个字节</p><p>文件驱动方式: 需求:处理文件  需要知道在哪个分区,makedriverinfo来回复</p><p>D:\my_ws\c_ws\control_ws\control_client\ClientSocket.h(202) : atlTraceGeneral - m_sock : 192<br />D:\my_ws\c_ws\control_ws\control_client\control_clientDlg.cpp(171) : atlTraceGeneral - Client Send ret 1<br />D:\my_ws\c_ws\control_ws\control_ws\ServerSocket.h(161) : atlTraceGeneral - m_client = 188<br />D:\my_ws\c_ws\control_ws\control_ws\control_ws.cpp(437) : atlTraceGeneral - Acceptclirnt return true<br />D:\my_ws\c_ws\control_ws\control_ws\ServerSocket.h(184) : atlTraceGeneral - recv len : 10</p><p>D:\my_ws\c_ws\control_ws\control_client\ClientSocket.h(202) : atlTraceGeneral - m_sock : 556<br />D:\my_ws\c_ws\control_ws\control_client\control_clientDlg.cpp(171) : atlTraceGeneral - Client Send ret 1<br />D:\my_ws\c_ws\control_ws\control_client\control_clientDlg.cpp(173) : atlTraceGeneral - Client ack : -1<br />D:\my_ws\c_ws\control_ws\control_ws\ServerSocket.h(161) : atlTraceGeneral - m_client = 508<br />D:\my_ws\c_ws\control_ws\control_ws\control_ws.cpp(437) : atlTraceGeneral - Acceptclirnt return true<br />D:\my_ws\c_ws\control_ws\control_ws\ServerSocket.h(185) : atlTraceGeneral - recv len : 12<br />D:\my_ws\c_ws\control_ws\control_ws\control_ws.cpp(439) : atlTraceGeneral - dealcommand ret : 12</p><p>困难: 设计的时候没有考虑周全关于文件执行 getfilepath只允许前几个  新加功能很麻烦 找错误很久</p><hr /><p>显示文件有丢失</p><p>断点发现发送没有问题 接收这边有问题</p><p>首先从设计上来讲一般没有什么问题,从俩方面下手,首先确保传输的数据是没有问题的,在服务端端加日志,打印了传输的数量并且打印了文件, 客户端一样 俩端去比对 如果数据没有问题 那就是显示有问题  : 结果是数据的问题 对不上号 count和包 , 开始调试, 不能调试就加日志, 一开始是index标志的问题 ,被覆盖 加了static没有用 , 又发现是buffer的问题, 另一个问题是服务端发完了,但是我这边接收端还有大量的数据 , 缓冲的数据还没有用完 ,所以当receive length为0的时候还不能结束,继续加条件,要缓冲也为0.</p><hr /><p>大文件传输解决</p><p>1 下载 : 耗时问题 为了避免很多时间卡住,  当窗口启动的时候是有一个线程的,线程主要是做一个循环,这个循环就叫做消息循环,包括点击文件下载都是消息循环,如果下载函数执行3s,那么整个消息循环都会被卡住3s,一直卡住,后面的消息就无法再处理了, <code>每个循环的开始首先是取消息,然后是处理消息,然后继续投递消息,无限制的去轮回,</code> 长时间卡住就会死掉,所以为什么要加线程: <code>当初发的时候,会另外起一个线程去跑3s,而主线程消息循环并不受影响</code> 那么在线程里面使用updatedata的时候,为什么会崩溃呢? 因为是在子线程去调用的,它会去验证是不是一个线程(是不是一致),断言,防止多线程去更改控件,所以哦我们使用了sendmessage,为什么它可以呢? sendmessage的原则是 ,我投递一个消息,投递到主线程,主线程去处理,所以在线程校验的时候会通过,然后给一个返回值, 不会崩掉.</p><p>2 自定义消息 : 自定义消息id , 每次+1 , (这是windwosAPI) ,</p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式基础</title>
      <link href="/posts/5c8c37e6/"/>
      <url>/posts/5c8c37e6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>预览:</strong></p><p><img src="https://pic.imgdb.cn/item/627bc37e09475431295ff01a.jpg" alt="" /></p><p><img src="https://pic.imgdb.cn/item/627bc37e09475431295fefd0.jpg" alt="" /></p><h1 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h1><p>``/etc/init.d/rcS`  是6ull开发板的开机脚本文件</p><p><code>echo &quot;7 4 1 7&quot; &gt; /proc/sys/kernel/printk</code> 开启内核打印信息</p><hr /><p>开发板挂载: <code>mount -t nfs -o nolock,vers=3 192.168.2.125:/home/book/nfs_rootfs /mnt</code><br /><code>umount /mnt</code> if busy</p><p>NAT的话: <code>mount -t nfs -o nolock,vers=3,port=2049,mountport=9999  192.x.x.x:/home/book/nfs_rootfs /mnt</code></p><p>mount命令用来挂载各种支持的文件系统协议到某个目录下。</p><p>mount成功之后，开发板在/mnt目录下读写文件时，实际上访问的就是Ubuntu中的/home/book/nfs_rootfs目录，所以开发板和Ubuntu之间通过NFS可以很方便地共享文件。</p><p>在开发过程中，在Ubuntu中编译好程序后放入/home/book/nfs_rootfs目录，开发板mount nfs后就可以直接使用/mnt下的文件。</p><hr /><h2 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmcli r wifi on</span><br><span class="line">nmcli dev wifi</span><br><span class="line">nmcli dev wifi connect &quot;DRLyyds&quot; password &quot;19407010220&quot; ifname wlan0</span><br></pre></td></tr></table></figure><p><strong>官方</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">移除GUI: mv /etc/init.d/S07hmi /root reboot</span><br><span class="line">重新加载驱动</span><br><span class="line">rmmod 8723bu.ko</span><br><span class="line">modprobe 8723bu</span><br><span class="line">移除其它控制</span><br><span class="line">ps -ef | grep &quot;wpa&quot;</span><br><span class="line">292 root     /usr/sbin/wpa_supplicant -u</span><br><span class="line">kill -9 292</span><br><span class="line">rm /etc/wpa_supplicant.conf</span><br><span class="line">3.执行wifi链接操作</span><br><span class="line">ifconfig wlan0 up</span><br><span class="line">iw dev wlan0 scan |grep SSID</span><br><span class="line">//wpa_passphrase  HUAWEI zihezihe  &gt;&gt; /etc/wpa_supplicant.conf</span><br><span class="line">-/etc/wpa_supplicant.conf</span><br><span class="line">ctrl_interface=/var/run/wpa_supplicant</span><br><span class="line">ctrl_interface_group=0</span><br><span class="line">update_config=1</span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=&quot;DRLyyds&quot;</span><br><span class="line">        psk=&quot;19407010220&quot;</span><br><span class="line">&#125;</span><br><span class="line">-</span><br><span class="line">wpa_supplicant -B -iwlan0 -c /etc/wpa_supplicant.conf</span><br><span class="line">iw wlan0 link</span><br><span class="line">udhcpc -i wlan0</span><br><span class="line">ping -I wlan0 www.baidu.com</span><br></pre></td></tr></table></figure><hr /><p>设置交叉编译工具链:   <code>vim ~/.bashrc</code>    永久生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm</span><br><span class="line">export CROSS_COMPILE=arm-buildroot-linux-gnueabihf-</span><br><span class="line">export PATH=$PATH:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin</span><br></pre></td></tr></table></figure><hr /><h2 id="一些命令"><a class="markdownIt-Anchor" href="#一些命令"></a> 一些命令</h2><p>udhcpc : 获取ip 用网线的时候用</p><p>make之后, 可以使用make menuconfig来查看命令 状况  然后make <code>100ask_imx6ull_pro_ddr512m_systemV_qt5_defconfig</code> <code>make all</code></p><p>编译成功后文件输出路径为 <strong>output/images</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">buildroot2020.02.x </span><br><span class="line"></span><br><span class="line">  ├── output</span><br><span class="line"></span><br><span class="line">​    ├── images  </span><br><span class="line"></span><br><span class="line">​      ├── 100ask_imx6ull-14x14.dtb &lt;--设备树文件  </span><br><span class="line"></span><br><span class="line">​      ├── rootfs.ext2         &lt;--ext2格式根文件系统</span><br><span class="line"></span><br><span class="line">​      ├── rootfs.ext4 -&gt; rootfs.ext2   &lt;--ext2格式根文件系统 </span><br><span class="line"></span><br><span class="line">​      ├── rootfs.tar         </span><br><span class="line"></span><br><span class="line">​      ├── rootfs.tar.bz2       &lt;--打包并压缩的根文件系统，用于NFSROOT启动</span><br><span class="line"></span><br><span class="line">​      ├── 100ask-imx6ull-pro-512d-systemv-v1.img     &lt;--完整的系统镜像(可以用来烧写emmc和sd卡)</span><br><span class="line"></span><br><span class="line">​      ├── u-boot-dtb.imx       &lt;--u-boot镜像</span><br><span class="line"></span><br><span class="line">​      └── zImage         &lt;--内核镜像</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>烧写裸机文件: imx是烧写EMMC, img是烧写到sdCard</p><p>parsec</p><h1 id="入门"><a class="markdownIt-Anchor" href="#入门"></a> 入门</h1><p><strong>Linux启动流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220401203510.png" alt="" /></p><p><strong>IMX6ULL启动流程</strong></p><p>reset 开发板复位启动 -&gt; rom 板子只读内存 -&gt;加载UBOOT 去加载 第一段bootloader引导程序 -&gt; uboot里有启动参数(环境变量)来启动kernel -&gt; kernel + dtb 设备树 -&gt; 启动Rootfs 跟文件系统 -&gt; app</p><p><strong>使用mount挂载</strong></p><p><code>mount -t nfs -o nolock,vers=3 192.168.2.125:/home/book/nfs_rootfs /mnt</code></p><p><code>mount -t nfs -o intr,nolock,rsize=1024,wsize=1024 192.168.2.125:/home/book/nfs_rootfs /mnt </code></p><p>挂载ubuntu的nfs目录到开发板/mnt目录下，挂载成功后使用<code>df -h</code>命令查看所有挂载。</p><p><strong>编译内核镜像-设备树</strong></p><p>编译内核模块-&gt;nfs挂载-&gt;传输到开发板 reboot即可使用新的 zImage镜像 *.dtb设备树 /lib/modules模块</p><p><strong>编译UBOOT</strong></p><p>make distclean 删除之前缓存 -&gt; make mx6ull_14x14_evk_defconfig   -&gt; make</p><h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h1><p>shell会去环境变量读取 可以通过<code>echo SPATH</code> 查看</p><p>ls: <code>-l(long 显示完整信息) -a(显示隐藏文件) -h(列出大小)</code></p><p>cp: <code>r：recursive，递归地，即复制所有文件  f：force，强制覆盖  d：如果源文件为链接文件，也只是把它作为链接文件复制过去，而不是复制实际文件</code></p><p>rm: <code>r：recursive，递归地，即删除所有文件  f：force，强制删除</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">chgrp：改变文件所属用户组</span><br><span class="line">        -R : 进行递归的持续更改，也连同子目录下的所有文件、目录都更新成为这个用户组之意。常常用在更改            某一目录内所有文件的情况。</span><br><span class="line">chown：改变文件所有者</span><br><span class="line">chmod：改变文件的权限</span><br><span class="line">        r:  4或0</span><br><span class="line">        ② w:  2或0</span><br><span class="line">        ③ x:  1或0</span><br><span class="line">        这3种权限的取值相加后，就是权限的数字表示。</span><br><span class="line">        例如：文件a的权限为“-rwxrwx---”，它的数值表示为：</span><br><span class="line">        ① owner = rwx = 4+2+1 = 7</span><br><span class="line">        ② group = rwx = 4+2+1 = 7</span><br><span class="line">        ③ others = --- = 0+0 +0 = 0</span><br><span class="line">        使用u、g、o三个字母代表user、group、others 3中身份。此外a代表all，即所有身份。</span><br><span class="line">        范例： </span><br><span class="line">        chmod u=rwx,go=rx  .bashrc</span><br><span class="line"></span><br><span class="line">        也可以增加或去除某种权限，“+”表示添加权限，“-”表示去除权限：</span><br><span class="line">        chmod a+w  .bashrc</span><br><span class="line">        chmod a-x  .bashrc</span><br></pre></td></tr></table></figure><p><strong>查找\搜索命令</strong></p><p><strong>find</strong>  <code>find 目录名 选项 查找条件</code>   用来查找文件</p><p>例: <code>find /home/book/dira/ -name &quot; test1.txt &quot; </code></p><p>! - <strong>查找最近几天(几个小时)之内(之前)有变动的文件</strong></p><p><code>$ find /home/book -mtime -2    //查找/home目录下两天内有变动的文件。</code></p><p><strong>grep</strong>  grep命令的作用是查找文件中符合条件的字符串，其格式如下： <code>grep [选项] [查找模式] [文件名]</code></p><p><code>grep -rn &quot;字符串&quot; 文件名 r(recursive)：递归查找 n(number)：显示目标位置的行号</code>  可以加入-w全字匹配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以在grep的结果中再次执行grep搜索，比如搜索包含有ABC的头文件，可执行如下命令：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep  “ABC”  *  -nR  |  grep “\.h”</span></span><br><span class="line">上述命令把第1个命令“grep  “ABC”  *  -nR”通过管道传给第2个命令。</span><br><span class="line">即第2个命令在第1个命令的结果中搜索。</span><br></pre></td></tr></table></figure><p>vi 学习见 -&gt; 日常技巧</p><p><strong>查找命令或应用程序的所在位置</strong></p><p><code>which pwd   //定位到/bin/pwd</code>  <code>whereis pwd  //可得到可执行程序的位置和手册页的位置</code></p><h2 id="gcc"><a class="markdownIt-Anchor" href="#gcc"></a> GCC</h2><p><strong>GCC 编译选项</strong></p><table><thead><tr><th>常用选项</th><th>描述</th></tr></thead><tbody><tr><td>-E</td><td>预处理，开发过程中想快速确定某个宏可以使用“-E -dM”</td></tr><tr><td>-c</td><td>把预处理、编译、汇编都做了，但是不链接</td></tr><tr><td>-o</td><td>指定输出文件</td></tr><tr><td>-I</td><td>指定头文件目录</td></tr><tr><td>-L</td><td>指定链接时库文件目录</td></tr><tr><td>-l</td><td>指定链接哪一个库文件</td></tr></tbody></table><p>其他有用的选项:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c   // 查看预处理结果，比如头文件是哪个</span><br><span class="line">gcc -E -dM main.c  &gt; 1.txt  // 把所有的宏展开，存在1.txt里</span><br><span class="line">gcc -Wp,-MD,abc.dep -c -o main.o main.c  // 生成依赖文件abc.dep，后面Makefile会用</span><br><span class="line"></span><br><span class="line">echo &#x27;main()&#123;&#125;&#x27;| gcc -E -v -  // 它会列出头文件目录、库目录(LIBRARY_PATH)</span><br></pre></td></tr></table></figure><p><strong>制作, 使用动态库 | 静态库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">动态库:</span><br><span class="line">制作、编译：</span><br><span class="line">gcc -c -o main.o  main.c</span><br><span class="line">gcc -c -o sub.o   sub.c</span><br><span class="line">gcc -shared  -o libsub.so  sub.o  sub2.o  sub3.o(可以使用多个.o生成动态库)</span><br><span class="line">gcc -o test main.o  -lsub  -L /libsub.so/所在目录/</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">① 先把libsub.so放到Ubuntu的/lib目录，然后就可以运行test程序。</span><br><span class="line">② 如果不想把libsub.so放到/lib，也可以放在某个目录比如/a，然后如下执行：</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/a  </span><br><span class="line">./test</span><br><span class="line"></span><br><span class="line">静态库:</span><br><span class="line">gcc -c -o main.o  main.c</span><br><span class="line">gcc -c -o sub.o   sub.c</span><br><span class="line">ar  crs  libsub.a  sub.o  sub2.o  sub3.o(可以使用多个.o生成静态库)</span><br><span class="line">gcc  -o  test  main.o  libsub.a  (如果.a不在当前目录下，需要指定它的绝对或相对路径)</span><br><span class="line">运行：</span><br><span class="line">不需要把静态库libsub.a放到板子上。</span><br><span class="line">注意:执行arm-linux-gnueabihf-gcc -c -o sub.o   sub.c交叉编译需要在最后面加上 -fPIC参数。</span><br></pre></td></tr></table></figure><p><strong>GCC编译过程</strong></p><img src="https://pic.imgdb.cn/item/62add7ee09475431293ddb72.jpg" style="zoom:75%;" /><ul><li><p>（1）预处理</p><p>C/C++源文件中，以“#”开头的命令被称为预处理命令，如包含命令“#include”、宏定义命令“#define”、条件编译命令“#if”、“#ifdef”等。预处理就是将要包含(include)的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码，最后将这些东西输出到一个“.i”文件中等待进一步处理。</p></li><li><p>（2）编译</p><p>编译就是把C/C++代码(比如上述的“.i”文件)“翻译”成汇编代码，所用到的工具为cc1(它的名字就是cc1，x86有自己的cc1命令，ARM板也有自己的cc1命令)。</p></li><li><p>（3）汇编</p><p>汇编就是将第二步输出的汇编代码翻译成符合一定格式的机器代码，在Linux系统上一般表现为ELF目标文件(OBJ文件)，用到的工具为as。x86有自己的as命令，ARM版也有自己的as命令，也可能是xxxx-as（比如arm-linux-as）。</p><p>“反汇编”是指将机器代码转换为汇编代码，这在调试程序时常常用到。</p></li><li><p>（4）链接</p><p>链接就是将上步生成的OBJ文件和系统库的OBJ文件、库文件链接起来，最终生成了可以在特定平台运行的可执行文件，用到的工具为ld或collect2。</p></li></ul><p>编译过程常用选项:</p><table><thead><tr><th>常用选项</th><th>描述</th></tr></thead><tbody><tr><td>-E</td><td>预处理，开发过程中想快速确定某个宏可以使用“-E -dM”</td></tr><tr><td>-c</td><td>把预处理、编译、汇编都做了，但是不链接</td></tr><tr><td>-o</td><td>指定输出文件</td></tr><tr><td>-I</td><td>指定头文件目录</td></tr><tr><td>-L</td><td>指定链接时库文件目录</td></tr><tr><td>-l</td><td>指定链接哪一个库文件</td></tr></tbody></table><p><strong>总体选项</strong></p><p>（1）-c</p><p>预处理、编译和汇编源文件，但是不作链接，编译器根据源文件生成OBJ文件。缺省情况下，GCC通过用’.o’替换源文件名的后缀’.c’，‘.i’，`.s’等，产生OBJ文件名。可以使用-o选项选择其他名字。GCC忽略-c选项后面任何无法识别的输入文件。</p><p>（2）-S</p><p>编译后即停止，不进行汇编。对于每个输入的非汇编语言文件，输出结果是汇编语言文件。缺省情况下，GCC通过用`.s’替换源文件名后缀 ‘.c’，'.i’等等，产生汇编文件名。可以使用-o选项选择其他名字。GCC忽略任何不需要汇编的输入文件。</p><p>（3）-E</p><p>预处理后即停止，不进行编译。预处理后的代码送往标准输出。</p><p>（4）-o file</p><p>指定输出文件为file。无论是预处理、编译、汇编还是链接，这个选项都可以使用。如果没有使用-o 选项，默认的输出结果是：可执行文件为a.out；修改输入文件的名称是source.suffix，则它的OBJ文件是source.o，汇编文件是 source.s，而预处理后的C源代码送往标准输出。</p><p>（5）-v</p><p>显示制作GCC工具自身时的配置命令；同时显示编译器驱动程序、预处理器、编译器的版本号。</p><h2 id="makefile"><a class="markdownIt-Anchor" href="#makefile"></a> Makefile</h2><p>demo:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">gcc -o hello hello.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f  hello</span><br></pre></td></tr></table></figure><p><strong>完善Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">第1个Makefile，简单粗暴，效率低：</span><br><span class="line">test : main.c sub.c sub.h</span><br><span class="line">    gcc -o test main.c sub.c</span><br><span class="line"></span><br><span class="line">第2个Makefile，效率高，相似规则太多太啰嗦，不支持检测头文件：</span><br><span class="line">test : main.o sub.o</span><br><span class="line">    gcc -o test main.o sub.o</span><br><span class="line">main.o : main.c</span><br><span class="line">    gcc -c -o main.o  main.c</span><br><span class="line">sub.o : sub.c</span><br><span class="line">    gcc -c -o sub.o  sub.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o test -f</span><br><span class="line"></span><br><span class="line">第3个Makefile，效率高，精炼，不支持检测头文件：</span><br><span class="line">test : main.o sub.o</span><br><span class="line">    gcc -o test main.o sub.o</span><br><span class="line">%.o : %.c //%是通配符</span><br><span class="line">    gcc -c -o <span class="variable">$@</span>  <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o test -f</span><br><span class="line"></span><br><span class="line">第4个Makefile，效率高，精炼，支持检测头文件(但是需要手工添加头文件规则)：</span><br><span class="line">test : main.o sub.o</span><br><span class="line">    gcc -o test main.o sub.o</span><br><span class="line">%.o : %.c </span><br><span class="line">    gcc -c -o <span class="variable">$@</span>(代表目标文件)  <span class="variable">$&lt;</span>(代表第一个依赖)</span><br><span class="line">sub.o : sub.h</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o test -f</span><br><span class="line"></span><br><span class="line">第5个Makefile，效率高，精炼，支持自动检测头文件：</span><br><span class="line">objs := main.o sub.o</span><br><span class="line">test : <span class="variable">$(objs)</span></span><br><span class="line">    gcc -o test <span class="variable">$^</span>(表示所有的依赖)</span><br><span class="line"><span class="comment"># 需要判断是否存在依赖文件</span></span><br><span class="line"><span class="comment"># .main.o.d .sub.o.d</span></span><br><span class="line">dep_files(依赖文件) := <span class="variable">$(<span class="built_in">foreach</span> f, <span class="variable">$(objs)</span>, .<span class="variable">$(f)</span>.d)</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把依赖文件包含进来</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,) (如果这个变量不等于空)</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">%.o : %.c</span><br><span class="line">    gcc -Wp,-MD,.<span class="variable">$@</span>.d  -c -o <span class="variable">$@</span>  <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o test -f</span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">    rm  <span class="variable">$(dep_files)</span> *.o test -f</span><br><span class="line">    </span><br><span class="line">----</span><br><span class="line">CFLAGS(编译参数) = -Werr (把所有警告都当作错误) -I(指定头文件目录) . -Iinclude(默认头文件目录)</span><br></pre></td></tr></table></figure><p>**假想目标 : ** <code>.PHONY</code></p><p>**即时变量  延时变量 : ** <code>export</code>  <code>A := xxx 定义时就确定</code>  <code>B = xxx 使用时才确定</code></p><p><code>?=  延时变量 只有在第一次定义才起效</code>  <code>+=  是即时还是延时取决于前面的定义</code></p><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">目标(target)…: 依赖(prerequiries)…</span></span><br><span class="line">&lt;tab&gt;命令(command)</span><br><span class="line">如果“依赖文件”比“目标文件”更加新，那么执行“命令”来重新生成“目标文件”。</span><br><span class="line">命令被执行的2个条件：依赖文件比目标文件新，或是 目标文件还没生成。</span><br></pre></td></tr></table></figure><p><code>$(foreach var,list,text)</code></p><p>对list中的每一个元素，取出来赋给var，然后把var改为text所描述的形式。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">objs := a.o b.o</span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f, <span class="variable">$(objs)</span>, .<span class="variable">$(f)</span>.d)</span> // 最终 dep_files := .a.o.d .b.o.d</span><br></pre></td></tr></table></figure><p><code>$(wildcard pattern)</code></p><p>pattern所列出的文件是否存在，把存在的文件都列出来。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">src_files := $( wildcard  *.c)  // 最终 src_files中列出了当前目录下的所有.c文件</span><br></pre></td></tr></table></figure><p><code>$(filter pattern..., text)</code>  <code>$(filter-out pattern..., text)</code></p><p>在text中取出符合patten格式的值            (不符合)</p><p><code>$(patsubst pattern, replacement, $(var))</code></p><p>从列表中取出每一个值, 如果符合pattern, 则替换为replacement</p><p><code>gcc -M c.c</code> 打印出依赖</p><p><code>gcc -M -MF c.d c.c</code> 把依赖写入文件c.d</p><p><code>gcc -c -o c.o c.c -MD -MF c.d</code>  编译c.o, 把依赖写入文件c.d</p><h3 id="通用makefile使用"><a class="markdownIt-Anchor" href="#通用makefile使用"></a> 通用Makefile使用</h3><p>目录: <code>D:\imx6ull\01_all_series_quickstart\04_嵌入式Linux应用开发基础知识\source\05_general_Makefile\Makefile_and_readme</code></p><p>待补充</p><h2 id="文件io"><a class="markdownIt-Anchor" href="#文件io"></a> 文件IO</h2><img src="https://pic.imgdb.cn/item/62add82909475431293e37f0.jpg" style="zoom: 67%;" /><ul><li><p>如果要访问真实的文件(SD卡 等等) 需要挂载</p><p>可以 <code>cat /proc/mounts</code> 看是否自动挂载</p><p>使用<code>mount /dev/sda1 /mnt</code> 来手动挂载到mnt目录下</p></li><li><p>有些文件是虚拟的,Linux内核提供虚拟文件系统,根据虚拟文件系统里面的文件可以查看内核的一些信息<code>/sys</code></p></li><li><p>其他为驱动文件, 通过函数去直接操作硬件</p></li></ul><p>在Linux内核有俩种驱动,字符设备驱动’c’(ls -al 第一个字母)  块设备’b’  主设备号  次设备号  (通过这些来确定到底是哪一个驱动  哪一个硬件)</p><p>不是通用的函数：<code>ioctl/mmap</code></p><p><strong>俩个复制文件的demo:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">这个是用 write / read 方式</span><br><span class="line">    </span><br><span class="line"><span class="number">02</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="number">03</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="number">04</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="number">05</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">06</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">07</span></span><br><span class="line"><span class="number">08</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">09  * ./copy 1.txt 2.txt</span></span><br><span class="line"><span class="comment">10  * argc    = 3</span></span><br><span class="line"><span class="comment">11  * argv[0] = &quot;./copy&quot;</span></span><br><span class="line"><span class="comment">12  * argv[1] = &quot;1.txt&quot;</span></span><br><span class="line"><span class="comment">13  * argv[2] = &quot;2.txt&quot;</span></span><br><span class="line"><span class="comment">14  */</span></span><br><span class="line"><span class="number">15</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">16 &#123;</span><br><span class="line"><span class="number">17</span>      <span class="type">int</span> fd_old, fd_new;</span><br><span class="line"><span class="number">18</span>      <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="number">19</span>      <span class="type">int</span> len;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>      <span class="comment">/* 1. 判断参数 */</span></span><br><span class="line"><span class="number">22</span>      <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line"><span class="number">23</span>      &#123;</span><br><span class="line"><span class="number">24</span>              <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;old-file&gt; &lt;new-file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="number">25</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">26</span>      &#125;</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span>      <span class="comment">/* 2. 打开老文件 */</span></span><br><span class="line"><span class="number">29</span>      fd_old = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line"><span class="number">30</span>      <span class="keyword">if</span> (fd_old == <span class="number">-1</span>)</span><br><span class="line"><span class="number">31</span>      &#123;</span><br><span class="line"><span class="number">32</span>              <span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="number">33</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">34</span>      &#125;</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">36</span>      <span class="comment">/* 3. 创建新文件 */</span></span><br><span class="line"><span class="number">37</span>      fd_new = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line"><span class="number">38</span>      <span class="keyword">if</span> (fd_new == <span class="number">-1</span>)</span><br><span class="line"><span class="number">39</span>      &#123;</span><br><span class="line"><span class="number">40</span>              <span class="built_in">printf</span>(<span class="string">&quot;can not creat file %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="number">41</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">42</span>      &#125;</span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">44</span>      <span class="comment">/* 4. 循环： 读老文件-写新文件 */</span></span><br><span class="line"><span class="number">45</span>      <span class="keyword">while</span> ((len = read(fd_old, buf, <span class="number">1024</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="number">46</span>      &#123;</span><br><span class="line"><span class="number">47</span>              <span class="keyword">if</span> (write(fd_new, buf, len) != len)</span><br><span class="line"><span class="number">48</span>              &#123;</span><br><span class="line"><span class="number">49</span>                      <span class="built_in">printf</span>(<span class="string">&quot;can not write %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="number">50</span>                      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">51</span>              &#125;</span><br><span class="line"><span class="number">52</span>      &#125;</span><br><span class="line"><span class="number">53</span></span><br><span class="line"><span class="number">54</span>      <span class="comment">/* 5. 关闭文件 */</span></span><br><span class="line"><span class="number">55</span>      close(fd_old);</span><br><span class="line"><span class="number">56</span>      close(fd_new);</span><br><span class="line"><span class="number">57</span></span><br><span class="line"><span class="number">58</span>      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">59</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这个使用 mmap方式</span><br><span class="line"></span><br><span class="line"><span class="number">02</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="number">03</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="number">04</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="number">05</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">06</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">07</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="number">08</span></span><br><span class="line"><span class="number">09</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">10  * ./copy 1.txt 2.txt</span></span><br><span class="line"><span class="comment">11  * argc    = 3</span></span><br><span class="line"><span class="comment">12  * argv[0] = &quot;./copy&quot;</span></span><br><span class="line"><span class="comment">13  * argv[1] = &quot;1.txt&quot;</span></span><br><span class="line"><span class="comment">14  * argv[2] = &quot;2.txt&quot;</span></span><br><span class="line"><span class="comment">15  */</span></span><br><span class="line"><span class="number">16</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">17 &#123;</span><br><span class="line"><span class="number">18</span>      <span class="type">int</span> fd_old, fd_new;</span><br><span class="line"><span class="number">19</span>      <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line"><span class="number">20</span>      <span class="type">char</span> *buf;</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span>      <span class="comment">/* 1. 判断参数 */</span></span><br><span class="line"><span class="number">23</span>      <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line"><span class="number">24</span>      &#123;</span><br><span class="line"><span class="number">25</span>              <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;old-file&gt; &lt;new-file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="number">26</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">27</span>      &#125;</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span>      <span class="comment">/* 2. 打开老文件 */</span></span><br><span class="line"><span class="number">30</span>      fd_old = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line"><span class="number">31</span>      <span class="keyword">if</span> (fd_old == <span class="number">-1</span>)</span><br><span class="line"><span class="number">32</span>      &#123;</span><br><span class="line"><span class="number">33</span>              <span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="number">34</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">35</span>      &#125;</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">37</span>      <span class="comment">/* 3. 确定老文件的大小 */</span></span><br><span class="line"><span class="number">38</span>      <span class="keyword">if</span> (fstat(fd_old, &amp;stat) == <span class="number">-1</span>)</span><br><span class="line"><span class="number">39</span>      &#123;</span><br><span class="line"><span class="number">40</span>              <span class="built_in">printf</span>(<span class="string">&quot;can not get stat of file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="number">41</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">42</span>      &#125;</span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">44</span>      <span class="comment">/* 4. 映射老文件 */</span></span><br><span class="line"><span class="number">45</span>      buf = mmap(<span class="literal">NULL</span>, stat.st_size, PROT_READ, MAP_SHARED, fd_old, <span class="number">0</span>);</span><br><span class="line"><span class="number">46</span>      <span class="keyword">if</span> (buf == MAP_FAILED)</span><br><span class="line"><span class="number">47</span>      &#123;</span><br><span class="line"><span class="number">48</span>              <span class="built_in">printf</span>(<span class="string">&quot;can not mmap file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="number">49</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">50</span>      &#125;</span><br><span class="line"><span class="number">51</span></span><br><span class="line"><span class="number">52</span>      <span class="comment">/* 5. 创建新文件 */</span></span><br><span class="line"><span class="number">53</span>      fd_new = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line"><span class="number">54</span>      <span class="keyword">if</span> (fd_new == <span class="number">-1</span>)</span><br><span class="line"><span class="number">55</span>      &#123;</span><br><span class="line"><span class="number">56</span>              <span class="built_in">printf</span>(<span class="string">&quot;can not creat file %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="number">57</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">58</span>      &#125;</span><br><span class="line"><span class="number">59</span></span><br><span class="line"><span class="number">60</span>      <span class="comment">/* 6. 写新文件 */</span></span><br><span class="line"><span class="number">61</span>      <span class="keyword">if</span> (write(fd_new, buf, stat.st_size) != stat.st_size)</span><br><span class="line"><span class="number">62</span>      &#123;</span><br><span class="line"><span class="number">63</span>              <span class="built_in">printf</span>(<span class="string">&quot;can not write %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="number">64</span>              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">65</span>      &#125;</span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">67</span>      <span class="comment">/* 5. 关闭文件 */</span></span><br><span class="line"><span class="number">68</span>      close(fd_old);</span><br><span class="line"><span class="number">69</span>      close(fd_new);</span><br><span class="line"><span class="number">70</span></span><br><span class="line"><span class="number">71</span>      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">72</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用函数怎么进入内核"><a class="markdownIt-Anchor" href="#系统调用函数怎么进入内核"></a> 系统调用函数怎么进入内核?</h3><p>应用程序通过 open/read/write 进而去访问设备、文件。</p><p>进入到内核kernel, 对于普通文件,会使用文件系统去读取对应的磁盘, 对于硬件, 会去找到内核中对应的驱动程序调用相关的程序</p><p><strong>调用过程</strong></p><p>这些关于文件的函数一般是由<code>glibc</code>提供的,以及其他不同版本的C库(ucibc), open这些要去打开文件需要依赖操作系统提供的功能(怎么进入Linux内核),  可以把内核当作另外一个APP , 这个app不能去调用另外一个app里面的函数</p><p>open函数里面会放一条指令, 比如在32为cpu,会使用<code>swi</code>指令, 对于64位cpu, 使用<code>svc</code>指令, 一旦执行这些指令, 就会触发CPU的异常, 会导致CPU跳到某个地址里面去执行系统里面的代码, 这时候操作系统就会去执行对应的<code>sys_open  sys_read</code>函数, 对于read , write 函数也是如此.</p><p>那么它怎么知道app触发这个异常是为了去调用<code>sys_open</code>或者是<code>sys_read</code>, glibc在实现sys这些系统调用的时候, 会使用这些命令(swi等)来触发异常, 并且传入不同的参数给内核, 内核根据不同的参数来分辨是想调用哪个</p><p><img src="https://pic.imgdb.cn/item/62add89b09475431293edbfd.jpg" alt="" /></p><ul><li>glibc里面怎么传递参数给内核呢?  最开始用的old abi 二进制接口(老的API), 在执行swi指令的时候可以在这条指令后面跟一个数值,  内核执行这个swi的异常处理函数时会把后面的数值取出来, 根据里面的值知道要去调用什么函数.</li><li>后来又有改进,使用EABI, 不在swi里面传参数了, 它事先在 R7 寄存器(汇编) 里面存入那些值, 当发生异常的时候,内核会去R7寄存器得到这些值, 进而得到去执行sys的什么函数</li><li>对于64位,使用svc指令, 通过X8寄存器传入, 内核里面有一个<code>系统函数调用指针数组</code>, <code>sys_call_table</code>内核把库函数传进来的值处理之后,  用这个值作为下标, 在这个数组里面对应的函数.(阅读glibc的源码,内核源码)</li></ul><p><strong>app调用openread导致内核的sys_openread被调用,那么内核的sys_openread会做什么事情呢</strong></p><img src="https://pic.imgdb.cn/item/62add8b609475431293f0925.jpg" style="zoom:67%;" /><h1 id="linux软件架构"><a class="markdownIt-Anchor" href="#linux软件架构"></a> Linux软件架构</h1><p>在linux系统软件<a href="https://so.csdn.net/so/search?q=%E6%9E%B6%E6%9E%84&amp;spm=1001.2101.3001.7020">架构</a>可以分为4个层次（从低到高分别为）：</p><p><strong>1.引导加载程序</strong></p><p>​     引导加载程序（Bootloader）是固化在硬件Flash中的一段引导代码，用于完成硬件的一些基本配置，引导内核启动。</p><p>​     同时，Bootloader会在自身与内核分区之间存放一些可设置的参数（Boot parameters），比如IP地址，串口<a href="https://so.csdn.net/so/search?q=%E6%B3%A2%E7%89%B9%E7%8E%87&amp;spm=1001.2101.3001.7020">波特率</a>，要传递给内核的命令行参数。</p><p><strong>2.系统内核</strong></p><p>​     系统内核（Kernel）是整个操作系统的最底层，它负责整个硬件的驱动，以及提供各种系统所需的核心功能，包括防火墙机制、是否支持LVM或Quota等文件系统等等，如果内核不认识某个最新的硬件，那么硬件也就无法被驱动，你也就无法使用该硬件。计算机真正工作的东西其实是硬件，例如数值运算要使用到CPU、数据储存要使用到硬盘、图形显示会用到显示适配器、音乐发声要有音效芯片、连接Internet 可能需要网络卡等等。内核就是控制这些芯片如何工作。</p><p><strong>3.文件系统</strong></p><p>​     Linux文件系统（File System）中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。</p><p>​     文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。</p><p><strong>4.用户程序</strong></p><p>​     用户应用程序（Application）为了完成某项或某几项特定任务而被开发运行于操作系统之上的计算机程序。</p><h2 id="linux启动过程"><a class="markdownIt-Anchor" href="#linux启动过程"></a> Linux启动过程</h2><p>正常启动过程中，Bootloader首先运行，然后将内核复制到内存中（或者在固态存储设备上直接运行，但是效率较低），并在内存某个固定的地址（包括地址与参数的结构）设置好要传递给内核的参数，最后运行内核。内核启动后，挂载（mount）根文件系统（Root filesystem），启动文件系统中的应用程序。</p><p>上电 ——&gt; Bootloader —[传递参数]—&gt; 加载内核 ——&gt; 内核挂载根文件系统 ——&gt;执行应用程序</p><img src="https://pic.imgdb.cn/item/62ade7f60947543129581ca2.jpg" style="zoom: 50%;" /><h2 id="如何理解bootloader与kernel"><a class="markdownIt-Anchor" href="#如何理解bootloader与kernel"></a> 如何理解Bootloader与Kernel</h2><p>操作系统内核本身就是一个裸机程序，和我们学的uboot和其他裸机程序没有本质的区别；事实上，不少U-Boot源码就是根据相应的Linux内核源程序进行简化而形成的，尤其是一些设备的驱动程序。如果我们去琢磨U-Boot源码的注释，便会轻易的发现这一情况。</p><p>区别就是操作系统运行起来后可以分为应用层（用户态）和内核层（内核态），分层后，两层的权限不同（实现的原理是基于CPU的模式切换），内存访问和设备操作的管理上更加精细（内核可以随便方位各种硬件，而应用程序只能被限制的访问硬件和内存地址）。</p><blockquote><p>以ARM处理器为例，除用户模式外，其余6种工作模式都属于特权模式：</p><p>用户模式（USR）：正常程序执行模式，不能直接切换到其他模式</p><p>系统模式（SYS）：运行操作系统的特权任务，与用户模式类似，但具有可以直接切换到其他模式等特权</p><p>快中断模式（FIQ）：支持高速数据传输及通道处理，FIQ异常响应时进入此模式</p><p>中断模式（IRQ）：用于通用中断处理，IRQ异常响应时进入此模式</p><p>管理模式（SVC）：操作系统保护模式，系统复位和软件中断响应时进入此模式（由系统调用执行软中断SWI命令触发）</p><p>中止模式（ABT）：用于支持虚拟内存和/或存储器保护，在ARM7TDMI没有大用处</p><p>未定义模式（UND）：支持硬件协处理器的软件仿真，未定义指令异常响应时进入此模式</p><p>Linux内核态是从ARM的SVC即管理模式下启动的，但在某些情况下、如：硬件中断、程序异常（被动）等情况下进入ARM的其他特权模式，这时仍然可以进入内核态（因为就是可以操作内核了）；同样，Linux用户态是从ARM用户模式启动的，但当进入ARM系统模式时、仍然可以操作Linux用户态程序（进入用户态，如init进程的启动过程）。</p><p>即：Linux内核从ARM的SVC模式下启动，但内核态不仅仅指ARM的SVC模式（还包括可以访问内核空间的所有ARM模式）；Linux用户程序从ARM的用户模式启动，但用户态不仅仅指ARM的用户模式。</p></blockquote><p>直观来看：uboot的镜像是u-boot.bin，Linux系统的镜像是zImage，这两个东西其实都是裸机程序镜像。从系统启动的角度来讲，内核和uboot都是裸机程序。</p><h2 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p>Linux文件系统中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。这种机制有利于用户和操作系统的交互。</p><p>尽管内核是 Linux 的核心，但文件却是用户与操作系统交互所采用的主要工具。这对 Linux 来说尤其如此，这是因为在 UNIX 传统中，它使用文件 I/O 机制管理硬件设备和数据文件</p><h3 id="虚拟文件系统-根文件系统和文件系统"><a class="markdownIt-Anchor" href="#虚拟文件系统-根文件系统和文件系统"></a> 虚拟文件系统、根文件系统和文件系统</h3><h3 id="vfs"><a class="markdownIt-Anchor" href="#vfs"></a> VFS：</h3><p>Linux支持多种文件系统类型，因为它将底层与应用层分隔开；而提供统一的接口支持应用层对于不同实现的文件系统的访问，这个统一的接口称为虚拟文件系统VFS。</p><p>kernel中以VFS去支持各种文件系统，如yaffs，ext3，cramfs等等。yaffs/yaffs2是专为<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&amp;spm=1001.2101.3001.7020">嵌入式</a>系统使用NAND型闪存而设计的一种日志型文件系统。在内核中以VFS来屏蔽各种文件系统的接口不同，以VFS向kernel提供一个统一的接口。</p><h3 id="根文件系统"><a class="markdownIt-Anchor" href="#根文件系统"></a> 根文件系统</h3><p>文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。以“/”为顶级目录的文件系统称为根文件系统。</p><p>Linux启动时，第一个必须挂载的是根文件系统；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。系统正常挂载根文件系统之后可以自动或手动挂载其他的文件系统（根文件系统是其他文件的最终挂载点）。因此，一个系统中可以同时存在不同的文件系统。</p><blockquote><p>也就是说：</p><p>根文件系统可以是任何kernel支持的文件系统类型(ext4,yaffs等)。</p><p>但它必须包含linux内核启动时所必需的文件(根文件系统必需存在的目录 /dev /bin /sbin 等等)，不然系统启动会失败。</p><p>根文件系统是之所以有个根(/)字,是因为它是linux系统启动时挂载(mount,所谓挂载：就是在内存中创建一个虚拟的文件对应具体的存储空间分区的过程,挂载时不会保存信息,下次启动时得重新挂载)的第一个文件系统,启动完成后可以自动(配置etc/fstab)或者手动的方式将其它文件系统(分区)挂载到根文件系统中。</p></blockquote><h3 id="其他文件系统"><a class="markdownIt-Anchor" href="#其他文件系统"></a> 其他文件系统</h3><p>不同的文件系统类型有不同的特点，因而根据存储设备的硬件特性、系统需求等有不同的应用场合。在嵌入式Linux应用中，主要的存储设备为 RAM(DRAM, SDRAM)和ROM(常采用FLASH存储器)，常用的基于存储设备的文件系统类型包括：jffs2, yaffs, cramfs, romfs, ramdisk,initramfs, ramfs/tmpfs,ubifs等。</p><h3 id="uboot与根文件系统的关系"><a class="markdownIt-Anchor" href="#uboot与根文件系统的关系"></a> uboot与根文件系统的关系</h3><p>早期的uboot没有分区的概念，uboot只知道应该将什么数据烧写到存储介质的什么区间中。</p><p>（也就是说，对于uboot来看，只有起始地址结束地址等，A～B地址放内核，C～D地址放文件系统，即：规定哪个地址区间放内核或者文件系统等）</p><p>虽然此后，uboot中渐渐也有了MTD等管理分区部分的功能。尽管如此，不影响我们的学习理解。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>cpu首先执行位于0地址的uboot，uboot启动以后初始化一些资源，告诉内核有关的参数并引导内核，内核通过事先添加对于某种文件系统类型的支持驱动（相当于一小段程序），读取uboot等boot loader在指定的区域烧写制作好的文件系统镜像，内核解析并挂载成根文件系统，并在此基础上，通过VFS再挂载不同的文件系统类型，完成启动以后，再去管理有关的资源（包括应用程序）</p><h1 id="应用编程"><a class="markdownIt-Anchor" href="#应用编程"></a> 应用编程</h1><h2 id="framebufferioctl-mmap"><a class="markdownIt-Anchor" href="#framebufferioctl-mmap"></a> Framebuffer(ioctl  mmap)</h2><p>bpp: 每个像素用多少位来表示它的颜色</p><p><strong>首地址+偏移地址=确定出位于哪里</strong></p><p>假设fb_base是APP执行mmap后得到的Framebuffer地址</p><p>求偏移地址: <code>y*line_width+x*pixel_width(这就时偏移地址) + fb_base = 绝对地址</code></p><p>可以用以下公式算出(x,y)坐标处像素对应的Framebuffer地址：</p><p>(x，y)像素起始地址=fb_base+(xres*bpp/8)<em>y + x</em>bpp/8</p><p>一行的宽度: <code>xres * bpp/8</code> 一个像素宽度: <code>bpp/8</code></p><h3 id="ioctl"><a class="markdownIt-Anchor" href="#ioctl"></a> ioctl</h3><p>ioctl是设备驱动程序中对设备的I/O通道进行管理的函数 。所谓对I/O通道进行管理，就是对设备的一些特性进行控制</p><p>ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数来控制设备的I/O通道。</p><p>头文件：<code>#include &lt;sys/ioctl.h&gt;</code></p><p>函数原型： <code>int ioctl(int fd, unsigned long request, ...);</code></p><p>函数说明：</p><p>① fd 表示文件描述符；</p><p>② request表示与驱动程序交互的命令，用不同的命令控制驱动程序输出我们需要的数据；</p><p>③ … 表示可变参数arg，根据request命令，设备驱动程序返回输出的数据。</p><p>④ 返回值：打开成功返回文件描述符，失败将返回-1。</p><p>ioctl的作用非常强大、灵活。不同的驱动程序内部会实现不同的ioctl，APP可以使用各种ioctl跟驱动程序交互：可以传数据给驱动程序，也可以从驱动程序中读出数据。</p><h3 id="mmap"><a class="markdownIt-Anchor" href="#mmap"></a> mmap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line">函数原型：</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"></span><br><span class="line">函数说明：</span><br><span class="line">① addr表示指定映射的內存起始地址，通常设为 <span class="literal">NULL</span>表示让系统自动选定地址，并在成功映射后返回该地址；</span><br><span class="line">② length表示将文件中多大的内容映射到内存中；</span><br><span class="line">③ prot 表示映射区域的保护方式，可以为以下<span class="number">4</span>种方式的组合</span><br><span class="line">a. PROT_EXEC 映射区域可被执行</span><br><span class="line">b. PROT_READ 映射区域可被读出</span><br><span class="line">c. PROT_WRITE 映射区域可被写入</span><br><span class="line">d. PROT_NONE 映射区域不能存取</span><br><span class="line">④ Flags 表示影响映射区域的不同特性，常用的有以下两种</span><br><span class="line">a. MAP_SHARED 表示对映射区域写入的数据会复制回文件内，原来的文件会改变。</span><br><span class="line">b. MAP_PRIVATE 表示对映射区域的操作会产生一个映射文件的复制，对此区域的任何修改都不会写回原来的文件内容中。</span><br><span class="line">⑤ 返回值：若成功映射，将返回指向映射的区域的指针，失败将返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><p>映射framebuffer, framebuffer时驱动程序分配的, 应用程序想要去使用必须使用mmap映射到用户空间, 应用程序得到LCD的参数并且得到framebuffer的地址之后就可以在上面操作了.</p><p>描点函数demo:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">28</span> <span class="type">void</span> <span class="title function_">lcd_put_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> color(传入RGB888))</span></span><br><span class="line">29 &#123;</span><br><span class="line"><span class="number">30</span>      <span class="type">unsigned</span> <span class="type">char</span> *pen_8 = fb_base+y*line_width+x*pixel_width;</span><br><span class="line"><span class="number">31</span>      <span class="type">unsigned</span> <span class="type">short</span> *pen_16;</span><br><span class="line"><span class="number">32</span>      <span class="type">unsigned</span> <span class="type">int</span> *pen_32;</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">34</span>      <span class="type">unsigned</span> <span class="type">int</span> red, green, blue;</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">36</span>      pen_16 = (<span class="type">unsigned</span> <span class="type">short</span> *)pen_8;</span><br><span class="line"><span class="number">37</span>      pen_32 = (<span class="type">unsigned</span> <span class="type">int</span> *)pen_8;</span><br><span class="line"><span class="number">38</span></span><br><span class="line"><span class="number">39</span>      <span class="keyword">switch</span> (var.bits_per_pixel)</span><br><span class="line"><span class="number">40</span>      &#123;</span><br><span class="line"><span class="number">41</span>              <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="number">42</span>              &#123;</span><br><span class="line"><span class="number">43</span>                      *pen_8 = color;</span><br><span class="line"><span class="number">44</span>                      <span class="keyword">break</span>;</span><br><span class="line"><span class="number">45</span>              &#125;</span><br><span class="line"><span class="number">46</span>              <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line"><span class="number">47</span>              &#123;</span><br><span class="line"><span class="number">48</span>                      <span class="comment">/* 565 */</span></span><br><span class="line"><span class="number">49</span>                      red   = (color &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="number">50</span>                      green = (color &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="number">51</span>                      blue  = (color &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="number">52</span>                      color = ((red &gt;&gt; <span class="number">3</span>) &lt;&lt; <span class="number">11</span>) | ((green &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">5</span>) | (blue &gt;&gt;                         <span class="number">3</span>);<span class="comment">//保证绿颜色高六位 //保证蓝颜色高五位</span></span><br><span class="line"><span class="number">53</span>                      *pen_16 = color;</span><br><span class="line"><span class="number">54</span>                      <span class="keyword">break</span>;</span><br><span class="line"><span class="number">55</span>              &#125;</span><br><span class="line"><span class="number">56</span>              <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line"><span class="number">57</span>              &#123;</span><br><span class="line"><span class="number">58</span>                      *pen_32 = color;</span><br><span class="line"><span class="number">59</span>                      <span class="keyword">break</span>;</span><br><span class="line"><span class="number">60</span>              &#125;</span><br><span class="line"><span class="number">61</span>              <span class="keyword">default</span>:</span><br><span class="line"><span class="number">62</span>              &#123;</span><br><span class="line"><span class="number">63</span>                      <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t surport %dbpp\n&quot;</span>, var.bits_per_pixel);</span><br><span class="line"><span class="number">64</span>                      <span class="keyword">break</span>;</span><br><span class="line"><span class="number">65</span>              &#125;</span><br><span class="line"><span class="number">66</span>      &#125;</span><br><span class="line"><span class="number">67</span> &#125;</span><br><span class="line">第<span class="number">28</span>行中传入的color表示颜色，它的格式永远是<span class="number">0x00</span>RRGGBB，即RGB888。当LCD是<span class="number">16b</span>pp时，要把color变量中的R、G、B抽出来再合并成RGB565格式。</span><br><span class="line">第<span class="number">30</span>行计算(x,y)坐标上像素对应的Framebuffer地址。</span><br><span class="line">第<span class="number">43</span>行，对于<span class="number">8b</span>pp，color就不再表示RBG三原色了，这涉及调色板的概念，color是调色板的值。</span><br><span class="line">第<span class="number">49</span>～<span class="number">51</span>行，先从color变量中把R、G、B抽出来。</span><br><span class="line">第<span class="number">52</span>行，把red、green、blue这三种<span class="number">8</span>位颜色值，根据RGB565的格式，只保留red中的高<span class="number">5</span>位、green中的高<span class="number">6</span>位、blue中的高<span class="number">5</span>位，组合成一个新的<span class="number">16</span>位颜色值。</span><br><span class="line">第<span class="number">53</span>行，把新的<span class="number">16</span>位颜色值写入Framebuffer。</span><br><span class="line">第<span class="number">58</span>行，对于<span class="number">32b</span>pp，颜色格式跟color参数一致，可以直接写入Framebuffer。</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* 清屏: 全部设为白色 */</span></span><br><span class="line"><span class="number">96</span>      <span class="built_in">memset</span>(fbmem, <span class="number">0xff</span>, screen_size);</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">98</span>      <span class="comment">/* 随便设置出100个为红色 */</span></span><br><span class="line"><span class="number">99</span>      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line"><span class="number">100</span>             lcd_put_pixel(var.xres/<span class="number">2</span>+i, var.yres/<span class="number">2</span>, <span class="number">0xFF0000</span>);</span><br></pre></td></tr></table></figure><h2 id="文字显示"><a class="markdownIt-Anchor" href="#文字显示"></a> 文字显示</h2><h3 id="字符编码"><a class="markdownIt-Anchor" href="#字符编码"></a> 字符编码</h3><p><code>ASCII</code> 常用字母就26个，区分大小写、加上标点符号也没超过127个，每个字符用一个字节来表示就足够了。一个字节的7位就可以表示128个数值，在ASCII码中最高位永远是0。</p><p><img src="https://pic.imgdb.cn/item/6282470109475431294c9869.png" alt="" /></p><p><code>ANSI</code> ASNI是ASCII的扩展，向下包含ASCII。对于ASCII字符仍以一个字节来表示，对于非ASCII字符则使用2字节来表示。</p><p>在中国大陆地区，ANSI的默认编码是GB2312；在港澳台地区默认编码是BIG5。以数值“0xd0d6”为例，对于GB2312编码它表示“中”；对于BIG5编码它表示“笢”。所以对于ANSI编码的TXT文件，如果你打开它发现乱码，那么还得再次细分它的具体编码。</p><p><code>UNICODE</code></p><p>在ANSI标准中，很多种文字都有自己的编码标准，汉字简体字有GB2312、繁体字有BIG5，这难免同一个数值对应不同字符。比如数值“0xd0d6”，对于GB2312编码它表示“中”；对于BIG5编码它表示“笢”。这造成了使用ANSI编码保存的文件，不适合跨地区交流。</p><p>UNICODE编码就是解决这类问题：对于地球上任意一个字符，都给它一个唯一的数值。</p><p>UNICODE仍然向下兼容ASCII，但是对于其他字符会有对应的数值，比如对于“中”、“笢”，它们的数值分别是：0x4e2d、0x7b22</p><p>UNICODE中的数值范围是0x0000至0x10FFFF，有1,114,111即100多万个数值，可以表示100多万个字符，足够地球人使用了。</p><h3 id="ascii字符显示"><a class="markdownIt-Anchor" href="#ascii字符显示"></a> ASCII字符显示</h3><p><img src="https://pic.imgdb.cn/item/6282594b09475431299abf28.png" alt="" /></p><h3 id="中文字符显示"><a class="markdownIt-Anchor" href="#中文字符显示"></a> 中文字符显示</h3><p>如果不指定“-finput-charset”，GCC就会默认C程序的编码方式为UTF-8，即使你是以ANSI格式保存，也会被当作UTF-8来对待。</p><p>对于编译出来的可执行程序，可以指定它里面的字符是以什么方式编码，可以使用以下的选项编译器：</p><p><code>-fexec-charset=GB231</code></p><p><code>-fexec-charset=UTF-8</code></p><p>如果不指定“-fexec-charset”，GCC就会默认编译出的可执行程序中字符的编码方式为UTF-8。</p><p>如果“-finput-charset”与“-fexec-charset”不一样，编译器会进行格式转换。</p><p>待补充…</p><h3 id="交叉编译程序以freetype为例"><a class="markdownIt-Anchor" href="#交叉编译程序以freetype为例"></a> 交叉编译程序：以freetype为例</h3><p>使用buildroot来给ARM板编译程序、编译库会很简单,这里freetype在编译 安装一些小程序很有用</p><h4 id="库相关知识"><a class="markdownIt-Anchor" href="#库相关知识"></a> 库相关知识</h4><ol><li><p>编译程序时去哪找头文件？</p><p>系统目录：就是交叉编译工具链里的某个include目录；</p><p>也可以自己指定：编译时用 “ -I dir ”选项指定。</p></li><li><p>链接时去哪找库文件？</p><p>系统目录：就是交叉编译工具链里的某个lib目录；</p><p>也可以自己指定：链接时用 “ -L dir ”选项指定。</p></li><li><p>运行时去哪找库文件？</p><p>系统目录：就是板子上的/lib、/usr/lib目录；</p><p>也可以自己指定：运行程序用环境变量LD_LIBRARY_PATH指定。</p></li><li><p>运行时不需要头文件，所以头文件不用放到板子上</p></li></ol><p><strong>库的问题</strong>  这是链接程序时出现的问题</p><p>系统目录：就是交叉编译工具链里的某个lib目录, 也可以自己指定：链接时用 <code>-L dir</code>选项指定</p><p>怎么确定“系统目录”？执行下面命令确定目录：</p><p><code>echo 'main()&#123;&#125;'| arm-buildroot-linux-gnueabihf-gcc -E -v –</code></p><p>它会列出头文件目录、库目录(LIBRARY_PATH)，你编译出库文件时，可以把它放入系统库目录。</p><p><strong>运行问题</strong></p><p>系统目录：就是板子上的/lib、/usr/lib目录</p><p>也可以自己指定：  运行程序用环境变量LD_LIBRARY_PATH指定，执行以下的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export  LD_LIBRARY_PATH=/xxx_dir  ;  ./test</span><br><span class="line">或</span><br><span class="line">LD_LIBRARY_PATH=/xxx_dir   ./test</span><br></pre></td></tr></table></figure><h4 id="交叉编译"><a class="markdownIt-Anchor" href="#交叉编译"></a> 交叉编译</h4><p>如果交叉编辑工具链的前缀是arm-buildroot-linux-gnueabihf-，比如arm-buildroot-linux-gnueabihf-gcc，交叉编译开源软件时，如果它里面有configure</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure  --host=arm-buildroot-linux-gnueabihf(这里自己修改)   --prefix=$PWD/tmp</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>就可以在当前目录的tmp目录下看见bin, lib, include等目录，里面存有可执行程序、库、头文件。</p><p>程序运行不需要头文件</p><h3 id="freetype"><a class="markdownIt-Anchor" href="#freetype"></a> freetype</h3><p>Freetype是开源的字体引擎库，它提供统一的接口来访问多种字体格式文件，从而实现矢量字体显示。我们只需要移植这个字体引擎，调用对应的API接口，提供字体文件，就可以让freetype库帮我们取出关键点、实现闭合曲线，填充颜色，达到显示矢量字体的目的。</p><p>一个文字的显示过程可以概括如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">① 给定一个字符可以确定它的编码值(ASCII、UNICODE、GB2312)；</span><br><span class="line"></span><br><span class="line">② 设置字体大小；</span><br><span class="line"></span><br><span class="line">③ 根据编码值，从文件头部中通过charmap找到对应的关键点(glyph)，它会根据字体大小调整关键点；</span><br><span class="line"></span><br><span class="line">④ 把关键点转换为位图点阵；</span><br><span class="line"></span><br><span class="line">⑤ 在LCD上显示出来</span><br></pre></td></tr></table></figure><p><strong>如何使用freetype库，总结出下列步骤：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">① 初始化：FT_InitFreetype</span><br><span class="line"></span><br><span class="line">② 加载(打开)字体Face：FT_New_Face</span><br><span class="line"></span><br><span class="line">③ 设置字体大小：FT_Set_Char_Sizes 或 FT_Set_Pixel_Sizes</span><br><span class="line"></span><br><span class="line">④ 选择charmap：FT_Select_Charmap</span><br><span class="line"></span><br><span class="line">⑤ 根据编码值charcode找到glyph_index：glyph_index = FT_Get_Char_Index（face，charcode）</span><br><span class="line"></span><br><span class="line">⑥ 根据glyph_index取出glyph：FT_Load_Glyph（face，glyph_index）</span><br><span class="line"></span><br><span class="line">⑦ 转为位图：FT_Render_Glyph</span><br><span class="line"></span><br><span class="line">⑧ 移动或旋转:FT_Set_Transform</span><br><span class="line"></span><br><span class="line">⑨ 最后显示出来。</span><br></pre></td></tr></table></figure><p>上面的⑤⑥⑦可以使用一个函数代替：FT_Load_Char(face, charcode, FT_LOAD_RENDER)，它就可以得到位图。</p><p>demo:</p><p>如果想在代码中能直接使用UNICODE值，需要使用wchar_t，宽字符, 占四个字节</p><p>注意：如果test_wchar.c是以ANSI(GB2312)格式保存，那么需要使用以下命令来编译：</p><p><code>gcc -finput-charset=GB2312 -fexec-charset=UTF-8 -o test_wchar test_wchar.c</code></p><p><strong>显示一行文字</strong></p><p>笛卡尔坐标系:</p><p>在LCD的坐标系中，原点在屏幕的左上角。对于笛卡尔坐标系，原点在左下角。freetype使用笛卡尔坐标系，在显示时需要转换为LCD坐标系。</p><p>从下图可知，X方向坐标值是一样的。</p><p>在Y方向坐标值需要换算，<code>假设LCD的高度是V</code>。</p><p>在LCD坐标系中坐标是(x, y)，那么它在笛卡尔坐标系中的坐标值为(x, V-y)。</p><p>反过来也是一样的，在笛卡尔坐标系中坐标是(x, y)，那么它在LCD坐标系中坐标值为(x, V-y)。</p><img src="https://pic.imgdb.cn/item/6283d6de0947543129e1b268.png" style="zoom:67%;" /><p><code>具体函数见文档393页.</code></p><h2 id="输入系统"><a class="markdownIt-Anchor" href="#输入系统"></a> 输入系统</h2><p>外设都是输入设备,Linux系统为了统一管理这些输入设备，实现了一套能兼容所有输入设备的框架：输入系统。驱动开发人员基于这套框架开发出程序，应用开发人员就可以使用统一的API去使用设备。</p><h3 id="框架"><a class="markdownIt-Anchor" href="#框架"></a> 框架</h3><p><img src="https://pic.imgdb.cn/item/6283da1a0947543129ec9715.png" alt="" /></p><p>假设用户程序直接访问/dev/input/event0设备节点，或者使用tslib访问设备节点，数据的流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">① APP发起读操作，若无数据则休眠；</span><br><span class="line">② 用户操作设备，硬件上产生中断；</span><br><span class="line">③ 输入系统驱动层对应的驱动程序处理中断：</span><br><span class="line">    读取到数据，转换为标准的输入事件，向核心层汇报。</span><br><span class="line">    所谓输入事件就是一个“struct input_event”结构体。</span><br><span class="line">④ 核心层可以决定把输入事件转发给上面哪个handler来处理：</span><br><span class="line">    从handler的名字来看，它就是用来处输入操作的。有多种handler，比如：evdev_handler(常用)、kbd_handler、joydev_handler等等。</span><br><span class="line">    最常用的是evdev_handler：它只是把input_event结构体保存在内核buffer等，APP来读取时就原原本本地返回。它支持多个APP同时访问输入设备，每个APP都可以获得同一份输入事件。</span><br><span class="line">    当APP正在等待数据时，evdev_handler会把它唤醒，这样APP就可以返回数据。</span><br><span class="line">⑤ APP对输入事件的处理：</span><br><span class="line">    APP获得数据的方法有2种：直接访问设备节点(比如/dev/input/event0,1,2,...)，或者通过tslib、libinput这类库来间接访问设备节点。这些库简化了对数据的处理。</span><br></pre></td></tr></table></figure><p><strong>内核中怎么表示一个输入设备？</strong>  使用input_dev结构体来表示输入设备，它的内容如下：</p><p><img src="https://pic.imgdb.cn/item/6283ed3b094754312925c1e9.jpg" alt="" /></p><p>驱动程序上报的数据含义三项重要内容</p><ul><li><p><code>type</code> 表示数据是哪一类型的, 比如EV_KEY(表示按键类)  <strong>当type=0表示是同步事件</strong> 表示硬件已经上报了所有数据</p></li><li><p><code>code</code> 按键类事件里面是哪一个按键? 硬件上报的是哪个按键</p></li><li><p><code>value</code> 值, 比如0(松开) 1(按下) 2(长按)</p></li><li><p>事件之间的界线</p><p>APP读取数据时，可以得到一个或多个数据，比如一个触摸屏的一个触点会上报X、Y位置信息，也可能会上报压力值。</p><p>APP怎么知道它已经读到了完整的数据？</p><p>驱动程序上报完一系列的数据后，会上报一个“同步事件”，表示数据上报完毕。APP读到“同步事件”时，就知道已经读完了当前的数据。</p></li></ul><p>得到一系列的输入事件，就是一个一个“struct input_event”，它定义如下：</p><p><img src="https://pic.imgdb.cn/item/6283e6b3094754312914944d.jpg" alt="" /></p><p>每个输入事件input_event中都含有发生时间：timeval表示的是“自系统启动以来过了多少时间”，它是一个结构体，含有“tv_sec、tv_usec”两项(即秒、微秒)。</p><h4 id="调试技巧"><a class="markdownIt-Anchor" href="#调试技巧"></a> 调试技巧</h4><p>入设备的设备节点名为/dev/input/eventX(也可能是/dev/eventX，X表示0、1、2等数字)。查看设备节点，可以执行以下命令： <code>ls /dev/input/* -l</code> 或 <code>ls /dev/event* -l</code></p><p>怎么知道这些设备节点对应什么硬件呢？可以在板子上执行以下命令： <code>cat /proc/bus/input/devices</code></p><p>这条指令的含义就是获取与event对应的相关设备信息，可以看到类似以下的结果：</p><p><img src="https://pic.imgdb.cn/item/6283ebfd0947543129229387.jpg" alt="" /></p><p>这里的I、N、P、S、U、H、B对应的每一行是什么含义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">I:id of the device(设备ID) 该参数由结构体struct input_id来进行描述</span><br><span class="line">N:name of the device 设备名称</span><br><span class="line">P:physical path to the device in the system hierarchy 系统层次结构中设备的物理路径。</span><br><span class="line">S:sysfs path 位于sys文件系统的路径</span><br><span class="line">U:unique identification code for the device(if device has it) 设备的唯一标识码</span><br><span class="line">H:list of input handles associated with the device. 与设备关联的输入句柄列表。</span><br><span class="line">B:bitmaps(位图)</span><br><span class="line">    PROP:device properties and quirks(设备属性)</span><br><span class="line">    EV:types of events supported by the device(设备支持的事件类型)</span><br><span class="line">    KEY:keys/buttons this device has(此设备具有的键/按钮)</span><br><span class="line">    MSC:miscellaneous events supported by the device(设备支持的其他事件)</span><br><span class="line">    LED:leds present on the device(设备上的指示灯)</span><br></pre></td></tr></table></figure><p>比如上图中“B: EV=b”用来表示该设备支持哪类输入事件。b的二进制是1011，bit0、1、3为1，表示该设备支持0、1、3这三类事件，即EV_SYN、EV_KEY、EV_ABS。</p><p>再举一个例子，“B: ABS=2658000 3”如何理解？</p><p>它表示该设备支持EV_ABS这一类事件中的哪一些事件。这是2个32位的数字：0x2658000、0x3，高位在前低位在后，组成一个64位的数字：“0x2658000,00000003”，数值为1的位有：0、1、47、48、50、53、54，即：0、1、0x2f、0x30、0x32、0x35、0x36,对应一些宏.</p><p><strong>命令读取</strong></p><p>调试输入系统时，直接执行类似下面的命令，然后操作对应的输入设备即可读出数据： <code>hexdump /dev/input/event0</code></p><p><img src="https://pic.imgdb.cn/item/628466520947543129b4b595.jpg" alt="" /></p><p>上图中的type为3，对应EV_ABS；code为0x35对应ABS_MT_POSITION_X；code为0x36对应ABS_MT_POSITION_Y。</p><p>上图中还发现有2个同步事件：它的type、code、value都为0。表示电容屏上报了2次完整的数据。</p><h4 id="不用库开发应用"><a class="markdownIt-Anchor" href="#不用库开发应用"></a> 不用库开发应用</h4><p>输入系统支持完整的API操作 :  支持这些机制：阻塞、非阻塞、POLL/SELECT、异步通知。</p><p><strong>APP访问硬件的几种方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">① 时不时进房间看一下：查询方式</span><br><span class="line">简单，但是累</span><br><span class="line">② 进去房间陪小孩一起睡觉，小孩醒了会吵醒她：休眠-唤醒</span><br><span class="line">不累，但是妈妈干不了活了</span><br><span class="line">③ 妈妈要干很多活，但是可以陪小孩睡一会，定个闹钟：poll方式</span><br><span class="line">要浪费点时间，但是可以继续干活。</span><br><span class="line">妈妈要么是被小孩吵醒，要么是被闹钟吵醒。</span><br><span class="line">④ 妈妈在客厅干活，小孩醒了他会自己走出房门告诉妈妈：异步通知</span><br><span class="line">妈妈、小孩互不耽误。</span><br></pre></td></tr></table></figure><p>通过ioctl获取设备信息，ioctl的参数如下： <code>int ioctl(int fd, unsigned long request, ...);</code></p><h5 id="查询方式"><a class="markdownIt-Anchor" href="#查询方式"></a> 查询方式</h5><p>APP调用open函数时，传入“O_NONBLOCK”表示“非阻塞”。</p><p>APP调用read函数读取数据时，如果驱动程序中有数据，那么APP的read函数会返回数据，否则也会立刻返回错误。</p><h5 id="休眠-唤醒方式"><a class="markdownIt-Anchor" href="#休眠-唤醒方式"></a> 休眠-唤醒方式</h5><p>APP调用open函数时，不要传入“O_NONBLOCK”。</p><p>APP调用read函数读取数据时，如果驱动程序中有数据，那么APP的read函数会返回数据；否则APP就会在内核态休眠，当有数据时驱动程序会把APP唤醒，read函数恢复执行并返回数据给APP。</p><h5 id="pollselect方式"><a class="markdownIt-Anchor" href="#pollselect方式"></a> POLL/SELECT方式</h5><p>POLL机制、SELECT<code>机制</code>是完全一样的，只是APP接口函数不一样。在调用poll、select函数时可以传入“超时时间”。在这段时间内，条件合适时(比如有数据可读、有空间可写)就会立刻返回，否则等到“超时时间”结束时返回错误。</p><p>APP先调用open函数时。APP不是直接调用read函数，而是先调用poll或select函数，这2个函数中可以传入“超时时间”。它们的作用是：如果驱动程序中有数据，则立刻返回；否则就休眠。在休眠期间，如果有人操作了硬件，驱动程序获得数据后就会把APP唤醒，导致poll或select立刻返回；如果在“超时时间”内无人操作硬件，则时间到后poll或select函数也会返回。</p><p>poll/select函数可以监测多个文件，可以监测多种事件：</p><table><thead><tr><th>事件类型</th><th>说明</th></tr></thead><tbody><tr><td>POLLIN</td><td>有数据可读</td></tr><tr><td>POLLRDNORM</td><td>等同于POLLIN</td></tr><tr><td>POLLRDBAND</td><td>Priority band data can be read，有优先级较较高的“band  data”可读  Linux系统中很少使用这个事件</td></tr><tr><td>POLLPRI</td><td>高优先级数据可读</td></tr><tr><td>POLLOUT</td><td>可以写数据</td></tr><tr><td>POLLWRNORM</td><td>等同于POLLOUT</td></tr><tr><td>POLLWRBAND</td><td>Priority data may be written</td></tr><tr><td>POLLERR</td><td>发生了错误</td></tr><tr><td>POLLHUP</td><td>挂起</td></tr><tr><td>POLLNVAL</td><td>无效的请求，一般是fd未open</td></tr></tbody></table><p>在调用poll函数时，要指明：</p><p>① 你要监测哪一个文件：哪一个fd</p><p>② 你想监测这个文件的哪种事件：是POLLIN、还是POLLOUT</p><p>最后，在poll函数返回时，要判断状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码补充</span><br></pre></td></tr></table></figure><h4 id="异步通知方式"><a class="markdownIt-Anchor" href="#异步通知方式"></a> 异步通知方式</h4><p>所谓异步通知，就是APP可以忙自己的事，当驱动程序用数据时它会主动给APP发信号，这会导致APP执行信号处理函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">① 谁发：驱动程序发</span><br><span class="line">② 发什么：信号</span><br><span class="line">③ 发什么信号：SIGIO</span><br><span class="line">④ 怎么发：内核里提供有函数</span><br><span class="line">⑤ 发给谁：APP，APP要把自己告诉驱动</span><br><span class="line">⑥ APP收到后做什么：执行信号处理函数</span><br><span class="line">⑦ 信号处理函数和信号，之间怎么挂钩：APP注册信号处理函数</span><br></pre></td></tr></table></figure><p>除了注册SIGIO的处理函数，APP还要做什么事？想想这几个问题：</p><p>① 内核里有那么多驱动，你想让哪一个驱动给你发SIGIO信号？</p><p>APP要打开驱动程序的设备节点。</p><p>② 驱动程序怎么知道要发信号给你而不是别人？</p><p>APP要把自己的进程ID告诉驱动程序。</p><p>③ APP有时候想收到信号，有时候又不想收到信号：</p><p>应该可以把APP的意愿告诉驱动：设置Flag里面的FASYNC位为1，使能“异步通知”。</p><h3 id="tslib"><a class="markdownIt-Anchor" href="#tslib"></a> tslib</h3><p>tslib是一个触摸屏的开源库，可以使用它来访问触摸屏设备，可以给输入设备添加各种“filter”(过滤器，就是各种处理)，地址是：<a href="http://www.tslib.org/%E3%80%82">http://www.tslib.org/。</a></p><p>编译tslib后，可以得到libts库，还可以得到各种工具：较准工具、测试工具。</p><p>具体待补充.</p><h2 id="网络通信"><a class="markdownIt-Anchor" href="#网络通信"></a> 网络通信</h2><p>数据传输，都有三个要素 ：源、目的、长度。</p><p>待补充</p><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2><p>待补充</p><h2 id="串口"><a class="markdownIt-Anchor" href="#串口"></a> 串口</h2><p>UART：通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，简称串口</p><p><strong>参数</strong></p><ul><li><p>波特率：一般选波特率都会有9600,19200,115200等选项。其实意思就是每秒传输这么多个比特位数(bit)。</p></li><li><p>起始位:先发出一个逻辑”0”的信号，表示传输数据的开始。</p></li><li><p>数据位：可以是5~8位逻辑”0”或”1”。如ASCII码（7位），扩展BCD码（8位）。小端传输。</p></li><li><p>校验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。</p></li><li><p>停止位：它是一个字符数据的结束标志。</p></li></ul><p><strong>如何发送数据</strong></p><img src="https://pic.imgdb.cn/item/6285e5cb09475431296c6968.jpg" style="zoom: 90%;" /><p>要发送数据时，CPU控制(UART单元)内存要发送的数据通过FIFO传给UART里面的移位器(诸位发送)，依次将数据发送出去，在发送完成后产生中断提醒CPU传输完成。</p><p>接收数据时，获取接收引脚的电平，逐位放进接收移位器，再放入FIFO，程序再从FIFO中把数据取出来写入内存。在接收完成后产生中断提醒CPU传输完成。</p><h3 id="tty体系中设备节点的差别"><a class="markdownIt-Anchor" href="#tty体系中设备节点的差别"></a> TTY体系中设备节点的差别</h3><table><thead><tr><th>设备节点</th><th>含义</th></tr></thead><tbody><tr><td>/dev/ttyS0、/dev/ttySAC0</td><td>串口</td></tr><tr><td>/dev/tty1、/dev/tty2、/dev/tty3、……</td><td>虚拟终端设备节点</td></tr><tr><td>/dev/tty0</td><td>前台终端</td></tr><tr><td>/dev/tty</td><td>程序自己的终端，可能是串口、也可能是虚拟终端</td></tr><tr><td>/dev/console</td><td>控制台，又内核的cmdline参数确定</td></tr></tbody></table><p>TTY /Terminal /Console /UART</p><p>下图中两条红线之内的代码被称为TTY子系统。它既支持UART，也支持键盘、显示器，还支持更复杂的功能(比如伪终端)</p><p>ctrl + alt +f4(x) 切换</p><img src="https://pic.imgdb.cn/item/6285ebf40947543129701b04.jpg"  /><p>关于 /dev/ttyN   通过内核的cmdline来指定，比如: <code>console=ttyS0 console=tty</code></p><p>更多:</p><h3 id="tty驱动框架"><a class="markdownIt-Anchor" href="#tty驱动框架"></a> TTY驱动框架</h3><img src="https://pic.imgdb.cn/item/62863cf80947543129b0773e.jpg" style="zoom: 60%;" /><p>TTY这一层帮你屏蔽了不同输入输出设备的差别,串口 键盘等的驱动程序肯定会向上注册某个结构体, 再TTY这层使用同一个接口访问不同的设备</p><p>虚拟终端: 对于同一套键盘和显示器, 它可以对应不同的个虚拟终端, 对于虚拟终端又抽象出了一层 virtual terminal(串口没有这个) , 有很多个虚拟终端, 驱动程序得到键盘信息时会发送给前排的虚拟终端, 应用程序要显示的数据也会存入某一个buffer, 要显示时再从buffer中取出来,</p><h4 id="行规程"><a class="markdownIt-Anchor" href="#行规程"></a> 行规程</h4><img src="https://pic.imgdb.cn/item/628637070947543129ad4ff5.jpg" style="zoom: 50%;" /><p>也叫做回显 echo, 比较有意思 : 说的是在键盘上输入一个字符所发生的事情.</p><p>删除的话,删除命令(就是字节对应的编码) 发送到后,驱动上报行规成, 它把buf中的lsa删除掉a,然后将删除命令再发送回去, 所谓删除a只是显示效果, 串口工具还是接收到了4个字节的数据: l s a 退格键</p><p>回车键: 一样的,…, 将buf中的数据上传给APP(shell), 把结果再发给行规成,再发给串口驱动,然后PC显示.</p><h3 id="linux串口应用编程"><a class="markdownIt-Anchor" href="#linux串口应用编程"></a> Linux串口应用编程</h3><h4 id="串口怎么插"><a class="markdownIt-Anchor" href="#串口怎么插"></a> 串口怎么插</h4><img src="https://pic.imgdb.cn/item/628681f80947543129d1fddb.jpg" style="zoom: 80%;" /><img src="https://pic.imgdb.cn/item/62868c990947543129d578d7.jpg" style="zoom: 25%;" /><p>这个位置是串口,靠</p><h4 id="串口api"><a class="markdownIt-Anchor" href="#串口api"></a> 串口API</h4><p>在Linux系统中，操作设备的统一接口就是：open/ioctl/read/write。对于UART，又在ioctl之上封装了很多函数，主要是用来设置行规程。</p><p>所以对于UART，编程的套路就是：</p><p><code>open -&gt; 设置行规程，比如波特率、数据位、停止位、检验位、RAW模式、一有数据就返回 -&gt; read/write</code></p><p>怎么设置行规程？行规程的参数用结构体termios来表示,把这个结构体构造好之后再发给驱动程序.</p><img src="https://pic.imgdb.cn/item/628676540947543129cdaea1.jpg" style="zoom:50%;" /><p>这些函数在名称上有一些惯例：</p><p>`` tc：terminal contorl<code>   </code>cf: control flflag`</p><table><thead><tr><th><strong>函数名</strong></th><th>作用</th></tr></thead><tbody><tr><td>tcgetattr</td><td>get terminal attributes，获得终端的属性(获得驱动程序参数)</td></tr><tr><td>tcsetattr</td><td>set terminal attributes，修改终端参数</td></tr><tr><td>tcflflush</td><td>清空终端未完成的输入/输出请求及数据</td></tr><tr><td>cfsetispeed</td><td>sets the input baud rate，设置输入波特率</td></tr><tr><td>cfsetospeed</td><td>sets the output baud rate，设置输出波特率</td></tr><tr><td>cfsetspeed</td><td>同时设置输入、输出波特率</td></tr></tbody></table><p>需要设置好termios中的参数.</p><h4 id="实例回环"><a class="markdownIt-Anchor" href="#实例回环"></a> 实例(回环)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set_opt(fd,115200,8,&#x27;N&#x27;,1) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_opt</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> nSpeed, <span class="type">int</span> nBits, <span class="type">char</span> nEvent, <span class="type">int</span> nStop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">newtio</span>,<span class="title">oldtio</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( tcgetattr( fd,&amp;oldtio) != <span class="number">0</span>) &#123; <span class="comment">//获得驱动程序中默认的参数</span></span><br><span class="line">        perror(<span class="string">&quot;SetupSerial 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清除 使用原始模式</span></span><br><span class="line">    bzero( &amp;newtio, <span class="keyword">sizeof</span>( newtio ) );</span><br><span class="line">    newtio.c_cflag |= CLOCAL | CREAD; </span><br><span class="line">    newtio.c_cflag &amp;= ~CSIZE; </span><br><span class="line"></span><br><span class="line">    newtio.c_lflag  &amp;= ~(ICANON | ECHO | ECHOE | ISIG);  <span class="comment">/*Input*/</span></span><br><span class="line">    newtio.c_oflag  &amp;= ~OPOST;   <span class="comment">/*Output*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( nBits )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        newtio.c_cflag |= CS7;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        newtio.c_cflag |= CS8;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( nEvent )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">        newtio.c_cflag |= PARENB;</span><br><span class="line">        newtio.c_cflag |= PARODD;</span><br><span class="line">        newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: </span><br><span class="line">        newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">        newtio.c_cflag |= PARENB;</span><br><span class="line">        newtio.c_cflag &amp;= ~PARODD;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: </span><br><span class="line">        newtio.c_cflag &amp;= ~PARENB;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( nSpeed )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2400</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B2400);</span><br><span class="line">        cfsetospeed(&amp;newtio, B2400);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4800</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B4800);</span><br><span class="line">        cfsetospeed(&amp;newtio, B4800);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9600</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">        cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">115200</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B115200);</span><br><span class="line">        cfsetospeed(&amp;newtio, B115200);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">        cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( nStop == <span class="number">1</span> )</span><br><span class="line">        newtio.c_cflag &amp;= ~CSTOPB;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( nStop == <span class="number">2</span> )</span><br><span class="line">        newtio.c_cflag |= CSTOPB;</span><br><span class="line">    </span><br><span class="line">    newtio.c_cc[VMIN]  = <span class="number">1</span>;  <span class="comment">/* 读数据时的最小字节数: 没读到这些数据我就不返回! */</span></span><br><span class="line">    newtio.c_cc[VTIME] = <span class="number">0</span>; <span class="comment">/* 等待第1个数据的时间: </span></span><br><span class="line"><span class="comment">                             * 比如VMIN设为10表示至少读到10个数据才返回,</span></span><br><span class="line"><span class="comment">                             * 但是没有数据总不能一直等吧? 可以设置VTIME(单位是10秒)</span></span><br><span class="line"><span class="comment">                             * 假设VTIME=1，表示: </span></span><br><span class="line"><span class="comment">                             *    10秒内一个数据都没有的话就返回</span></span><br><span class="line"><span class="comment">                             *    如果10秒内至少读到了1个字节，那就继续等待，完全读到VMIN个数据再返回</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line"></span><br><span class="line">    tcflush(fd,TCIFLUSH);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((tcsetattr(fd,TCSANOW,&amp;newtio))!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;com set error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;set done!\n&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_port</span><span class="params">(<span class="type">char</span> *com)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">//fd = open(com, O_RDWR|O_NOCTTY|O_NDELAY);</span></span><br><span class="line">    fd = open(com, O_RDWR|O_NOCTTY);<span class="comment">//打开某个设备节点  O_NOCTTY:程序打开串口之后不要把这个串口用作控制终端(serial连接就是控制终端,输入字符转换成某些信号去控制)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fcntl(fd,F_SETEL, FNDELAY); 读数据时不等待, 没有数据就返回0</span></span><br><span class="line">      <span class="keyword">if</span>(fcntl(fd, F_SETFL, <span class="number">0</span>)&lt;<span class="number">0</span>) <span class="comment">/* 设置串口为阻塞状态*/</span> <span class="comment">//读写数据不成功就会休眠</span></span><br><span class="line">      &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fcntl failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./serial_send_recv &lt;dev&gt;(设备节点)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> iRet;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. open */</span><span class="comment">//打开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. setup </span></span><br><span class="line"><span class="comment">     * 115200,8N1</span></span><br><span class="line"><span class="comment">     * RAW mode</span></span><br><span class="line"><span class="comment">     * return data immediately</span></span><br><span class="line"><span class="comment">     */</span><span class="comment">//设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. write and read */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &lt;/dev/ttySAC1 or other&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open_port(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open %s err!\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iRet = set_opt(fd, <span class="number">115200</span>, <span class="number">8</span>, <span class="string">&#x27;N&#x27;</span>, <span class="number">1</span>);<span class="comment">//设置参数波特率11520 数据位8 不用校验位 停止位1</span></span><br><span class="line">    <span class="keyword">if</span> (iRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;set port err!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a char: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">        iRet = write(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">        iRet = read(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (iRet == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get: %02x %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;can not get data\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读数据时的最小字节数设置为0: 为什么第一遍打印俩遍错误呢?</strong></p><p>输入a, 将a保存在行规程, 回车键继续发送至行规程, 才会去唤醒应用程序, scanf被唤醒得到了a, 把a发给另一个串口, 串口1开始接收(一位一位), 所以write发送了,但是read没有接受, 返回0, 第二个字符时enter, 又没有读到数据,  输入字符b, read读到a(行规程里第一个数据)</p><p>主要问题是write确实可以发送出去, 但是串口没有得到数据呢(没有上报给驱动程序), read返回0, 所以要设置读到最小字节为1, 没有数据的话永远等待(等待时间设置)</p><h2 id="i2c"><a class="markdownIt-Anchor" href="#i2c"></a> I2C</h2><h3 id="i2c框架"><a class="markdownIt-Anchor" href="#i2c框架"></a> I2C框架</h3><img src="https://pic.imgdb.cn/item/62892229094754312979a1b0.jpg" style="zoom: 80%;" /><p>一个芯片里面有一个或者多个I2C控制器, 一个I2C控制器上面可以挂载一个或者多个I2C设备, 访问这些设备需要去寻址, 所以使用I2C总线来操作设备时, 首先得知道设备的设备地址, 知道后就可以跟他收发数据了.</p><p>I2C总线只需要2条线：时钟线SCL、数据线SDA.  在I2C总线的SCL、SDA线上，都有上拉电阻</p><img src="https://pic.imgdb.cn/item/6289231a09475431297a306e.jpg" style="zoom: 50%;" /><p>APP(open/read/write)  设备驱动程序(例如EEPROM存储设备  TS触摸屏设备)  控制驱动程序</p><h3 id="协议"><a class="markdownIt-Anchor" href="#协议"></a> 协议</h3><p>控芯片引出两条线SCL(SCK),SDA线，在一条I2C总线上可以接很多I2C设备，我们还会放一个上拉电阻</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简单的例子，来解释一下IIC的传输协议：</span><br><span class="line">    老师说开始了，表示开始信号(start)</span><br><span class="line">    老师提醒某个学生要发球，表示发送地址和方向(address/read/write)</span><br><span class="line">    老师发球/接球，表示数据的传输</span><br><span class="line">    收到球要回应：回应信号(ACK)</span><br><span class="line">    老师说结束，表示IIC传输结束(P)</span><br></pre></td></tr></table></figure><h4 id="写操作"><a class="markdownIt-Anchor" href="#写操作"></a> 写操作</h4><p>主芯片要发出一个start信号</p><p>然后发出一个设备地址(用来确定是往哪一个芯片写数据)，方向(读/写，0表示写，1表示读)</p><p>从设备回应(用来确定这个设备是否存在)，然后就可以传输数据</p><p>主设备发送一个字节数据给从设备，并等待回应</p><p>每传输一字节数据，接收方要有一个回应信号（确定数据是否接受完成)，然后再传输下一个数据。</p><p>数据发送完之后，主芯片就会发送一个停止信号。</p><p>下图：白色背景表示&quot;主→从&quot;，灰色背景表示&quot;从→主&quot;</p><img src="https://pic.imgdb.cn/item/6289251a09475431297b5a97.jpg" style="zoom: 67%;" /><h4 id="读操作"><a class="markdownIt-Anchor" href="#读操作"></a> 读操作</h4><p>主芯片要发出一个start信号</p><p>然后发出一个设备地址(用来确定是往哪一个芯片写数据)，方向(读/写，0表示写，1表示读)</p><p>从设备回应(用来确定这个设备是否存在)，然后就可以传输数据</p><p>从设备发送一个字节数据给主设备，并等待回应</p><p>每传输一字节数据，接收方要有一个回应信号（确定数据是否接受完成)，然后再传输下一个数据。</p><p>数据发送完之后，主芯片就会发送一个停止信号。</p><p>下图：白色背景表示&quot;主→从&quot;，灰色背景表示&quot;从→主&quot;</p><img src="https://pic.imgdb.cn/item/628925a609475431297baade.jpg" style="zoom:73%;" /><h4 id="信号"><a class="markdownIt-Anchor" href="#信号"></a> 信号</h4><p>I2C协议中数据传输的单位是字节，也就是8位。但是要用到9个时钟：前面8个时钟用来传输8数据，第9个时钟用来传输回应信号。传输时，先传输最高位(MSB)。</p><p>开始信号（S）：SCL为高电平时，SDA山高电平向低电平跳变，开始传送数据。</p><p>结束信号（P）：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。</p><p>响应信号(ACK)：接收器在接收到8位数据后，在第9个时钟周期，拉低SDA</p><p><strong>SDA上传输的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化</strong></p><img src="https://pic.imgdb.cn/item/6289261409475431297be5f7.jpg" style="zoom:110%;" /><h4 id="细节"><a class="markdownIt-Anchor" href="#细节"></a> 细节</h4><p>如何在SDA上实现双向传输？<br />主芯片通过一根SDA线既可以把数据发给从设备，也可以从SDA上读取数据，连接SDA线的引脚里面必然有两个引脚（发送引   脚/接受引脚）。</p><p>主、从设备都可以通过SDA发送数据，肯定不能同时发送数据，怎么错开时间？<br />在9个时钟里，<br />前8个时钟由主设备发送数据的话，第9个时钟就由从设备发送数据；<br />前8个时钟由从设备发送数据的话，第9个时钟就由主设备发送数据。</p><p>双方设备中，某个设备发送数据时，另一方怎样才能不影响SDA上的数据？<br />设备的SDA中有一个三极管，使用开极/开漏电路(三极管是开极，CMOS管是开漏，作用一样)，如下图：</p><img src="https://pic.imgdb.cn/item/6289ef530947543129f9709c.jpg" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当某一个芯片不想影响SDA线时，那就不驱动这个三极管</span><br><span class="line">想让SDA输出高电平，双方都不驱动三极管(SDA通过上拉电阻变为高电平)</span><br><span class="line">想让SDA输出低电平，就驱动三极管</span><br></pre></td></tr></table></figure><p><strong>举例</strong>(双向传输)     主设备发送（8bit）给从设备</p><ul><li><p>前8个clk</p><p>从设备不要影响SDA，从设备不驱动三极管</p><p>主设备决定数据，主设备要发送1时不驱动三极管，要发送0时驱动三极管</p></li><li><p>第9个clk，由从设备决定数据</p><p>主设备不驱动三极管</p><p>从设备决定数据，要发出回应信号的话，就驱动三极管让SDA变为0</p><p>从这里也可以知道ACK信号是低电平</p></li></ul><p><code>从上面的例子，就可以知道怎样在一条线上实现双向传输，这就是SDA上要使用上拉电阻的原因。</code></p><p>为何SCL也要使用上拉电阻？<br />在第9个时钟之后，如果有某一方需要更多的时间来处理数据，它可以一直驱动三极管把SCL拉低。<br />当SCL为低电平时候，大家都不应该使用IIC总线，只有当SCL从低电平变为高电平的时候，IIC总线才能被使用。<br />当它就绪后，就可以不再驱动三极管，这是上拉电阻把SCL变为高电平，其他设备就可以继续使用I2C总线了。</p><p>对于IIC协议它只能规定怎么传输数据，数据是什么含义由从设备决定。</p><h3 id="smbus协议"><a class="markdownIt-Anchor" href="#smbus协议"></a> SMBus协议</h3><p>SMBus: System Management Bus，系统管理总线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SMBus最初的目的是为智能电池、充电电池、其他微控制器之间的通信链路而定义的。</span><br><span class="line">SMBus也被用来连接各种设备，包括电源相关设备，系统传感器，EEPROM通讯设备等等。</span><br><span class="line">SMBus 为系统和电源管理这样的任务提供了一条控制总线，使用 SMBus 的系统，设备之间发送和接收消息都是通过 SMBus，而不是使用单独的控制线，这样可以节省设备的管脚数。</span><br><span class="line">SMBus是基于I2C协议的，SMBus要求更严格，SMBus是I2C协议的子集。</span><br></pre></td></tr></table></figure><p>跟一般的I2C协议的差别</p><p>VDD的极限值不一样<br />I2C协议：范围很广，甚至讨论了高达12V的情况<br />SMBus：1.8V~5V<br />最小时钟频率、最大的Clock Stretching<br />Clock Stretching含义：某个设备需要更多时间进行内部的处理时，它可以把SCL拉低占住I2C总线<br />I2C协议：时钟频率最小值无限制，Clock Stretching时长也没有限制<br />SMBus：时钟频率最小值是10KHz，Clock Stretching的最大时间值也有限制<br />地址回应(Address Acknowledge)<br />一个I2C设备接收到它的设备地址后，是否必须发出回应信号？<br />I2C协议：没有强制要求必须发出回应信号<br />SMBus：强制要求必须发出回应信号，这样对方才知道该设备的状态：busy，failed，或是被移除了</p><p>REPEATED START Condition(重复发出S信号)<br />比如读EEPROM时，涉及2个操作：<br />把存储地址发给设备  and   读数据<br />在写、读之间，可以不发出P信号，而是直接发出S信号：这个S信号就是REPEATED START<br /><img src="https://pic.imgdb.cn/item/6289f3850947543129fc638d.jpg" style="zoom: 80%;" /></p><p>SMBus协议明确了数据的传输格式<br />I2C协议：它只定义了怎么传输数据，但是并没有定义数据的格式，这完全由设备来定义<br />SMBus：定义了几种数据格式(下面分析)</p><p>I2C Block Write 和 I2C SMBus Block Write 的区别L: 传输过程会不会传输Byte Count值</p><h3 id="i2c系统重要结构体"><a class="markdownIt-Anchor" href="#i2c系统重要结构体"></a> I2C系统重要结构体</h3><p>使用一句话概括I2C传输：APP通过I2C Controller与I2C Device传输数据。</p><p>在Linux中：</p><ul><li><p>怎么表示I2C Controller</p><ul><li><p>一个芯片里可能有多个I2C Controller，比如第0个、第1个、……</p></li><li><p>对于使用者，只要确定是第几个I2C Controller即可</p></li><li><p>使用i2c_adapter表示一个I2C BUS，或称为I2C Controller(使用面向对象的方式)</p></li><li><p>里面有2个重要的成员：</p><ul><li>nr：第几个I2C BUS(I2C Controller)</li><li>i2c_algorithm，里面有该I2C BUS的传输函数，用来收发I2C数据</li></ul></li><li><p>i2c_adapter</p><img src="https://pic.imgdb.cn/item/6289fbe1094754312901f9f4.jpg" style="zoom:80%;" /></li><li><p>i2c_algorithm</p></li></ul></li></ul><img src="https://pic.imgdb.cn/item/6289fd22094754312902b564.jpg" style="zoom:80%;" /><ul><li><p>怎么表示I2C Device</p><ul><li><p>一个I2C Device，一定有<strong>设备地址</strong></p></li><li><p>它连接在哪个I2C Controller上，即对应的i2c_adapter是什么</p></li><li><p>使用i2c_client来表示一个I2C Device</p></li></ul><img src="https://pic.imgdb.cn/item/6289fd34094754312902c30f.jpg" style="zoom:80%;" /></li><li><p>怎么表示要传输的数据</p><ul><li><p>在上面的i2c_algorithm结构体中可以看到要传输的数据被称为：i2c_msg</p></li><li><p>i2c_msg</p><img src="https://pic.imgdb.cn/item/6289fd4d094754312902d1e2.jpg" style="zoom:90%;" /></li><li><p>i2c_msg中的flags用来表示传输方向：bit 0等于I2C_M_RD表示读，bit 0等于0表示写</p></li><li><p>一个i2c_msg要么是读，要么是写</p></li><li><p>举例：设备地址为0x50的EEPROM，要读取它里面存储地址为0x10的一个字节，应该构造几个i2c_msg？</p><ul><li><p>要构造2个i2c_msg</p></li><li><p>第一个i2c_msg表示写操作，把要访问的存储地址0x10发给设备</p></li><li><p>第二个i2c_msg表示读操作</p></li><li><p>代码如下</p></li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">u8 data_addr = <span class="number">0x10</span>; </span><br><span class="line">i8 data; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[2];</span> </span><br><span class="line"></span><br><span class="line">msgs[<span class="number">0</span>].addr = <span class="number">0x50</span>; </span><br><span class="line">msgs[<span class="number">0</span>].flags = <span class="number">0</span>; </span><br><span class="line">msgs[<span class="number">0</span>].len = <span class="number">1</span>; </span><br><span class="line">msgs[<span class="number">0</span>].buf = &amp;data_addr; </span><br><span class="line"></span><br><span class="line">msgs[<span class="number">1</span>].addr = <span class="number">0x50</span>; </span><br><span class="line">msgs[<span class="number">1</span>].flags = I2C_M_RD; </span><br><span class="line">msgs[<span class="number">1</span>].len = <span class="number">1</span>; </span><br><span class="line">msgs[<span class="number">1</span>].buf = &amp;data;</span><br></pre></td></tr></table></figure><p><strong>内核怎么传输数据</strong> 使用一句话概括I2C传输：</p><ul><li><p>APP通过I2C Controller与I2C Device传输数据</p></li><li><p>APP通过i2c_adapter与i2c_client传输i2c_msg</p></li><li><p>内核函数i2c_transfer</p><ul><li><p>i2c_msg里含有addr，所以这个函数里不需要i2c_client</p><p><code>int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</code></p></li></ul></li></ul><h3 id="无需编写驱动直接访问设备_i2c-tools介绍"><a class="markdownIt-Anchor" href="#无需编写驱动直接访问设备_i2c-tools介绍"></a> 无需编写驱动直接访问设备_I2C-Tools介绍</h3><p>APP访问硬件肯定是需要驱动程序的，对于I2C设备，内核提供了驱动程序 drivers/i2c/i2c-dev.c ，通过它可以直接使用下面的I2C控制器 驱动程序来访问I2C设备</p><img src="https://pic.imgdb.cn/item/628a08bb09475431290a532b.jpg" style="zoom: 67%;" /><p>使用一句话概括I2C传输：APP通过I2C Controller与I2C Device传输数据。</p><p>所以使用I2C-Tools时也需要指定：</p><ul><li><p>哪个I2C控制器(或称为I2C BUS、I2C Adapter)</p></li><li><p>哪个I2C设备(设备地址)</p></li><li><p>数据：读还是写、数据本身</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">AP3216C是红外、光强、距离三合一的传感器，以读出光强、距离值为例，步骤如下：</span><br><span class="line">复位：往寄存器0写入0x4</span><br><span class="line">使能：往寄存器0写入0x3</span><br><span class="line">读光强：读寄存器0xC、0xD得到2字节的光强</span><br><span class="line">读距离：读寄存器0xE、0xF得到2字节的距离值</span><br><span class="line">AP3216C的设备地址是0x1E，假设节在I2C BUS0上，操作命令如下：</span><br><span class="line">i2cdetect </span><br><span class="line">查看当前i2c设备</span><br><span class="line">用法: i2cdetect 0 或者 i2cdetect -l</span><br><span class="line">使用SMBus协议</span><br><span class="line">i2cset -f -y 0 0x1e 0 0x4 </span><br><span class="line">i2cset -f -y 0 0x1e 0 0x3 </span><br><span class="line">i2cget -f -y 0 0x1e 0xc w </span><br><span class="line">i2cget -f -y 0 0x1e 0xe w </span><br><span class="line">使用I2C协议</span><br><span class="line">i2ctransfer -f -y 0 w2@0x1e 0 0x4 </span><br><span class="line">i2ctransfer -f -y 0 w2@0x1e 0 0x3 </span><br><span class="line">i2ctransfer -f -y 0 w1@0x1e 0xc r2 </span><br><span class="line">i2ctransfer -f -y 0 w1@0x1e 0xe r2</span><br></pre></td></tr></table></figure><h4 id="访问i2c设备的俩种方式"><a class="markdownIt-Anchor" href="#访问i2c设备的俩种方式"></a> 访问I2C设备的俩种方式</h4><p>I2C-Tools可以通过SMBus来访问I2C设备，也可以使用一般的I2C协议来访问I2C设备。</p><p>使用一句话概括I2C传输：APP通过I2C Controller与I2C Device传输数据。</p><p>在APP里，有这几个问题：</p><ul><li><p>怎么指定I2C控制器？</p><ul><li><p>i2c-dev.c提供为每个I2C控制器(I2C Bus、I2C Adapter)都生成一个设备节点：/dev/i2c-0、/dev/i2c-1等待</p></li><li><p>open某个/dev/i2c-X节点，就是去访问该I2C控制器下的设备</p></li></ul></li><li><p>怎么指定I2C设备？</p><ul><li><p>通过ioctl指定I2C设备的地址</p></li><li><p>ioctl(fifile, I2C_SLAVE, address)</p><ul><li>如果该设备已经有了对应的设备驱动程序，则返回失败</li></ul></li><li><p>ioctl(fifile, I2C_SLAVE_FORCE, address)</p><ul><li><p>如果该设备已经有了对应的设备驱动程序</p></li><li><p>但是还是想通过i2c-dev驱动来访问它</p></li><li><p>则使用这个ioctl来指定I2C设备地址</p></li></ul></li></ul></li><li><p>怎么传输数据？</p><ul><li><p>两种方式</p></li><li><p>一般的I2C方式：ioctl(fifile, I2C_RDWR, &amp;rdwr)</p></li><li><p>SMBus方式：ioctl(fifile, I2C_SMBUS, &amp;args)</p></li></ul></li></ul><h4 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h4><p>i2c方式</p><img src="https://pic.imgdb.cn/item/628a1fec09475431291adf28.jpg" style="zoom: 67%;" /><p>SMBus方式</p><img src="https://pic.imgdb.cn/item/628a201109475431291af879.jpg" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;i2c/smbus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2cbusses.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ./at24c02 &lt;i2c_bus_number&gt; w &quot;100ask.taobao.com&quot;</span></span><br><span class="line"><span class="comment"> * ./at24c02 &lt;i2c_bus_number&gt; r</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dev_addr = <span class="number">0x50</span>;<span class="comment">//设备地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem_addr = <span class="number">0</span>;<span class="comment">//存储空间地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> file;</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">20</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">req</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> &amp;&amp; argc != <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write eeprom: %s &lt;i2c_bus_number&gt; w string\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read  eeprom: %s &lt;i2c_bus_number&gt; r\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = open_i2c_dev(argv[<span class="number">1</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>, filename, <span class="keyword">sizeof</span>(filename), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (file &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open %s\n&quot;</span>, filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (set_slave_addr(file, dev_addr, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t set_slave_addr\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write str: argv[3]</span></span><br><span class="line">        str = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        req.tv_sec  = <span class="number">0</span>;</span><br><span class="line">        req.tv_nsec = <span class="number">20000000</span>; <span class="comment">/* 20ms */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (*str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// mem_addr, *str</span></span><br><span class="line">            <span class="comment">// mem_addr++, str++</span></span><br><span class="line">            ret = i2c_smbus_write_byte_data(file, mem_addr, *str);</span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;i2c_smbus_write_byte_data err\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// wait tWR(10ms)</span></span><br><span class="line">            nanosleep(&amp;req, <span class="literal">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            mem_addr++;</span><br><span class="line">            str++;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = i2c_smbus_write_byte_data(file, mem_addr, <span class="number">0</span>); <span class="comment">// string end char</span></span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i2c_smbus_write_byte_data err\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// read</span></span><br><span class="line">        ret = i2c_smbus_read_i2c_block_data(file, mem_addr, <span class="keyword">sizeof</span>(buf), buf);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i2c_smbus_read_i2c_block_data err\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buf[<span class="number">31</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get data: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式驱动</title>
      <link href="/posts/5c8c37e6/"/>
      <url>/posts/5c8c37e6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> Hello World</h1><h2 id="回顾"><a class="markdownIt-Anchor" href="#回顾"></a> 回顾</h2><p><strong>文件IO</strong></p><p>应用程序去调用glibc所提供的open read write函数,最终会进入到内核里面, 调用到内核里的sysopen sysread函数</p><ul><li><p>访问普通文件: 普通文件访问代码, 经过文件系统操作</p></li><li><p>访问驱动程序: 调用驱动程序对应代码</p><ul><li>驱动程序也提供函数 drv_open drv_read函数, 当应用程序去打开某个设备节点,最终会调用驱动程序提供的函数</li></ul></li></ul><h2 id="如何编写驱动程序"><a class="markdownIt-Anchor" href="#如何编写驱动程序"></a> 如何编写驱动程序?</h2><p>① 确定主设备号，也可以让内核分配(0 是让内核分配)</p><p>② 定义自己的file_operations结构体</p><p>③ 实现对应的drv_open/drv_read/drv_write等函数，填入file_operations结构体</p><p>④ 把file_operations结构体告诉(注册)内核：register_chrdev   [这里可以看成是一个数组, 需要注册进某个位置,需要主设备号和副设备号]</p><p>⑤ 谁来注册驱动程序啊？得有一个入口函数(去注册驱动函数)：安装驱动程序时，就会去调用这个入口函数</p><p>⑥ 有入口函数就应该有出口函数：卸载驱动程序时，出口函数调用unregister_chrdev (从数组里面去掉)</p><p>⑦ 其他完善：提供设备信息，自动创建设备节点：class_create, device_create</p><p>驱动怎么操作硬件？通过ioremap映射寄存器的物理地址得到虚拟地址，读写虚拟地址。</p><p>驱动怎么和APP传输数据？通过copy_to_user、copy_from_user这2个函数。</p><h2 id="内核中的表示"><a class="markdownIt-Anchor" href="#内核中的表示"></a> 内核中的表示</h2><p>应用程序调用open函数打开一个文件时, 得到一个整数返回值, 整数会对应内核中的一个结构体(struct file)</p><p>打开某个设备节点时, 会根据这个设备节点的主设备号, 在内核的数组里面找到file_operations结构体, 这个结构体里面有驱动程序的open read函数等等, 会去调用这个结构体里面的函数</p><img src="https://pic.imgdb.cn/item/628a7cd60947543129a43c46.jpg" style="zoom:150%;" /><p>可以猜测，我们使用open打开文件时，传入的flags、mode等参数会被记录在内核中对应的struct file结构体里(f_flags、f_mode)：</p><p><code>int open(const char *pathname, int flags, mode_t mode);</code></p><p>去读写文件时，文件的当前偏移地址也会保存在struct file结构体的f_pos成员里。</p><h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2><p>参考driver/char中的程序，包含头文件，写框架，传输数据：</p><p>​A. 驱动中实现open, read, write, release，APP调用这些函数时，都打印内核信息</p><p>​B. APP调用write函数时，传入的数据保存在驱动中</p><p>​C. APP调用read函数时，把驱动中保存的数据返回给APP</p><p>可以参考misc.c  是一个比较经典的字符驱动程序</p><p><strong>驱动程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 确定主设备号                                                                 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>; <span class="comment">//让内核给我们分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 实现对应的open/read/write等函数，填入file_operations结构体                   */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    err = copy_to_user(buf, kernel_buf, MIN(<span class="number">1024</span>, size));<span class="comment">//给用户空间的buf</span></span><br><span class="line">    <span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    err = copy_from_user(kernel_buf, buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static 防止污染命名空间</span></span><br><span class="line"><span class="comment">/* 2. 定义自己的file_operations结构体                                              */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open    = hello_drv_open,</span><br><span class="line">    .read    = hello_drv_read,</span><br><span class="line">    .write   = hello_drv_write,</span><br><span class="line">    .release = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 把file_operations结构体告诉内核：注册驱动程序                                */</span></span><br><span class="line"><span class="comment">/* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    </span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);  <span class="comment">/* /dev/hello */</span> <span class="comment">//返回主设备号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">    err = PTR_ERR(hello_class);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(hello_class)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">/* /dev/hello */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数           */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    device_destroy(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(hello_class);</span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */</span></span><br><span class="line"></span><br><span class="line">module_init(hello_init);<span class="comment">//修饰成入口函数</span></span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//遵守GPL协议</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">测试程序要实现写、读功能：</span><br><span class="line">A.  ./hello_drv_test  -w  wiki<span class="number">.100</span>ask.net  <span class="comment">// 把字符串“wiki.100ask.net”发给驱动程序</span></span><br><span class="line">B.  ./hello_drv_test  -r                  <span class="comment">// 把驱动中保存的字符串读回来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./hello_drv_test -w abc</span></span><br><span class="line"><span class="comment"> * ./hello_drv_test -r</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 1. 判断参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s -w &lt;string&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       %s -r\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 打开文件 */</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not open file /dev/hello\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 写文件或读文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> == <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-w&quot;</span>)) &amp;&amp; (argc == <span class="number">3</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line">        len = len &lt; <span class="number">1024</span> ? len : <span class="number">1024</span>;</span><br><span class="line">        write(fd, argv[<span class="number">2</span>], len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = read(fd, buf, <span class="number">1024</span>);</span><br><span class="line">        buf[<span class="number">1023</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;APP read : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那么怎么去编译驱动程序和测试程序呢</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用不同的开发板内核时, 一定要修改KERN_DIR</span></span><br><span class="line"><span class="comment"># 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span></span><br><span class="line"><span class="comment"># 2.1 ARCH,          比如: export ARCH=arm64</span></span><br><span class="line"><span class="comment"># 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-</span></span><br><span class="line"><span class="comment"># 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin </span></span><br><span class="line"><span class="comment"># 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,</span></span><br><span class="line"><span class="comment">#       请参考各开发板的高级用户使用手册</span></span><br><span class="line"></span><br><span class="line">KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules  <span class="comment">#进入到内核目录 编译当前目录的xx.o文件 编译成驱动程序</span></span><br><span class="line">    <span class="variable">$(CROSS_COMPILE)</span>gcc -o hello_drv_test hello_drv_test.c   <span class="comment">#b</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">    rm -rf modules.order</span><br><span class="line">    rm -f hello_drv_test</span><br><span class="line"></span><br><span class="line">obj-m    += hello_drv.o</span><br></pre></td></tr></table></figure><p>然后make 注意配置</p><p>将生成ko文件和 可执行文件传到板子</p><p>使用<code>insmod xx.ko</code> 来装载驱动   <code>cat /proc/devices</code> 来查看驱动是否添加   <code>lsmod</code> 查看内核中已经加载的驱动程序</p><p><code>ls /dev/xx -l</code> 查看我们的设备节点 (主设备号等等)  <code>rmmod</code> 卸载驱动</p><p><strong>知识补充</strong></p><p>module_init/module_exit的实现</p><p>register_chrdev的内部实现</p><p>class_destroy/device_create浅析</p><h1 id="gpio"><a class="markdownIt-Anchor" href="#gpio"></a> GPIO</h1><h2 id="gpio引脚操作方法"><a class="markdownIt-Anchor" href="#gpio引脚操作方法"></a> GPIO引脚操作方法</h2><p>GPIO: General-purpose input/output，通用的输入输出口</p><p><strong>GPIO模块一般结构</strong></p><p>​a. 有多组GPIO，每组有多个GPIO</p><p>​b. 使能：电源/时钟</p><p>​c. 模式(Mode)：引脚可用于GPIO或其他功能</p><p>​d. 方向：引脚Mode设置为GPIO时，可以继续设置它是输出引脚，还是输入引脚</p><p>​e. 数值：对于输出引脚，可以设置寄存器让它输出高、低电平 对于输入引脚，可以读取寄存器得到引脚的当前电平</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">举例子:</span><br><span class="line">一个芯片, 有n组GPIO, 每组gpio里面有若干个引脚, 我们以目的为导向,想让一个引脚输出高低电平.</span><br><span class="line">从数据流向反向来看:</span><br><span class="line">②数据来自io_mux(多路选择器), 一个引脚又可能来自gpio模块,也有可能来自uart,所以在这里需要去选择引脚来自    于哪里,这称为引脚的模式选择 pins_mode</span><br><span class="line">①假设这个引脚来自gpio模块,需要使能gpio模块,需要去设置power/clock control Enable</span><br><span class="line">为了省电,这些模块有可能默认下是关闭的,使用的话要设置p/c control来向这些模块提供电源,提供clock</span><br><span class="line">③设置引脚的输入输出功能(方向)</span><br><span class="line">④设置数据让他输出高低电平</span><br><span class="line">这些操作都需要读写寄存器</span><br><span class="line"></span><br><span class="line">配图如下</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/628b47e0094754312971494b.jpg" style="zoom:80%;" /><p><strong>GPIO寄存器操作</strong></p><p>操作寄存器原则: 不要去影响到其他位</p><ul><li><p>举例: 数据寄存器</p><p>想让一个引脚输出高电平,需要把这个寄存器的bit0设置为1</p><p>①读出这个寄存器的值 val = data_reg (读出来)</p><p>②修改这个值,让这个bit0等于1  val = val | 1  (修改)</p><p>③写回去 datareg_reg = val  (写)</p></li><li><p>能不能直接写呢? <code>data_reg = 1</code></p><p>不可以, bit0 = 1了,但是bit1 2 3都被修改了. 影响到了其他位</p></li><li><p>更高效的办法:  (set-and-clear protocal)有些处理器,对于这个寄存器又引出了俩个寄存器, 一个是设置寄存器set_reg,清除寄存器clr_reg(和set_reg同理)设置bit0等于1,可以去把寄存器读出来修改bit0写回去也可以直接操作这个寄存器bit0=1就可以了 set_reg=1或者  0和2 set_reg=(1)|(1&lt;&lt;2), 等于0的寄存器没有任何效果,等于1的位会影响实际的数据寄存器</p></li></ul><p><img src="https://pic.imgdb.cn/item/628b79c20947543129f6adb2.jpg" alt="" /></p><h2 id="imx6ull的gpio操作"><a class="markdownIt-Anchor" href="#imx6ull的gpio操作"></a> IMX6ULL的GPIO操作</h2><p>拿到新的芯片,需要去看芯片手册,找到gpio章节, GPIO的控制涉及4大模块：CCM、IOMUXC、GPIO模块本身，框图如下：</p><p><img src="https://pic.imgdb.cn/item/628b832e09475431291129da.jpg" alt="" /></p><p>CCM: Clock Controller Module (时钟控制模块)<br />IOMUXC : IOMUX Controller，IO复用控制器<br />GPIO: General-purpose input/output，通用的输入输出口</p><ul><li>CCM 设定某个寄存器来使能某一组IO</li><li>IOMUXC 设置寄存器来选择某个引脚(每个引脚对应俩个寄存器:MUX_CTL用来选择脚功能 PAD_CTL是否使用上拉 下拉电阻等等信息)</li><li>设置gpio里面的寄存器<ul><li>设置gpio.GDIR让这个引脚工作于输入或者输出模式<ul><li>输出模式:把值写道gpio.DR寄存器, 让这个引脚输出高低电平</li><li>输入模式: 读gpio.PSR寄存器, 得到这个引脚当前状态</li><li>其他都是中断相关的</li></ul></li></ul></li><li><h2 id="设置iomuxc-来把某个引脚设置gpio功能"><a class="markdownIt-Anchor" href="#设置iomuxc-来把某个引脚设置gpio功能"></a> 设置IOMUXC  来把某个引脚设置GPIO功能</h2></li></ul><p><strong>看芯片手册</strong></p><p>地址:  <code>基地址 + 偏移地址 = 绝对地址</code></p><p><strong>编程–读GPIO</strong></p><p>① 设置CCM_CCGRx寄存器中某位使能对应的GPIO模块 // 默认是使能的<br />② 设置IOMUX来选择引脚用于GPIO<br />③ 设置GPIOx_GDIR中某位为0，把该引脚设置为输入功能<br />④ 读GPIOx_DR或GPIOx_PSR得到某位的值（读GPIOx_DR返回的是GPIOx_PSR的值）</p><p><strong>编程–写GPIO</strong></p><p>① 设置CCM_CCGRx寄存器中某位使能对应的GPIO模块 // 默认是使能的<br />② 设置IOMUX来选择引脚用于GPIO<br />③ 设置GPIOx_GDIR中某位为1，把该引脚设置为输出功能<br />④ 写GPIOx_DR某位的值<br />需要注意的是，你可以设置该引脚的loopback(回环)功能，这样就可以从GPIOx_PSR中读到引脚的有实电平；你从GPIOx_DR中读回的只是上次设置的值，它并不能反应引脚的真实电平，比如可能因为硬件故障导致该引脚跟地短路了，你通过设置GPIOx_DR让它输出高电平并不会起效果。</p><h2 id="led驱动"><a class="markdownIt-Anchor" href="#led驱动"></a> LED驱动</h2><ul><li>先看原理图  GPIO5_3</li><li>再看芯片手册：使能GPIO5 对于IMX6ULL，GPIO5默认使能，无需设置 <code>CCM_CCGR1地址：0x020C4000 + 0x6C</code></li><li>设置GPIO5_3为GPIO  需要配置为gpio模式gpio5_IO03, 需要设置IOMUXC寄存器</li><li>设置GPIO5_3为输出 将gpio_gdir设置成1 变成输出引脚</li><li>设置GPIOB0的输出电平 gpio5_DR 输出1就在这一位写入1</li></ul><h3 id="字符设备驱动框架"><a class="markdownIt-Anchor" href="#字符设备驱动框架"></a> 字符设备驱动框架</h3><img src="https://pic.imgdb.cn/item/628b934409475431293eea69.jpg" style="zoom:67%;" /><p>在Linux系统中, 应用程序只能通过一些标准的接口open read 等访问文件,进而访问驱动程序, 最终访问到硬件</p><p>应用程序要调用open,那么就提供驱动程序的open函数</p><h3 id="led驱动模板"><a class="markdownIt-Anchor" href="#led驱动模板"></a> LED驱动模板</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    <span class="comment">/* copy_from_user : get data from app */</span></span><br><span class="line">    copy_from_user(&amp;val, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* to set gpio register寄存器: out 1/0 */</span></span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* set gpio to let led on */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set gpio to let led off */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* enable gpio</span></span><br><span class="line"><span class="comment">     * configure pin as gpio</span></span><br><span class="line"><span class="comment">     * configure gpio as output </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> =</span> &#123;</span><br><span class="line">    .owner= THIS_MODULE,</span><br><span class="line">    .write= led_write,</span><br><span class="line">    .open= led_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    </span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//led_open write都要访问gpio的寄存器, 都要用到虚拟地址, 虚拟地址在哪里映射呢? </span></span><br><span class="line">    <span class="comment">/* ioremap */</span></span><br><span class="line"></span><br><span class="line">    led_class = class_create(THIS_MODULE, <span class="string">&quot;myled&quot;</span>);</span><br><span class="line">    device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;myled&quot;</span>); <span class="comment">/* /dev/myled */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(led_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(led_class);</span><br><span class="line">    </span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="以imx6ull为例的led驱动"><a class="markdownIt-Anchor" href="#以imx6ull为例的led驱动"></a> 以IMX6ULL为例的LED驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* registers */</span></span><br><span class="line"><span class="comment">// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 地址：0x02290000 + 0x14</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO5_GDIR 地址：0x020AC004 设置功能</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_GDIR;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//GPIO5_DR 地址：0x020AC000  设置输出高低电平</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_DR;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* copy_from_user : get data from app */</span></span><br><span class="line">    ret = copy_from_user(&amp;val, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* to set gpio register: out 1/0 */</span></span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* set gpio to let led on */</span></span><br><span class="line">        *GPIO5_DR &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set gpio to let led off */</span></span><br><span class="line">        *GPIO5_DR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* enable gpio5</span></span><br><span class="line"><span class="comment">     * configure gpio5_io3 as gpio</span></span><br><span class="line"><span class="comment">     * configure gpio5_io3 as output </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 &amp;= ~<span class="number">0xf</span>;<span class="comment">//清掉最低的4位</span></span><br><span class="line">    *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 |= <span class="number">0x5</span>;<span class="comment">//101</span></span><br><span class="line"></span><br><span class="line">    *GPIO5_GDIR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> =</span> &#123;</span><br><span class="line">    .owner= THIS_MODULE,</span><br><span class="line">    .write= led_write,</span><br><span class="line">    .open= led_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    </span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ioremap 映射*/</span></span><br><span class="line">    <span class="comment">// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 地址：0x02290000 + 0x14</span></span><br><span class="line">    IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(<span class="number">0x02290000</span> + <span class="number">0x14</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//ioremap映射的时候以页为单位 ,4k</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GPIO5_GDIR 地址：0x020AC004</span></span><br><span class="line">    GPIO5_GDIR = ioremap(<span class="number">0x020AC004</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GPIO5_DR 地址：0x020AC000</span></span><br><span class="line">    GPIO5_DR  = ioremap(<span class="number">0x020AC000</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    led_class = class_create(THIS_MODULE, <span class="string">&quot;myled&quot;</span>);</span><br><span class="line">    device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;myled&quot;</span>); <span class="comment">/* /dev/myled */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    iounmap(IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3);</span><br><span class="line">    iounmap(GPIO5_GDIR);</span><br><span class="line">    iounmap(GPIO5_DR);</span><br><span class="line">    </span><br><span class="line">    device_destroy(led_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(led_class);</span><br><span class="line">    </span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>怎么访问寄存器</strong>   知道寄存器的地址.</p><p><code>int *p = addr</code> 读取寄存器是为了访问硬件<br />volatile: 对寄存器操作不能去优化 告诉编译器不要随便优化我<br />驱动程序中不可以使用物理地址来访问寄存器, 需要映射成虚拟地址</p><p><strong>测试代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>v</span></span><br><span class="line"><span class="comment">// ledtest /dev/myled on</span></span><br><span class="line"><span class="comment">// ledtest /dev/myled off</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> status = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt; &lt;on|off&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  eg: %s /dev/myled on\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  eg: %s /dev/myled off\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// open</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not open %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;on&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="led驱动程序框架"><a class="markdownIt-Anchor" href="#led驱动程序框架"></a> LED驱动程序框架</h1><p><strong>字符设备驱动框架</strong></p><p><img src="https://pic.imgdb.cn/item/628bc2550947543129b508fc.jpg" alt="" /></p><p>对于LED驱动，我们想要什么样的接口？</p><p><img src="https://pic.imgdb.cn/item/628bc2d60947543129b5a0b8.jpg" alt="" /></p><p>LED驱动要怎么写，才能支持多个板子？<strong>分层</strong></p><ul><li><p>把驱动拆分为通用的框架(leddrv.c)、具体的硬件操作(board_X.c)：</p><p>在leddrv.c里面调用单板提供的led初始化函数,调用单板提供的ctl函数, 每个单板都实现这俩个同名的函数. 当想给A提供驱动程序时, 编译leddrv.c和board_A.c</p></li></ul><p><a href="https://imgtu.com/i/XicKER"><img src="https://s1.ax1x.com/2022/05/25/XicKER.png" alt="XicKER.png" /></a></p><ul><li><p>以面向对象的思想，改进代码： 抽象出一个结构体：</p><p>抽象出一个led_operations结构体, 里面有初始化函数有控制函数, 单板实现下图所示结构体(右边), 里面有初始化成员有控制成员 等于自己的函数. 上层的leddrv.c代码调用底层提供的结构体, 调用里面的函数, 当编译驱动程序时, 要把公共部分和单板部分编译成一个.ko文件.</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> &#123;</span></span><br><span class="line"><span class="type">int</span> (*init) (<span class="type">int</span> which); <span class="comment">/* 初始化LED,which-哪个LED */</span></span><br><span class="line"><span class="type">int</span> (*ctl) (<span class="type">int</span> which, <span class="type">int</span> status); <span class="comment">/* 控制LED,which-哪个LED，status:1-亮,0-灭*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个单板相关的board_X.c实现自己的led_operations结构体，供上层的leddrv.c调用：</p><p><img src="https://pic.imgdb.cn/item/628d0f7209475431296c403b.jpg" alt="" /></p><p><strong>代码(以面向对象为例)</strong></p><p>D:\imx6ull\01_all_series_quickstart\05_嵌入式Linux驱动开发基础知识\source\02_led_drv\01_led_drv_template</p><h2 id="具体单板的led驱动"><a class="markdownIt-Anchor" href="#具体单板的led驱动"></a> 具体单板的LED驱动</h2><p><strong>怎么写LED驱动程序</strong></p><p>① 看原理图确定引脚，确定引脚输出什么电平才能点亮/熄灭LED<br />② 看主芯片手册，确定寄存器操作方法：哪些寄存器？哪些位？地址是？<br />③ 编写驱动：先写框架，再写硬件操作的代码<br />注意：在芯片手册中确定的寄存器地址被称为物理地址，在Linux内核中无法直接使用。需要使用内核提供的ioremap把物理地址映射为虚拟地址，使用虚拟地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ioremap函数的使用：物理地址映射为虚拟地址</span><br><span class="line">① 函数原型：</span><br><span class="line"> <span class="type">void</span> __iomem *<span class="title function_">ioremap</span><span class="params">(<span class="type">resource_size_t</span> res_cokkie, <span class="type">size_t</span> size)</span></span><br><span class="line">使用时，要包含头文件：<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"> ② 它的作用：</span><br><span class="line">把物理地址phys_addr开始的一段空间<span class="params">(大小为size)</span>，映射为虚拟地址；返回值是该段虚拟地址的首地址。</span><br><span class="line"> virt_addr  = ioremap(phys_addr, size);</span><br><span class="line"></span><br><span class="line">实际上，它是按页(<span class="number">4096</span>字节)进行映射的，是整页整页地映射的。</span><br><span class="line">假设phys_addr = <span class="number">0x10002</span>，size=<span class="number">4</span>，ioremap的内部实现是：</span><br><span class="line">a. phys_addr按页取整，得到地址<span class="number">0x10000</span></span><br><span class="line">b. size按页取整，得到<span class="number">4096</span></span><br><span class="line">c. 把起始地址<span class="number">0x10000</span>，大小为<span class="number">4096</span>的这一块物理地址空间，映射到虚拟地址空间，</span><br><span class="line">   假设得到的虚拟空间起始地址为<span class="number">0xf0010000</span></span><br><span class="line">d. 那么phys_addr = <span class="number">0x10002</span>对应的virt_addr = <span class="number">0xf0010002</span></span><br><span class="line">③ 不再使用该段虚拟地址时，要iounmap(virt_addr)：</span><br><span class="line"> <span class="type">void</span> iounmap(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *cokkie)</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>的使用：</span><br><span class="line">① 编译器很聪明，会帮我们做些优化，比如：</span><br><span class="line"><span class="type">int</span>   a;</span><br><span class="line">a = <span class="number">0</span>;   <span class="comment">// 这句话可以优化掉，不影响a的结果</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">② 有时候编译器会自作聪明，比如：</span><br><span class="line"><span class="type">int</span> *p = ioremap(xxxx, <span class="number">4</span>);  <span class="comment">// GPIO寄存器的地址</span></span><br><span class="line">*p = <span class="number">0</span>;   <span class="comment">// 点灯，但是这句话被优化掉了</span></span><br><span class="line">*p = <span class="number">1</span>;   <span class="comment">// 灭灯</span></span><br><span class="line"></span><br><span class="line">③ 对于上面的情况，为了避免编译器自动优化，需要加上<span class="keyword">volatile</span>，告诉它“这是容易出错的，别乱优化”：</span><br><span class="line"><span class="keyword">volatile</span>  <span class="type">int</span> *p = ioremap(xxxx, <span class="number">4</span>);  <span class="comment">// GPIO寄存器的地址</span></span><br><span class="line">*p = <span class="number">0</span>;   <span class="comment">// 点灯，这句话不会被优化掉</span></span><br><span class="line">*p = <span class="number">1</span>;   <span class="comment">// 灭灯</span></span><br></pre></td></tr></table></figure><h3 id="为什么需要ioremap"><a class="markdownIt-Anchor" href="#为什么需要ioremap"></a> 为什么需要ioremap?</h3><img src="https://pic.imgdb.cn/item/628df51309475431297417f8.jpg"  /><p>运行右上角代码俩次, 那么在内存中必定有俩份代码, 同一份程序运行时打印出来的全局变量地址一样嘛?<br />如图, A保存在物理地址addrA上, B保存在物理地址addrB上, 但是他们打印的地址都是一样的, 显然代码打印的并不是物理地址,打印的是CPU看到的虚拟地址, CPU使用同一个地址addr来访问这俩个程序, 运行程序A时, MMU里面会有一个pid, 根据A的进程号 把CPU这个addr转换成程序A这个变量的物理地址, 对B也一样.</p><p>对于程序A和B, 虽然CPU发出的是同一份地址, 他们的进程号不一样导致了他们的物理地址不一样. 由MMU实现从虚拟地址到物理地址的转换.</p><p>MMU: 内存管理单元.</p><ol><li>地址映射</li><li>权限保护 : 各个程序地址间需要有互相隔离的作用,也不能去直接访问硬件.  CPU发出的addr, 能不能访问到硬件得由MMU来决定. 对内核也是一样的, 内核能不能访问到硬件也是由MMU来决定, MMU把物理地址映射成虚拟地址, 内核才能使用虚拟地址去访问这些硬件.</li></ol><h3 id="程序"><a class="markdownIt-Anchor" href="#程序"></a> 程序</h3><p><img src="https://pic.imgdb.cn/item/628dfe39094754312980bd7d.jpg" alt="" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *CCM_CCGR1                              ;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_GDIR                             ;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_DR                               ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_init</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化LED, which-哪个LED */</span>       </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);</span></span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!CCM_CCGR1)</span><br><span class="line">        &#123;</span><br><span class="line">            CCM_CCGR1                               = ioremap(<span class="number">0x20C406C</span>, <span class="number">4</span>);</span><br><span class="line">            IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(<span class="number">0x2290014</span>, <span class="number">4</span>);</span><br><span class="line">            GPIO5_GDIR                              = ioremap(<span class="number">0x020AC000</span> + <span class="number">0x4</span>, <span class="number">4</span>);</span><br><span class="line">            GPIO5_DR                                = ioremap(<span class="number">0x020AC000</span> + <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* GPIO5_IO03 */</span></span><br><span class="line">        <span class="comment">/* a. 使能GPIO5</span></span><br><span class="line"><span class="comment">         * set CCM to enable GPIO5</span></span><br><span class="line"><span class="comment">         * CCM_CCGR1[CG15] 0x20C406C</span></span><br><span class="line"><span class="comment">         * bit[31:30] = 0b11</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* b. 设置GPIO5_IO03用于GPIO</span></span><br><span class="line"><span class="comment">         * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3</span></span><br><span class="line"><span class="comment">         *      to configure GPIO5_IO03 as GPIO</span></span><br><span class="line"><span class="comment">         * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3  0x2290014</span></span><br><span class="line"><span class="comment">         * bit[3:0] = 0b0101 alt5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        val = *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;<span class="comment">//这样只做一次读操作</span></span><br><span class="line">        val &amp;= ~(<span class="number">0xf</span>);</span><br><span class="line">        val |= (<span class="number">5</span>);</span><br><span class="line">        *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = val;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* b. 设置GPIO5_IO03作为output引脚</span></span><br><span class="line"><span class="comment">         * set GPIO5_GDIR to configure GPIO5_IO03 as output</span></span><br><span class="line"><span class="comment">         * GPIO5_GDIR  0x020AC000 + 0x4</span></span><br><span class="line"><span class="comment">         * bit[3] = 0b1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *GPIO5_GDIR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_ctl</span> <span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span> <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//printk(&quot;%s %s line %d, led %d, %s\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &quot;on&quot; : &quot;off&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (status) <span class="comment">/* on: output 0*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* d. 设置GPIO5_DR输出低电平</span></span><br><span class="line"><span class="comment">             * set GPIO5_DR to configure GPIO5_IO03 output 0</span></span><br><span class="line"><span class="comment">             * GPIO5_DR 0x020AC000 + 0</span></span><br><span class="line"><span class="comment">             * bit[3] = 0b0</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            *GPIO5_DR &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">/* off: output 1*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* e. 设置GPIO5_IO3输出高电平</span></span><br><span class="line"><span class="comment">             * set GPIO5_DR to configure GPIO5_IO03 output 1</span></span><br><span class="line"><span class="comment">             * GPIO5_DR 0x020AC000 + 0</span></span><br><span class="line"><span class="comment">             * bit[3] = 0b1</span></span><br><span class="line"><span class="comment">             */</span> </span><br><span class="line">            *GPIO5_DR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">board_demo_led_opr</span> =</span> &#123;</span><br><span class="line">    .num  = <span class="number">1</span>,</span><br><span class="line">    .init = board_demo_led_init,</span><br><span class="line">    .ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_board_led_opr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;board_demo_led_opr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="驱动设计的思想"><a class="markdownIt-Anchor" href="#驱动设计的思想"></a> 驱动设计的思想</h1><p><code>Linux驱动 = 驱动框架 + 硬件操作  = 驱动框架 + 单片机</code></p><h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2><p>字符设备驱动程序抽象出一个file_operations结构体；<br />我们写的程序针对硬件部分抽象出led_operations结构体。</p><h2 id="分层"><a class="markdownIt-Anchor" href="#分层"></a> 分层</h2><p>上下分层，比如我们前面写的LED驱动程序就分为2层：<br />① 上层实现硬件无关的操作，比如注册字符设备驱动：leddrv.c<br />② 下层实现硬件相关的操作，比如board_A.c实现单板A的LED操作</p><p><img src="https://pic.imgdb.cn/item/628e4fbf0947543129faa32d.jpg" alt="" /></p><p>通过分层的思想, 写不同板子的时候比较省时省力. 只需专注单板硬件操作</p><h2 id="分离"><a class="markdownIt-Anchor" href="#分离"></a> 分离</h2><p>在之前实现的单板程序中, 一些函数变量和芯片给绑定太紧了, 换一个灯啥的换一个引脚就需要重新编写代码</p><p>在board_A.c中，实现了一个led_operations，为LED引脚实现了初始化函数、控制函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">board_demo_led_opr</span> =</span> &#123;</span><br><span class="line">    .num  = <span class="number">1</span>,</span><br><span class="line">    .init = board_demo_led_init,</span><br><span class="line">    .ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果硬件上更换一个引脚来控制LED怎么办？你要去修改上面结构体中的init、ctl函数。<br />实际情况是，每一款芯片它的GPIO操作都是类似的。比如：GPIO1_3、GPIO5_4这2个引脚接到LED：</p><ul><li><p>GPIO1_3属于第1组，即GPIO1。<br />有方向寄存器DIR、数据寄存器DR等，基础地址是addr_base_addr_gpio1。<br />设置为output引脚：修改GPIO1的DIR寄存器的bit3。<br />设置输出电平：修改GPIO1的DR寄存器的bit3。</p></li><li><p>GPIO5_4属于第5组，即GPIO5。<br />有方向寄存器DIR、数据寄存器DR等，基础地址是addr_base_addr_gpio5。<br />设置为output引脚：修改GPIO5的DIR寄存器的bit4。<br />设置输出电平：修改GPIO5的DR寄存器的bit4。</p></li></ul><p>既然引脚操作那么有规律，并且这是跟主芯片相关的，那可以针对该芯片写出比较通用的硬件操作代码。</p><p>比如board_A.c使用芯片chipY，那就可以写出：chipY_gpio.c，它实现芯片Y的GPIO操作，适用于芯片Y的所有GPIO引脚。</p><p>使用时，我们只需要在board_A_led.c中指定使用哪一个引脚即可。</p><p>程序结构如下：</p><img src="https://pic.imgdb.cn/item/628e52c10947543129fee5ec.jpg" style="zoom:125%;" /><p>某款芯片可以写出gpio程序去支持所有gpio的操作,当想操作某一个引脚的时候, 告诉它需要用哪个gpio. 左右分离,左边定义资源,右边是硬件通用代码</p><p>以面向对象的思想，在board_A_led.c中实现led_resouce结构体，它定义“资源”──要用哪一个引脚。</p><p>在chipY_gpio.c中仍是实现led_operations结构体，它要写得更完善，支持所有GPIO。</p><p>代码查看文件夹<code>\source\02_led_drv\03_led_drv_template_seperate</code></p><h1 id="总线设备驱动模型"><a class="markdownIt-Anchor" href="#总线设备驱动模型"></a> 总线设备驱动模型</h1><p><img src="https://pic.imgdb.cn/item/628f57db09475431292dd3f2.jpg" alt="" /></p><h2 id="驱动编写的方法"><a class="markdownIt-Anchor" href="#驱动编写的方法"></a> 驱动编写的方法</h2><h3 id="传统写法"><a class="markdownIt-Anchor" href="#传统写法"></a> 传统写法</h3><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220526183457450.png" alt="image-20220526183457450" /></p><p>定义file_operation结构体,在里面提供应用程序要用到的函数, 在驱动程序里提供对应的openread等,然后在驱动程序里操作那些寄存器就可以了.<br />使用哪个引脚，怎么操作引脚，都写死在代码中。<br />最简单，不考虑扩展性，可以快速实现功能。<br />修改引脚时，需要重新编译。</p><h3 id="总线设备驱动模型-2"><a class="markdownIt-Anchor" href="#总线设备驱动模型-2"></a> 总线设备驱动模型</h3><p><img src="https://pic.imgdb.cn/item/628f57ba09475431292d9c2b.jpg" alt="" /></p><p>硬件资源用一个平台platform_device来表示(定义了引脚,寄存器), 对于硬件的操作放在platform_driver里面(固定的驱动程序)<br />用一个总线Bus来管理, 总线的左边是device, 右边是drv.他们俩俩匹配, 这是对分离的设计思想更好的实现. 以前抽象出了led_resource,只能支持led. 现在在platform_device可以存入各种资源</p><h3 id="设备树"><a class="markdownIt-Anchor" href="#设备树"></a> 设备树</h3><p><img src="https://pic.imgdb.cn/item/628f57a109475431292d6d61.jpg" alt="" /></p><p>存在dts文件,存入了驱动的引脚等信息, 会被编译成dtb文件传递给内核, 内核会解析这个文件并构造出一系列的platform_device. 即dts、dtb是放在内核之外的,保持了Linux代码优雅, 即总线设备模型和设备树是类似的,并不涉及驱动程序的核心(分配设置注册file_operation,ioremap操作寄存器),</p><p>设备仅仅是指定硬件使用哪些引脚,哪个资源.</p><h2 id="busdevdrv模型"><a class="markdownIt-Anchor" href="#busdevdrv模型"></a> Bus/Dev/Drv模型</h2><img src="https://pic.imgdb.cn/item/628f6e0b0947543129516180.png" style="zoom:120%;" /><p>首先在内核里面有一个总线platform_bus_type, 这个总线是一个虚拟的总线,它有俩个链表, 左边是设备链表,右边是驱动链表,当我们去注册一个平台设备时,就会放入左边的链表, 注册一个平台driver时放入右边的链表. 这些结构体放入链表之后就会马上跟对方的成员一一比较, 比如: 将一个platform_device注册进内核里面, 同时会把drv里面一个个比较一下, 如果匹配成功就会调用内个drv里面的<code>probe</code>函数. 当注册一个platform_driver时,同时也会去和设备链表一一比较, 如果匹配成功就调用drv里面的<code>probe</code>函数去处理内个device.</p><p>如何知道是否匹配成功?<br />总线这里platform_bus_type里有一个<code>match</code>函数, 用来判断dev和drv是否匹配. dev里面有成员name和driver_override(非它不嫁),  drv里面name放在<code>struct device_driver driver</code>成员里面, 还有数组id_table,表示能支持哪些设备.<br />比较过程: dev里面如果定义了driver_override,就会根据这个名字去查找drv, 如果drv里的name等于的话表示找到.  如果没有定义driver_override就进行第二次比较, 如果drv的id_table不是空的, 就使用dev的name跟id_table里每一项进行比较, 如果吻合的话就表明这俩项是匹配的, 如果id_table为空或者匹配不成功就会用dev里的name和drv里的name去比较(实际中这种比较用的比较多,id_table也多,但使用driver_override比较少).<br />启动过程是怎么启动的? 无论是注册平台dev还是平台drv,都会先放入链表然后从另外的链表把对方的每个成员一一比较</p><p><strong>调用关系</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">platform_device_register</span><br><span class="line">platform_device_add</span><br><span class="line">    device_add</span><br><span class="line">        bus_add_device <span class="comment">// 放入链表</span></span><br><span class="line">        bus_probe_device  <span class="comment">// probe枚举设备，即找到匹配的(dev, drv)</span></span><br><span class="line">            device_initial_probe</span><br><span class="line">                __device_attach</span><br><span class="line">                    <span class="title function_">bus_for_each_drv</span><span class="params">(...,__device_attach_driver,...)</span></span><br><span class="line">                        __device_attach_driver</span><br><span class="line">                            <span class="title function_">driver_match_device</span><span class="params">(drv, dev)</span> <span class="comment">// 是否匹配</span></span><br><span class="line">                            driver_probe_device         <span class="comment">// 调用drv的probe</span></span><br><span class="line"></span><br><span class="line">platform_driver_register</span><br><span class="line">__platform_driver_register</span><br><span class="line">    driver_register</span><br><span class="line">        bus_add_driver <span class="comment">// 放入链表</span></span><br><span class="line">            <span class="title function_">driver_attach</span><span class="params">(drv)</span></span><br><span class="line">                    <span class="title function_">bus_for_each_dev</span><span class="params">(drv-&gt;bus, <span class="literal">NULL</span>, drv, __driver_attach)</span>;</span><br><span class="line">                        __driver_attach</span><br><span class="line">                            <span class="title function_">driver_match_device</span><span class="params">(drv, dev)</span> <span class="comment">// 是否匹配</span></span><br><span class="line">                            driver_probe_device         <span class="comment">// 调用drv的probe</span></span><br></pre></td></tr></table></figure><p><strong>程序编写</strong></p><p>①分配/设置/注册platform_device结构体<br />在里面定义所用资源，指定设备名字。<br />②分配/设置/注册platform_driver结构体<br />在其中的probe函数里，分配/设置/注册file_operations结构体，并从platform_device中确实所用硬件资源。<br />指定platform_driver的名字。</p><h2 id="led驱动总线设备驱动模型"><a class="markdownIt-Anchor" href="#led驱动总线设备驱动模型"></a> LED驱动[总线设备驱动模型]</h2><p>需要实现的框架</p><img src="https://pic.imgdb.cn/item/628fcdef0947543129e06a03.jpg" style="zoom:110%;" /><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\source\02_led_drv\04_led_drv_template_bus_dev_drv</span><br><span class="line">    需要不断熟悉!!!</span><br></pre></td></tr></table></figure><p><strong>驱动内部调用流程</strong></p><p>led_dev.c的入口函数开始, register_chrdev [ led_dev里面有led_drv_open/read函数,但是没有和硬件挂钩, p_led_opr结构体还是空的 ] -&gt;创建类<br />设备相关board_A_led.c [ 入口函数里面去注册platform_device_register ]<br />chip_demo_gpio.c [ 入口函数里面注册platform_driver_register并且调用register_led_operations向上层(leddrv.c)提供了led的操作函数,主要在platform_driver里面的probe函数,当platform_driver和同名的platform_device同名之后,chip_demo_gpio_led_probe函数就被调用 ( 从平台设备里面获得资源, 把那些引脚记录下来同时调用led_device_create函数创建device,这样系统会帮我们创建设备节点,应用程序才可以打开节点 ) ]<br />应用程序打开节点之后,就会进入最上一层调用open函数 ( led_drv_open ), 调用init进入到底层init函数(board_demo_led_init)</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 学习 </tag>
            
            <tag> Drivers </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
