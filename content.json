{"meta":{"title":"Lzzの博客","subtitle":"","description":null,"author":"Leechee","url":"https://blogs.leechee.top","root":"/"},"pages":[{"title":"","date":"2023-01-13T11:24:20.888Z","updated":"2023-01-13T11:24:20.888Z","comments":true,"path":"manifest.json","permalink":"https://blogs.leechee.top/manifest.json","excerpt":"","text":"{\"name\":\"leechee\",\"short_name\":\"leechee\",\"theme_color\":\"var(--lyx-theme)\",\"background_color\":\"var(--lyx-theme)\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"},{\"src\":\"/img/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"/img/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/img/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"/img/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/img/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/img/180.png\",\"sizes\":\"180X180\",\"type\":\"image/png\"},{\"src\":\"/img/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"},{\"src\":\"/img/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/img/256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"/img/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2023-01-09T01:49:46.885Z","updated":"2023-01-09T01:49:46.885Z","comments":true,"path":"package.json","permalink":"https://blogs.leechee.top/package.json","excerpt":"","text":"{\"name\":\"ariasakablog\",\"version\":\"1.0.17\",\"description\":\"SpeedUp!\",\"main\":\"index.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"author\":\"\",\"license\":\"ISC\"}"},{"title":"bangumis","date":"2022-07-16T02:35:32.000Z","updated":"2023-01-09T01:49:46.828Z","comments":true,"path":"bangumis/index.html","permalink":"https://blogs.leechee.top/bangumis/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-03-30T07:57:51.000Z","updated":"2023-01-09T01:49:46.826Z","comments":true,"path":"about/index.html","permalink":"https://blogs.leechee.top/about/index.html","excerpt":"","text":""},{"title":"朋友圈","date":"2022-01-29T07:23:17.000Z","updated":"2023-01-09T12:06:34.845Z","comments":true,"path":"fcircle/index.html","permalink":"https://blogs.leechee.top/fcircle/index.html","excerpt":"","text":"🎣 钓鱼 与主机通讯中…… var fdataUser = { apiurl: '' }"},{"title":"分类","date":"2022-07-03T12:48:08.000Z","updated":"2023-01-09T01:49:46.828Z","comments":true,"path":"categories/index.html","permalink":"https://blogs.leechee.top/categories/index.html","excerpt":"","text":""},{"title":"小空调","date":"2022-11-24T23:37:35.000Z","updated":"2023-01-09T01:49:46.878Z","comments":true,"path":"kongtiao/index.html","permalink":"https://blogs.leechee.top/kongtiao/index.html","excerpt":"","text":""},{"title":"fontawesome对照","date":"2022-11-25T00:16:09.000Z","updated":"2023-01-09T01:49:46.830Z","comments":true,"path":"fontawesome/index.html","permalink":"https://blogs.leechee.top/fontawesome/index.html","excerpt":"","text":"window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight);"},{"title":"声明","date":"2022-07-10T03:13:49.000Z","updated":"2023-01-09T01:49:46.879Z","comments":true,"path":"license/index.html","permalink":"https://blogs.leechee.top/license/index.html","excerpt":"","text":"Copyright© LYX 2022 声明 | 版权协议 为了保持文章质量，并保持互联网的开放共享精神，保持页面流量的稳定，综合考虑下本站的所有原创文章均采用cc协议中比较严格的创作共用-非商业性-禁止演绎 4.0 国际标准。这篇文章主要想能够更加清楚明白的介绍本站的协议标准和要求。方便您合理的使用本站的文章。 本站无广告嵌入和商业行为。违反协议的行为不仅会损害原作者的创作热情，而且会影响整个版权环境。强烈呼吁您能够在转载时遵守协议。遵守协议的行为几乎不会对您的目标产生负面影响，鼓励创作环境是每个创作者的期望。 博客的分类介绍 经验分享包含原创内容，原创内容的非商用转载必须为完整转载且标注出处的带有超链接功能的完整url链接（需能点击）或访问原文之类字样的超链接。 转载内容为转载内容，均标注了出处。建议使用原链接打开，尊重原作者。所有转载内容尽可能为完整转载（如果有部分内容有问题可能会由部分删减和补充）并进行样式调整以适合本博客。如果转载该部分内容需要联系原作者。 你可以做什么？ 只要您遵守本页的许可，您可以自由地共享文章的内容 — 在任何媒介以任何形式复制、发行本作品。并且无需通知作者。 你需要遵守什么样的许可？ 署名 您必须标注内容的来源，您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接提升阅读体验）。 禁止商用 本站内容免费向互联网所有用户提供，分享本站文章时禁止商业性使用、禁止在转载页面中插入广告（例如谷歌广告、百度广告）、禁止阅读的拦截行为（例如关注公众号、下载App后观看文章）。 禁止演绎 分享全部内容（无修改） 您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接） 分享部分截取内容或者衍生创作 目前本站全部原创文章的衍生品禁止公开分享和分发。如有更好的修改建议，可以在对应文章下留言。如有衍生创作需求，可以在评论中联系。 什么内容会被版权保护 包括但不限于： 文章封面图片 文章标题和正文 站点图片素材（不含主题自带素材） 例外情况 本着友好互相进步的原则，被本站友链收录的博客允许博客文章内容的衍生品的分享和分发，但仍需标注出处。 本着互联网开放精神，您可以在博客文章下方留言要求授权博文的衍生品的分享和分发，标注您的网站地址。 作者原创代码及网站源代码协议 网站所有代码采用MIT协议，如有不同，作者会进行标注 随便扒站吧！ 网站本身有关 本站已开启存储桶全站加速，接入了灵天盾CDN，请刷流量的耗子尾汁！！！"},{"title":"","date":"2023-01-13T11:22:42.380Z","updated":"2023-01-13T11:22:42.380Z","comments":true,"path":"messageboard/index.html","permalink":"https://blogs.leechee.top/messageboard/index.html","excerpt":"","text":"说说你的建议吧... 你也可以私发我的邮件lyxof2010@yisous.xyz寻求帮助或者提供建议。 隐藏/显示弹幕（缓解卡顿） document.title = '留言板 | ';"},{"title":"友链","date":"2022-07-03T12:40:57.000Z","updated":"2023-01-13T11:23:09.840Z","comments":true,"path":"links/index.html","permalink":"https://blogs.leechee.top/links/index.html","excerpt":"","text":"🎣 钓鱼 冰糖红茶 “冰糖红茶”博客魔改组织的大佬们 小冰【冰】 做个有梦想的人！ Akilar【糖】 期待您的光临！ 张洪Heo【红】 分享设计与科技生活 贰猹【茶】 用这生命中的每一秒，给自己一个不后悔的未来 我的信息Butterfly & MengDfluidvolantishtml12345- name: Ariasakaの小窝 link: https://yisous.xyz avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg descr: 人有悲欢离合 月有阴晴圆缺 siteshot: https://vercel.yisous.xyz/img/siteshot.png123456- &#123; title: &#x27;Ariasakaの小窝&#x27;, intro: &#x27;人有悲欢离合 月有阴晴圆缺&#x27;, link: &#x27;https://yisous.xyz/&#x27;, image: &#x27;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&#x27;&#125;123456- title: Ariasakaの小窝 avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg url: https://yisous.xyz/ screenshot: https://yisous.xyz/img/siteshot.png keywords: 个人博客 description: 人有悲欢离合 月有阴晴圆缺1&lt;a href=&quot;https://yisous.xyz&quot;&gt;&lt;img src=&quot;https://pic.imgdb.cn/item/63bf8e38be43e0d30e6e6eb2.webp&quot; alt=&quot;avatar&quot;&gt;leechee&lt;/a&gt; 推荐标签衡量标准1.网站没有不良内容 2.文章质量较高 3.文章较多/或者质量过硬 如何申请友链？ 点下面的按钮！ 快速添加友链"},{"title":"好听的音乐","date":"2022-07-14T08:37:40.000Z","updated":"2023-01-09T01:49:46.881Z","comments":true,"path":"musics/index.html","permalink":"https://blogs.leechee.top/musics/index.html","excerpt":"","text":"好听的歌 歌曲排行榜 博主会每隔一段时间将自己近期爱听的歌排行在下面 2022-7 咕咕咕…"},{"title":"分站","date":"2022-08-04T03:38:05.000Z","updated":"2023-01-09T01:49:46.884Z","comments":true,"path":"othersite/index.html","permalink":"https://blogs.leechee.top/othersite/index.html","excerpt":"","text":"一些博主搭建的其它的站点： PS：划掉的表示已挂 域名 用处 搭建原因 yisous.xyz 博客，也是主站（默认无www） 分享一些东西 oj.yisous.xyz OnlineJudge系统 用于自己练习信奥赛题目其实是搞来象征意义的 status.yisous.xyz 网站状态监控 用于监控网站的状态，基于uptimeRobot mc.yisous.xyz Minecraft服务器 用来联机玩，类似于粉丝服那种，还没弄好 tc.yisous.xyz Typecho测试站 看看typecho怎么样，搞来玩的，已经由Wordpress迁移至当前的Typecho，未来服务器文档之后可能会换用 yisous.tk/lyxop.xyz 短链接生成器 制作短链接，使用本站域名，技术有限，所以很丑 bbs.yisous.xyz LYXの论坛 交流一些事情，也可以闲聊，还没弄说是交流其实还是搞来象征意义搞来玩的 博主的一些域名 域名 用处 yisous.xyz 主要使用的域名，当时看到dynadot14块一年就买了，这个名字就是念起来顺口 lyxop.xyz 注册拿来给副站用的，使用blog.lyxop.xyz进入主站。由于域名续费太贵，所以打算以后换成yisous.tk，其余一样 ariasaka.top 在硅云白嫖的一个域名，后续可能会作为主域名使用 lyxoff2233.eu.org 以前的eu.org域名，还不错，后面要拿来想办法用一用 lyxofficial.eu.org 图一乐域名 yisous.tk 20年为了搭树莓派服搞的域名，可是树莓派没多久就被我超坏了，现在就买不起了，后来这个域名过期，现在又弄回来作为副站使用，使用blog.yisous.tk进入主站，www和根域名主站用于提供短域名服务（已挂）。 注意：本博客强制HTTPS，旧电脑可能会出现问题。 #article-container a:not(.post-meta__tags):not(img):not(a[data-fancybox]):hover{ border-radius: 6px; background-color: #425aef; text-decoration: none!important; color:#fff!important; border:none; box-shadow: #dadada 0 0 8px 2px; } #article-container a:not(.post-meta__tags):not(.headerlink):not(a[data-fancybox]){ /* padding:0 2px; */ /* text-decoration: 1px solid #425aef; */ /* text-decoration: underline; */ border-bottom: 2px solid #425aef; color:var(--font-color); padding:4px }"},{"title":"说说","date":"2023-01-09T12:06:36.582Z","updated":"2023-01-09T12:06:36.582Z","comments":true,"path":"speaks/index.html","permalink":"https://blogs.leechee.top/speaks/index.html","excerpt":"","text":"function doSpeaks() { document.title = '说说 | Ariasakaの小窝'; bbtalk.init({ appId: \"\", appKey: \"\", serverURLs: '', pageSize:1919810 }) } document.addEventListener('DOMContentLoaded', (e) => { doSpeaks(); }) document.addEventListener('pjax:complete', (e) => { doSpeaks(); })"},{"title":"敲木鱼","date":"2022-11-25T00:16:09.000Z","updated":"2023-01-09T01:49:46.882Z","comments":true,"path":"muyu/index.html","permalink":"https://blogs.leechee.top/muyu/index.html","excerpt":"","text":"功德：0 功德+100 .muyu-layout { background: black; display: flex; width: 100%; border-radius: 20px; position: relative; justify-content: center; height: 90vh; align-items: center; } #muyu-box img { width: 250px; } #jishu-box{ top: 55px; position: absolute; } #muyu-box p { color: white; opacity: 0; font-size: 25px; } #jishu-box p { color: white; font-size: 30px; } var gongde = document.getElementById(\"gongde\"); var muyu = document.getElementById(\"muyu\"); var jishu = document.getElementById(\"jishu-box\"); var mp3Url = \"/music/muyu.mp3\"; var player = new Audio(mp3Url); var num = 0; muyu.addEventListener(\"click\", function () { num+=100; player.load(); player.play(); muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500); gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600); jishu.innerHTML = \"功德：\"+num+\"\"; });"},{"title":"标签","date":"2022-07-03T12:51:29.000Z","updated":"2023-01-09T01:49:46.911Z","comments":true,"path":"tags/index.html","permalink":"https://blogs.leechee.top/tags/index.html","excerpt":"","text":""},{"title":"网站更新日志","date":"2022-07-02T11:56:00.000Z","updated":"2023-01-09T01:49:46.912Z","comments":true,"path":"update/index.html","permalink":"https://blogs.leechee.top/update/index.html","excerpt":"","text":"Acryple v1.0.0 2022-10-23 经过了深思熟虑，博客主题独立啦！ 现在的主题叫做Acryple，具体见： 引用站外地址 博客正式独立主题啦！ Ariasakaの小窝 目前博客有： 更好的右键菜单 留言弹幕 博客设置（功能贼多大家自己看） 不错的UI，至今为止主css(style.css)有3k行 一些小功能比如公祭日弹窗自动欢迎等 大概就是这些了。 Acryple v1.0.110 2022-12-13 加入pwa 全站采用存储桶加速，可惜并没有卵用 很多资源转为了白嫖eleme 抛弃metingjs，目前aplayer的歌曲托管在eleme npm镜像中 友链添加随机头像 博客设置画饼的三个功能仍未修复 qwq 修复一些bug 大改swiper，参考自Leonus 完成Build101的大部分饼 修复了朋友圈爬取bug sw换回cyfan 套上了灵天盾亚太CDN 因为性能问题，移除了文章日历 给导航栏加上滚动动画（画饼） bb布局重构（画饼） 分类标签栏bug修复（画饼） 语雀云端写作（因bug已回滚） gulp（因bug已回滚） 文章进度显示（画饼） 修复pjax的bug 右键菜单功能完善 Acryple v1.0.101 2022-12-06 （PS：部分画大饼 壮举：适配pjax！！！ 修复黑幕的bug 修复评论弹幕dom错误，溢出的bug 弹幕换用swiper方案，并且优化样式 首页bb增加天数显示，以及换用swiper(预计) 修复一些bug（e.g.aplayer、博客设置 优化部分动画/样式 完善博客控制面板，仍有部分未完工 修复部分文章页面溢出的bug 悼念某人，banner换图 pace换用xlenco的胶囊方案 由于未知特性删除了pjax的加载动画，首次保留 部分资源换用缤纷云 换用空梦的sw 不断优化加载速度ing… 修复首页轮播bug(预计) 评论样式修改，预计添加用户tag功能 更换背景没有时效限制了 欢迎文本 左右栏切换 弹幕开关设置自动显隐 落樱特效 aplayer显隐功能 明暗模式自动切换、固定导航栏功能（预计） 边栏样式修改 修复点赞第一赞没反应的bug 修复ghactions部署没有npm缓存的bugtnnd我等十几分钟安装依赖等几个月了，结果是顺序反了 目前朋友圈后端出现了bug，导致不更新，请静待修复 Acryple v1.0.100 2022-12-04 修复部分bug（不，特性 优化部分动画/样式 修改右键菜单 重写博客设置，并将 rightside 的部分功能移动到博客设置中，灵感来源于ichika（未完工 支持隐藏 ASide 了 短暂变灰 修复公祭日js的bug 修复右键菜单在主页也能开启阅读模式的bug 优化手机端阅读体验，去卡片化 优化latex样式 修复部分分辨率下无导航栏的bug aplayer的体验更好了 优化部分样式，适配部分还未适配的黑暗模式 加了一个字体 重写分类和标签、归档页的样式，来源于ichika 优化页脚查看体验 优化网站性能 支持全屏 css 5k+ qpzc 解封辣！！！ 究极跳号？！CRT18:?! Acryple v1.0.92 修复部分bug（不，特性 优化部分样式 更改了博客设置的部分主题色 pages页面在Acrylic主题下的背景得到了改善 更改加载页面背景 重新进行部分断点 把博客api\\服务全部迁移到了另一个github账号~~(垃圾桶)~~上 优化搜索UI 对butterfly4.5.1进行了选择性同步(优化繁体字库) 疫情退退退awa Acryple v1.0.91 修复部分bug（不，特性 为APlayer进行完善 添加早报、木鱼、空调页面，参考Chuckle 更改关于页面，参考安知鱼的教程 尝试npm全站静态化，最终失败放弃qwq 优化sw，加载速度略有提升 新增文章统计 优化部分样式 Acryple v1.0.81 2022-11-23 修复部分bug（不，特性 优化性能问题，对弹幕进行了节流 添加APlayer，可惜没有pjax qwq 优化弹幕（更洪化了） 调整网站布局 修改一些样式 PS：在1.0.51偷偷加了一号字号你们发现没有(doge) Acryple v1.0.51 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 换用Twikoo-magic表情包 为了OI添加 KaTeX\\textbf{ \\KaTeX} KATE​X 修复跳转链接因原有bug被迫使原页面刷新的bug Acryple v1.0.14 2022-11-10 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 增加浏览器过期提醒以及banIE，参考chuckle以及b站 增加fps显示 评论表情添加颜文字 修复手机端侧边栏bug PS：作为一个萌新OIer依然没有考虑发oi文 ╮(╯▽╰)╭ 以前的更新日志哔哩哔哩 (゜-゜)つロ 干杯！ 2022 07-02 终于弄好网站了，庆祝一下🎉 Gitalk不知道为什么不显示出来… 07-03 小更新，修改细节 作者的Html实在太菜了，效果并不好 07-04 大更新 修改了很多ui 07-05 大更新 修改细节UI和友链部分，增加吐槽部分 07-06 小更新，做好一些功能并且写了第一篇文章 07-08 大更新，更改首页布局，增加首页分区 07-09 小更新，修改细节，适配手机端，修复bug，说说由Artitalk换为BBtalk 07-14 前面几天忘记写更新了，更新了很多UI和功能。。。 07-18 前面几天又忘记写更新了小小修改了一些布局，把鸽了很久的博客写完了并且还加了萌百的黑幕，没有你知道的太多了差评 07-22 前面几天又双忘记写更新了折腾了很多，加了自己的域名，把你知道的太多了弄出来了，并且修复了很多js的bug，把unpkg换成fastly.jsdelivr或者elemecdn，提升速度（竟然有人加了我友链，怎么知道这个网站的？） 08-12 前面几天又双叒忘记写更新了还是折腾了很多，按照冰糖红茶大佬们的方法加了不少东西，比如那个人潮汹涌模拟器（主页的）、文章点赞、无缝跳转等等，换成jsdelivr加速，同时也在最大化利用GoormIDE，不过在险些没有数据之后就尽可能迁移到了其它没有风险的平台。 08-25 最近在糖果屋群友们的建议和帮助下修改了很多功能,以后每隔一段时间都会写详细的日志而不是像前面简单概括了。 留言板的弹幕是真的像b站视频弹幕了，过一段时间修复了bug之后放教程 新增博客设置，做了一个极简风的主题，支持更换主题色，也可以换回之前的主题，可以禁用模糊效果和开启硬件加速提升性能 修复了部分排版bug，对safari进行了一些适应，感谢Apple Store和洪哥的帮助。 增加了hover的缩放效果，有层次感 优化动画 修复留言弹幕、右键菜单的bug并且把新版的代码更新到文章中 优化细节样式 新增最新文章标记 总算部署好朋友圈了！leancloud国内版垃圾！"},{"title":"工具","date":"2022-07-13T07:23:02.000Z","updated":"2023-01-09T12:06:38.049Z","comments":true,"path":"tools/index.html","permalink":"https://blogs.leechee.top/tools/index.html","excerpt":"","text":"镜像站常用的PyPi/npm/SDK镜像站 TUNA 清华大学开源镜像站 豆瓣PYPI源 豆瓣PYPI镜像站 jsDelivr jsDelivr静态资源加速（GFW已墙） unpkg 另一个静态资源加速CDN（没墙） 资源下载类好用的资源下载/收录站 MSDN,我告诉你 微软MSDNED2K镜像收录站 唧唧Down 下载B站视频 无损生活 免费下载全网绝大部分无损音乐 百度网盘简易下载助手 特别好用的bd网盘破解器（不知道为什么公众号分享很怕敏感词） 日常工具常用日常工具 计时器 闹钟网计时器 图片系列关于图片的工具 Bigjpg 高清修复图片与降噪 waifu2x 高清修复图片与降噪，性能貌似好一点 jpgrm 高清修复图片与降噪 Sheilds 制作Github项目徽章 极简壁纸 海量高清壁纸美图&二次元图片 常用测试网站测试一些基础功能 还没做完呢 你瞅啥？还妹做完呢！"},{"title":"早报","date":"2022-11-24T23:37:35.000Z","updated":"2023-01-09T01:49:46.912Z","comments":true,"path":"zaobao/index.html","permalink":"https://blogs.leechee.top/zaobao/index.html","excerpt":"","text":""}],"posts":[{"title":"ubuntu20的vscode设置","slug":"code_linux","date":"2022-04-10T15:21:13.000Z","updated":"2023-01-11T01:23:29.574Z","comments":true,"path":"posts/9c7668f5/","link":"","permalink":"https://blogs.leechee.top/posts/9c7668f5/","excerpt":"","text":"我的ubuntu20的vscode设置 launch.json 123456789101112131415161718192021222324252627282930&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;miDebuggerArgs&quot;: &quot;-q -ex quit; wait() &#123; fg &gt;/dev/null; &#125;; /bin/gdb -q --interpreter=mi&quot;, &quot;name&quot;: &quot;(gdb) Launch&quot;, // 配置名称 &quot;type&quot;: &quot;cppdbg&quot;,// 配置类型 &quot;request&quot;: &quot;launch&quot;, // 请求配置类型,launch或者attach &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;&quot;,// 进行调试程序的路径，程序生成文件.out &quot;args&quot;: [],// 传递给程序的命令行参数，一般为空 &quot;stopAtEntry&quot;: false,// 调试器是否在目标的入口点停止， &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,// 项目目录 &quot;environment&quot;: [], &quot;externalConsole&quot;: false,// 调试时是否显示控制台窗口，一般为true显示控制台 &quot;MIMode&quot;: &quot;gdb&quot;,// 指定连接的调试器 &quot;preLaunchTask&quot;: &quot;build&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ]&#125; tasks.json 1234567891011121314&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build&quot;,// 任务名 &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;g++&quot;,// 指令 &quot;args&quot;: [&quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-std=c++17&quot;, &quot;-o&quot;, &quot;$&#123;fileBasenameNoExtension&#125;&quot;] &#125; ]&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.leechee.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.leechee.top/tags/Linux/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://blogs.leechee.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blogs.leechee.top/tags/ubuntu/"}]},{"title":"QT","slug":"Qt","date":"2022-04-06T15:21:13.000Z","updated":"2023-01-11T01:58:15.935Z","comments":true,"path":"posts/9454662e/","link":"","permalink":"https://blogs.leechee.top/posts/9454662e/","excerpt":"","text":"[TOC] 信号和槽 信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是： QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot())); 参数 1、信号的发送者 参数 2、发送的信号 参数 3、信号的接收者 参数 4、处理函数（槽函数） 12QMetaObject::Connection ret = connect(btn,&amp;QPushButton::clicked,this,&amp;QWidget::close); //sendr.btn signal.clicked点击 recvier.this widget.close事件 把click信号和槽关联起来 信号与槽（Signal &amp; Slot）是 Qt 编程的基础，也是 Qt 的一大创新。因为有了信号与槽的 编程机制，在 Qt 中处理界面各个组件的交互操作时变得更加直观和简单。它可以让应用 程序编程人员把这些互不了解的对象绑定在一起。 信号（Signal） 信号（Signal）就是在特定情况下被发射的事件，例如 PushButton 最常见的信号就是鼠标 单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射 的 CurrentIndexChanged() 信号。 GUI 程序设计的主要内容就是对界面上各组件的信号的响应，只需要知道什么情况下发射 哪些信号，合理地去响应和处理这些信号就可以了。 槽（Slot） 就是对信号响应的函数。槽就是一个函数，与一般的 C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。 Qt 中自定义信号和槽函数 自定义信号和槽的区别，信号和槽都为 void 类型，信号只需要定义，不需要实 现，而槽函数既需要定义，也需要实现，信号和槽都可以有参数也都可以重载。emit 是出发信号的标志，可要可不要。 注意信号重载函数指针指向哪一个函数的问题，对于重载函数的信号连接，要指 明到底连接的是哪一个 信号和槽的扩展 多个信号可以连接同一个槽函数 这个就不用实例了，我们的按钮和窗口上的 xx 都可以关闭窗口。 信号和槽的参数必须一一对应。 信号的发送什么，槽就接收什么，类型必须一致。但信号的参数个数可以多余槽的参数的个 数，但前面相同数量的参数类型必须一一对应。反之则不可以 Lambda 函数 Lambda 函数也叫 Lambda 表达式，是匿名函数，就是没有名字的函数，和传统的函数不一样。Lambda 表达式是 C++11 中引入的新概念，用于定义并创建匿名的函数对象。首先看 下 Lambda 表达式的基本结构。 [捕捉列表] (参数) mutable -&gt;返回值类型 &#123;函数体&#125; 1234567891011121314151617[]()&#123;qDebug( &quot;Lambda&quot; );&#125;();1、 [ ]，标识一个，Lambda 匿名函数的开始，这个必须有，不能省略，函数对象参数是传 递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用到 Lambda 定 义为止 Lambda 所在的作用域范围内可见的局部变量，包括 Lambda 所在类的 this。函 数对象参数有以下形式 a) 空，没有使用任何的函数对象参数 b) =，函数体内使用 Lambda 所在范围内的可见局部变量包括所在类的 this 的传值方 式，相当于编译器给 Lambda 所在地的所有局部变量复制一份给 Lambda 函数 c) &amp;，函数体内使用 Lambda 所在范围内的可见局部变量包括所在类的 this 的引用方 式，相当于编译器给 Lambda 所在地的所有局部变量引用一份给 Lambda 函数 d) this，函数体内可以使用 Lambda 所在内的成员变量 e) a,不是字母，而是指具体一个变量 a，那么 Lambda 内拷贝一个 a 使用 f) &amp;a，Lambda 内引用 a g) a,&amp;b,拷贝 a，引用 b h) =，&amp;a，&amp;b，除 ab 引用，其余拷贝 i) &amp;，a，b。除 ab 拷贝，其余引用 2、 函数参数，这个跟常规函数一样。 3、 mutatble，修改关键字，再对应位置 mutatble 关键字，才能修改函数对象参数。否则报 错。可以有，也可以没有，但有才能修改。lambda 默认是 const，也就是不能修改本地 变量。 4、 -&gt;return-type 返回值的方式，既然是函数就可能有返回值，那么-&gt;就是有返回值的函 数标志。 5、 函数体，跟常规函数一样。 1234567QPushButton * btn2 = new QPushButton(&quot;222&quot;,this); QPushButton * btn3 = new QPushButton(&quot;333&quot;,this); btn2-&gt;move(0,20); btn3-&gt;move(0,50); int a = 10; connect(btn2,&amp;QPushButton::clicked,this,[a]()mutable&#123; a += 100;qDebug()&lt;&lt;a; &#125;); connect(btn3,&amp;QPushButton::clicked,this,[=]()mutable&#123; qDebug()&lt;&lt;a; &#125;); qDebug()&lt;&lt;a; 新建两个按钮分别写入以上 Lambda 函数，再连接函数中直接可以写上 Lambda 函数体，消 息触发的时候，就直接调用，btn2，中只是将 a 传值，有关键字 mutable 可以在函数中修改 a 的值，但不会影响外面的值。 扩展 123456789101112131415161718ret=100;ret=[&amp;ret]()mutable-&gt;int&#123;ret*=2;return ret;&#125;();cout&lt;&lt;ret;//retx2int a=0,b=1;[](int&amp; a,int&amp; b,int count)&#123; int ret=0; for(int i=0;i&lt;count;i++)&#123; ret=a+b; a=b; b=ret; cout&lt;&lt;ret; &#125;&#125;(a,b,20);//循环20次输出斐波那契数列(后一项是前俩项的和) 应用 无参按钮调用有参的槽函数","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://blogs.leechee.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blogs.leechee.top/tags/C-C/"},{"name":"QT","slug":"QT","permalink":"https://blogs.leechee.top/tags/QT/"},{"name":"项目","slug":"项目","permalink":"https://blogs.leechee.top/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"Linux 网络编程基础","slug":"Linux网络编程基础","date":"2022-04-01T15:21:13.000Z","updated":"2023-01-11T01:24:19.850Z","comments":true,"path":"posts/30335c15/","link":"","permalink":"https://blogs.leechee.top/posts/30335c15/","excerpt":"","text":"Libevent C++高并发网络编程 3.1 课程内容概述 Libevent源码的跨平台编译和测试 Libevent原理和网络模型设置 event事件处理原理和实战 bufferevent缓冲IO bufferevent、zlib实现过滤器中压缩和解压缩 libevent的http接口实现服务端和客户端 搭建基于libevent的C++跨平台线程池 基于libevent和线程池完成FTP服务器开发 大并发服务器架构学习 第一章 高性能的服务器架构 网络I/O + 服务器高性能编程技术 + 数据库 超出数据库连接数 超出时限（队列+连接池，缓冲更新，缓冲换页，数据库读写分离进行负载均衡-replication机制） 服务器性能四大杀手： 数据拷贝-缓存技术解决 环境切换-有理性创建线程，单线程还是多线程好，单核服务器（采用状态机编程，效率最佳，减少线程间的切换开销），多线程能够充分发挥多核服务器的性能。 内存分配-内存池 锁竞争 第二章 大型网站架构演变过程 web动静资源分离 缓存处理 减少对网站的访问-客户端（浏览器）缓存 减少对Web应用服务器的请求-前端页面缓存（squid） 减少对数据库的查询-页面片段缓存ESI（Edge Side Includes） 减少对文件系统I/O操作-本地数据缓存 Web server集群+读写分离（负载均衡） 前端负载均衡：DNS负载均衡、反向代理、基于NAT的负载均衡技术、LVS、F5硬件负载均衡 应用服务器负载均衡 数据库负载均衡 CDN、分布式缓存、分库分表 多数据中心+分布式存储与计算（技术点DFS分布式文件系统、Key-Value DB、Map/Reduce算法） 第三章 poll Linux下有三种I/O复用模型：select、poll、epoll。 Linux网络编程基础 网络基础-综述 1. 协议的概念 TCP协议注重数据的传输，HTTP协议注重数据的解释。 2. b/s（浏览器/服务端模式） c/s（客户端/服务端模式） C/S模式优点：协议选用灵活，提前对数据进行缓存 C/S模式缺点：对用户安全构成威胁，开发任务工作量大 B/S模式优点：安全性高，跨平台 B/S模式缺点：协议选用不灵活，数据加载不缓存 两者使用场景不同。 3. 分层模型：OSI七层模型-TCP/IP四层模型 OSI七层模型: 物理层-&gt;数据链路层-&gt;网络层（IP协议）-&gt;传输层（TCP/UDP协议）-&gt;会话层-&gt;表示层-&gt;应用层 TCP/IP四层模型：网络接口层------&gt;网络层（IP协议）-&gt;传输层（TCP/UDP协议）---------------&gt;应用层（FTP协议） 4. 协议格式 数据包基本格式：操作系统封装数据和解析数据包；路由器寻路（寻找下一路由节点）的一般思想。 以太网帧格式：|目的地址(6字节)|源地址6字节|类型2字节|数据|CRC校应2字节| arp数据包格式:|目的地址(6字节)|源地址6字节|帧类型0806|硬件类型-协议类型-硬件地址长度-协议地址长度-op-发送端以太网地址-发送端IP地址目的以太网地址-目的IP地址（28字节ARP请求/应答）|PAD填充18字节|。arp数据报的目的：获取下一跳mac的地址。 IP段格式：在网络层。|4位版本号|4位首部长度|8位服务类型（TOS）|16位总长度（字节数）| TCP/UDP数据报格式 5. NAT映射 打洞机制 NAT（Network Address Translation，网络地址转换），也叫做网络掩蔽或者IP掩蔽。NAT是一种网络地址翻译技术，主要是将内部的私有IP地址（private IP）转换成可以在公网使用的公网IP（public IP）。 NAT可以同时让多个计算机同时联网，并隐藏其内网IP，因此也增加了内网的网络安全性；此外，NAT对来自外部的数据查看其NAT映射记录，对没有相应记录的数据包进行拒绝，提高了网络安全性。 打洞机制需要借助公网 IP 实现； 公-公通信（局域网内IP通信）：直接访问；公-私：NAT映射；私-公：NAT映射；私-私：NAT映射、打洞机制。 6. 套接字socket通信原理概念 IP地址：在网络环境中唯一标识一台主机 端口号：在主机中唯一标识一个进程 IP地址 + 端口：唯一标识网络通讯中的一个进程，对应一个socket。 socket 成对出现、必须绑定IP+端口、一个文件描述符指向两个缓冲区（一个读一个写）。 6.1 网络字节序列化 大端存储：低地址–高位(高地址存低位) 小端存储：高地址–低位 TCP/IP协议规定，网络数据流应采用大端字节序。为了使网络程序具有可移植性，使同样的 c 代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。 123456#include&lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort); h 标识host， n 表示 network， I 表示 32 位长整数， s 表示 16位短整数。 6.2 ip地址转换函数 123#include&lt;arpa/inet.h&gt;int inet_pton(int af, const char *src, void *dst) //字符串ip转换网络字节序;const char *inet_ntop(int af,const void *src,char *dst, socklen_t size) //网络字节序转换字符串ip; 6.3 socketaddr数据结构 1234567891011// sockaddr_in 结构体定义struct sockaddr_in &#123; sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */&#125;;/* Internet address. */struct in_addr &#123; uint32_t s_addr; /* address in network byte order */&#125;; 6.4 网络套接字函数 1，创建套接字socket函数. 123int socket(int domain, int type, int protocol);返回值： 成功：返回指向创建的socket的文件描述符，失败：返回-1，设置errno。 2，绑定 ip 和端口号函数 bind. 1234567891011#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;int bind(int cockfd, const struct sockaddr *addr, socklen_t addrlen);sockfd: socket 文件描述符addr: 构造出IP地址+端口号addrlen： sizeof(addr)长度返回值： 成功返回0，失败返回-1，设置errno 7. TCP C/S模型：server.c client.c","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.leechee.top/categories/Linux/"}],"tags":[{"name":"unbuntu","slug":"unbuntu","permalink":"https://blogs.leechee.top/tags/unbuntu/"},{"name":"高并发","slug":"高并发","permalink":"https://blogs.leechee.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"C++","slug":"C","permalink":"https://blogs.leechee.top/tags/C/"}]},{"title":"C++","slug":"Cplus基础","date":"2022-03-16T15:21:13.000Z","updated":"2023-01-11T01:24:44.923Z","comments":true,"path":"posts/f9a964a9/","link":"","permalink":"https://blogs.leechee.top/posts/f9a964a9/","excerpt":"","text":"[TOC] 基础More size_t : typedef unsigned int C++的静态转换: b为要转换的内容 int a=static_cast&lt;int 目标类型&gt;(b); 查看变量类型: typeid(变量).name(); 格式化输出流: 运算优先级:(优先级从上到下) 枚举变量 1234567891011enum class xx:int //自动递增1,从上往下&#123; normal, high, low=xx, other, other1=other//多个情况&#125;;//使用xx use_xxn&#123;xx::normal&#125;;xx use_xxh&#123;xx::high&#125;; 1.提高代码的可读性和安全性 2.枚举类型默认int型 3.枚举类型成员只能是整数类型 4.枚举类型和其他类型转换需要强制转换 自定义变量名称 三种方式: 123#define A Typename //typedef Typename A; //Typename被A替换using A=Typename; //同上 自定义命名空间: 123456namespace yournamespace&#123; int ... string int xx()&#125; 变量的声明周期: 变量生命在代码块结束后死亡. 全局变量的生命程序运行一直存在 1::xx //定义后使用双冒号使用 位运算: 输出二进制文件. 12引用 bitset头文件std::bitset&lt;要显示的二进制位数&gt;(要显示的变量); std::boolalpha 可以将流的输出控制为bool类型 字符处理 判断 C++17语法 if(int a; check() ) {} switch(变量声明 ；条件（）) {} goto的使用 ： input&#123;代码段&#125; ... goto input； 数组 数组的地址连续 求大小 sizeof(a[])/sizeof(a[0]) or sizeof(数组名/sizeof(类型名)) 基于数组的循环 for(变量类型 变量名称 : 数组) &#123;&#125; for(auto 变量名称 : 数组) &#123;&#125; array容器 #include std::array&lt; 变量类型 , 元素数量&gt; 变量名; exp: std::array&lt;int ,5&gt;stuID; //五个学生的学号 1234stuID.size();stuID.fill(x); //将所有元素都设置为xstuID.at(1); //返回stu[1]里的内容 vector容器 array的优点基本都具备 size fill at #include 指针 c++声明指针需要初始化 指针数组 int* array[10] 数组里面存了10个指针 指针详细 {待补充} 123 动态内存分配 c内存分配 void* malloc ： 用法{ } nullptr 相当于0 （c++17新） void* calloc(size_t count , size_t size); : 为用户分配count*size字节个内存 void* realloc(void* _Block,size_t_size) : 为用户重新分配内存，_Block是用户已经分配好的内存，Size是要求重新分配的大小 void* free(void* _Block) : 释放内存 c++内存分配 释放内存： 12if (int* p = new int ) delete p;if (int* p = new int[x]) delete []p; 风险 悬挂指针：释放了还在继续使用释放掉的地址 内存碎片：频繁申请和释放小块内存会造成内存碎片，原则上可以使用，实际上使得我们无法分配新的内存.但是new和delete的算法会帮助我们尽量规避 复制内存 malloc和new本质区别 对于普通的数据类型来说malloc和new没什么区别,但是对于类来说,malloc仅仅是分配内存而new除了分配内存以外还会调用构造函数! free和delete本质区别 对于普通的数据类型来说free和delete没有什么区别,但是对于类来说,free仅仅是释放内存空间,而delete不仅释放内存空间,还会调用类的析构函数 delete和delete[]本质区别 对于普通的数据类型来说deletc和delete[]没有什么区别,但是对于类来说,delete仅仅是释放内存空间,且调用第一个元素的析构函数,而delete[]不仅释放内存空间,还会调用每一个元素的析构函数 对普通数据类型无所谓 引用 引用的本质其实就是一种被阉割了的指针，虽然我们取址引用变量得到的是原地址的内存地址，但是引用变量也是占用内存的 引用需要初始化 提高代码效率，{个人觉得类似于软连接} 语法： 数据类型&amp;变量名称&#123;引用对象的名称&#125;； exp： int a&#123;500&#125;; int&amp; la&#123;a&#125;; la=500即a=5200. 智能指针 std::unique_ptr 第一种声明不允许用数组方式访问，第二种可以。 智能指针不允许指向别的智能指针。具有唯一性。 用法 1234567reset();//reset将会释放std::unique_ptr的内存空间，并且设置为nullptrget();//get返回std::unique_ptr的指针release();//release返回std::unique_ptr的指针,并且设置为nullptr，但是不会释放占用的内存空间 std::shared_ptr 12345678910111213141516std::shared_ptr的复制std::shared_ptr&lt;int&gt; ptrA&#123;&#125;std::shared_ptr&lt;int&gt; ptrB&#123;std::make_shared&lt;int&gt;(5)&#125;;ptrA=ptrB;··························································//获得计数long std::shared_ptr.use_count();.use_count();会返回当前指针共有多少个对象调用bool std::shared_ptr.unique();//unique()会返回以一个bool值，if当前智能指针是唯一拥有该指针的人，返回truestd::shared_ptr.reset();//将当前共享指针设置为nullptr，如果是最后一个拥有该指针的对象，释放内存 特性 可以有多个std::shared_ptr指向同一地址，同一地址下只有最后一个std::shared_ptr释放的时候，才会释放其所占用的空间，std::shared_ptr会记录当前有多少个智能指针调用 C原生字符串 字符串就是指针，数组 &lt;! 待补充 --&gt; wchar_t str[0xff]&#123;L&quot;HEllo&quot;&#125;; 宽字节常量 （使用utf-16实现UNICODE） 使用UNICODE标准 ： setlocale(LC_ALL,&quot;chs&quot;) 使用wcout输出 std::cout 默认输出char类型的值时会当作字符串进行处理。 联合体 union 语法： 1234567891011union 联合体名称&#123; 变量类型 变量名称; 变量类型 变量名称;&#125;exp:union user&#123; short shp; int xhp;&#125; 通过union可以创建一个联合体，union中的成员变量共享内存，因此 union的数据类型大小由其最大的成员变量决定 union中任意一成员变量发生改变都可能影响别的变量 匿名联合体、结构体 顾名思义，没有名字的联合体和结构体 一般只用一次 C++字符串string #include &lt;string&gt; 定义： std::string str&#123;&quot;wow!&quot;&#125;; std::string 变量名称&#123; &quot;字符串&quot; , 要截取的长度&#125; exp：string str&#123;&quot;1234&quot;,2&#125;; str=&quot;12&quot; std::string 变量名称&#123; &quot;字符串&quot; ，起始位置 ， 要截取的长度&#125; std::string 变量名称(要复制的个数，'字符') 连接字符串 std::string str(6,'a'); str=str+&quot;123; str=&quot;aaa123&quot; 连接字符串和数字 std::string str = std::to_string(数字)； 字符串连接字符串 字符串不能直接和别的字符串连接，可以使用临时变量解决(std::string(xx)); 可以 &quot;变量&quot;&quot;变量&quot; 变成&quot;变量变量&quot; 也可以str.append(&quot;你要拼接的内容&quot;) 可以无限加 字符串连接字符 直接+‘字符’ 即可 截取字符串 .substr(起始位置，要截取的长度); or .substr(起始位置) 长度 std::string.length(); 得到长度 字符串比较 .compare() 比如： str.compare(&quot;abcd&quot;); 大于返回正数，相等等于0； 扩展： .compare(起始位置,参与比较的长度,被比较的字符串); 字符串搜索 .find() 用来搜素字符串的内容,并返回内容所在的位置,当返回值是std::string::npos表示未找到 .find(要搜索的内容 , 开始搜索的位置) .find(要搜索的内容,开始搜素的位置,要纳入的字符串长度[注:是搜索内容的字符串]) .rfind() 用法和find一样,从字符串尾部倒叙搜索 插入字符串 .insert() 可以在一个string字符串的指定位置插入另一个字符串 .insert(要插入的位置 , 要插入的字符串) .insert(要插入的位置,要插入的字符个数,要插入的字符) exp:id.insert(3,6,‘x’); .insert(要插入的位置,要插入的字符串,要插入的字符串的起始位置,要插入的大小) .insert(要插入的位置,要插入的字符串,要插入的大小) 替换字符串 .replace 可以替换string字符串中的内容 .replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot;) .replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot; ,'字符') 对单字符 .replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot; ,替换后内容节选长度[此处是替换的字符串的]) .replace(要替换内容的起始位置, 要替换的长度 ,&quot;替换的字符串&quot;,替换后的起始位置,替换后内容的节选长度 删除字符串 ``.erase()` 删除字符串中的内容 .erase(要删除的起始位置,要删除的起始长度) .erase(要删除的起始位置) exp: 从起始位置删除所有的内容 str.clear(); 指针数组字符串内存学习 {待补充} 想得到放字符串这段内存的区域 不能修改! 其他 exp：输入中文英文等字符串，正确返回字符个数 待补充 函数 指针参数 数组参数 建议用数组方式引用 引用参数 指针可以传入nullptr，而引用不可以 默认实参 exp： void func(int a,int&amp; b,int* c,bool x=true) 此时用户根据需要调用func时x可写可不写，不写默认是true ！默认实参只能放在最后 引用定义的时候不能瞎指 不定量参数 mian（int argc,char** argc）&#123;&#125; C语言也常用 函数返回：返回指针和引用 {知识很多 待补充} 比如返回结构体 ，返回指针，返回引用，传递引用参数时的类型转换 数组的引用： exp： int a[100] int(&amp;b)[100]=a 传递数组引用： 1234int num(int (&amp;array)[100])&#123; return sizeof(ary);&#125; 函数参数：右值引用 ps：函数使用引用会节约内存消耗 左值就是一般左边定义的东西有明确的内存空间 可以读取写入，右值是存放在临时空间内 exp：*(a+1)=2 此事a+1仍然是一个右值 int&amp;&amp; 右值引用 exp: 1234int&amp;&amp; e = 100+100;void Add(int&amp;&amp; a)&#123; std::cout&lt;&lt;a; &#125;Add(e+320+329); 设计字符串类的时候会感受到… exp: 创建一个临时的角色信息 1234567891011121314struct Role&#123; int hp; int mp;&#125;Role createmonster()&#123; Role rt&#123;100,200&#125;; return rt;&#125;void Show(Role&amp;&amp; rl)//没有分配内存空间却达到了同样的效果&#123; std::cout&lt;&lt;rl.hp;&#125; 函数的本质 loading 函数指针 可以指向特定类型函数的指针 函数返回类型 (*函数指针变量名)(参数类型 参数名称, …参数类型 参数名称); 转类型 char (*myadd)(int,int)=(char (*)(int,int)Add); 强转太长了怎么办: typedef函数返回类型 (*函数指针变量名)(参数类型 参数名称,....参数类型 参数名称); 也可以: using pfadd=char (*)(int,int); 函数重载 C++有，c语言需要自己实现，不自带此功能 尽管函数名称相同,但是在我们调用函数时,通过函数参数的不同,编译器还是能够确定我们调用的是哪一个函数,因此程序能够准确的编译 ！ 是参数的不同可以确定是哪个函数。 但是编译器无法单纯通过返回值来确定你要返回的函数,参数要不同! exp: float ave() 和 int ave() 无法重载 exp: 同样的函数,用指针和数组写法不能重载,引用也不行 Tips:为什么俩个函数,有一个int&amp; 一个float ,我定义了char变量去调用,强转为(int)x型,去调用函数却仍然是float函数,因为强转只是声明了一个临时的变量,而引用需要已经定义的(真实存在的)变量 同样的函数,一个int 一个const int也不行(会出现歧义) 但是一个是int的引用int&amp; 一个是 const int&amp; 常量引用,那就可以重载 函数重载的时候不可以设置默认参数 函数模板 除了类型不同外,函数的运算逻辑都一样,这样的函数我们就可以利用函数模板技术来生成对应的函数. 123456789101112131415template &lt;typename type1&gt; type1 ave(type1 a,type1 b)//ave求平均值的&#123; return (a+b/2);&#125;int a=ave(1,2); //ave相当于int ave(int a,int b)char a=ave(1,2); //ave相当于char ave(cahr a,char b)exp:template &lt;typename type1&gt; type1 ave(type1 a,type1 b,type1 c)&#123; type1 a;//可以定义 return (a+b+c)/3;&#125;//也可以指定一个函数模板exp： ave&lt;int&gt;(192.0f,159.3f); // 执行int ave 函数模板和重载 函数模板的例外处理 12345678910template &lt;typename type1&gt; type1 ave(type1 a,type1 b)&#123;return (a+b)/2;&#125;template &lt;&gt; float ave(float a,float b)&#123;return (a+b-100.0f)/2;&#125;我们可以利用template&lt;&gt;定义一种函数模板的例外情况 函数重载优先于函数模板,但是函数模板的例外情况要优先于函数重载 函数模板的重载 函数模板的重载也是通过参数来区分 1 推断函数模板返回类型(多不同类型) 返回值,传入参数都不同 123456789101112131415161718192021222324252627282930313233343536373839404142434445temp1ate &lt;typename type1,typename type2&gt;type1 ave(type1 a,type2 b)&#123;return (a+b)/2;&#125;template &lt;typename type1,typename type2&gt;type1 ave(type1 a,type2 b,int c)&#123;return (a+b+c)/3;&#125;//同时调用的时候可以 ave&lt;int,int&gt;();类似于这样强行更改类型 template &lt;typename type1,typename type2&gt;type1 ave(type1 a,type2 b,int c)&#123;return (a+b+c)/2;M&#125;template &lt;typename typeR,typename type1,typename type2&gt;typeR bigger(type1 a,type2 b)&#123;return a&gt;b?a:b;bigger&lt;int&gt;(100,120.2f);bigger&lt;int,float,int&gt;(100,120.2f);//### 如何更加智能的推断-&gt; (c++14后)temp1ate &lt;typename typeR,typename type1,typename type2&gt;typeR bigger(type1 a,type2 b)&#123;return a&gt;b?a:b;&#125;//可以利用auto来推断返回值的类型template &lt;typename type1,typename type2&gt;auto bigger(type1 a,type2 b)&#123;return ab?a:b;)&#125;注*auto做返回类型推断是在C++14之后引入的template &lt;typename type1,typename type2&gt;auto bigger(type1 a,type2 b-&gt;decltype(a&gt;b?a:b)&#123;return a&gt;b?a:b;&#125;template &lt;typename type1,typename type2&gt;decltype(auto) bigger(type1 a,type2 b) //decltype(auto)可以通过引用更改值&#123;return a&gt;b?a:b;&#125;//decltype(auto)为C++14后的写法 函数模板参数 1待补充 很多 函数模板本质 待补充 auto and decltype c++11之后出现 auto可以声明一个变量,让编译器根据变量的值来推断变量的类型 例如 auto a&#123;123&#125;; 相当于``int a{123; 利用auto的这一特性我们可以利用auto来创建一个函数 123456789101112auto ave(int a,int b)&#123;return a+b;&#125;相当于int ave(int a,int b)&#123;return a+b;&#125;注*以上都并非auto的最恰当用法,不管是函数还是变量,都不推荐使用auto来声明 auto 12345678910111213141516171819202122232425auto不能保留const属性比如const int a&#123;&#125;;auto c = a;c是int类型而非const类型auto 会优先推断为值类型而非引用类型int a&#123;5&#125;;const int&amp; la=a;auto d=a;d为int类型而非int&amp; auto利用函数返回值来确定类型的时候,函数会执行auto x=ave(1,2);//ave(1,2)会执行x的类型依据ave函数的返回类型来确定auto bigger(int&amp; a,int&amp; b)&#123;return a&gt;b?a:b;&#125;auto会优先把值匹配成值类型而非引用类型,就以本例来说假设我们希望bigger函数返回的是int&amp; 用auto声明达不到这样的效果,为了达到这种目的,我们可以使用另外一种技术: 拖尾函数auto bigger(int&amp; a,int&amp; b)-&gt;int&amp;&#123;return a&gt;b?a:b;&#125; decltype decltype关键字可以得出一个表达式的类型; 语法:decltype(表达式) int a&#123;&#125;; unsigned b; decltype(a-b) x;相当于unsigned x; 如果decltype内的表达式没经历任何运算,那么得出的数据类型同表达式内的数据类型,并且decltype可以保留const和引用类型 . 编译器依处理decltype关键字时的原则: 如果decltype内的表达式经历了运算,那么得出的数据类型是根据运算结果是否有固定的内存地址(左值)来决定的,如果有固定的内存地址则得出的类型为该类型的引用类型,如果没有固定的内存地址,则得出的类型为该结果的类型. 如果decltype内的表达式是一个函数,那么得出的数据类型是根据函数的返回类型来确定的;(decltype不会执行函数) static(only变量) and inline static 利用static可以声明一个静态变量 static类型变量名称; 例如: static int a; static的变量,如果没有指定初始化的值,那么会初始化为0,无论有没有指定初始值,都只会初始化一次! exp: count不会只会在函数被初始化一次,生命周期很长,值会保留 1234int Add(int a,int b)&#123;static int count;count++;&#125; inline inline int Add(int a,int b){ return a+b; } 我们可以用inline声明一个内联函数 内联函数将会建议编译器把这个函数处理成内联代码以提升性能 始终是建议,具体编译器是否采纳,由编译器决定 [有些过时了] extern 函数一些理论 理解定义和声明 我们写的函数就是函数的定义 因为函数的定义是我们要告诉计算机具体如何来执行我们的命令,所以这个命令必须是明确的,你不能告诉它同时往东并且往右,这就说明我们编写代码的时候,你不能多次定义一个函数! 因此函数的定义只能有一次! 但是函数的声明是我们和编译器的对话,在某些特殊的场景下,我们可以多次声明一个函数! 虽然编译器觉得我们啰嗦,但是并不影响我们之前的感情。 声明的本质是与编译器的对话,单纯的声明并不存在内存的分配,只是给编译器一个大体的概念，既然是对话,我们可以多次对话,所以对于同一个事物,我们可以多次声明; 而定义的本质是要通过编译器与计算机对话,这就涉及到内存的分配和访问,因此同一事物,不管声明多少次,但是只能有一次定义; 变量其实也适用这个规则,我们可以通过关键字extern声明一个变量,而把变量的声明和定义分开; 我们写函数的声明的时候,没有写extern关键字,是因为函数的声明本身就是extern的,因此不需要我们手动指出; extern 的作用也是告诉编译器,此处只是一个声明,你去别处找定义,因此extern是针对的全局变量，因为局部变量不存在去别U找的可能性!而函数的声明自带extern属性,因此函数本身也是全局的! 例如: extern int a; 函数名是内存地址 头文件和源文件 多个源码共用一个全局变量 在头文件中声明多个源文件中要共用的全局变量 察 比如 extern int verId; 至于verld的定义你可以放到任何源文件中,但是不可以放到头文件中,因为这样就违背了乎个事物只能定义一次的原则! 123456#pragma once放在头文件中的第一行,可以防止头文件被多次调用#ifndef#define#endif 创建自己的SDK 12345678#incldue &quot;&quot;#define VERSION &quot;1.0&quot;int xx() &#123; &#125;namespace my_sdk&#123; const char* Getversion() &#123; &#125; ...&#125; 步骤:(vs环境) 做成静态库 右键属性-&gt;配置类型.静态库 .lib-&gt;右键属性 . 生成-&gt;打开文件夹 库做好了 .lib 使用时: 右键属性-&gt;包含目录 放入自己的lib-&gt;库目录 加入自己的.h目录-&gt; 几种方法: 1: #pragma comment(lib,&quot;xxx.lib&quot;) 2: 右键属性-&gt;链接器-&gt;输入-&gt;附加依赖项(库目录需要有) 创建项目类型 1234567891011121314151617181920212223242526272829```### 函数调用约定函数调用约定是函数调用与被调用者之间的一种协议,这个协议主要规定了以下两个内容:`如何传递参数` `如何恢复栈平衡````c++函数调用约定_cdecl:__cdecl参数入栈顺序从右到左堆栈平衡:谁调用谁平衡正因为__cdecl这种堆栈平衡方式,能够支持不定量参数函数调用约定_stdcall___stdcall参数入栈顺序从右到左次堆栈乎衡:函数自己恢复栈平衡Windows编程中WINAPICA1LBACK都是__stdcall的宏生成的函数名会加下划线,后面跟@和参数尺寸int _stdcallave(int a, int b)函数调用约定__fastcall第一个参数通过ecs传递第二个参数通过edx传递剩余参数入栈顺序从右到左堆栈乎衡:函数自己恢复栈平衡fastcall的函数执行速度比较快_thiscall 用作C++中类的访问,我们将在类的底层时讲这种callnaked call是一个不常用的调用约定,一般用于实模式驱动开发 递归函数 套娃&gt;&gt;&gt; a调用b,b调用a称为互递归函数 递归会造成栈溢出 内联函数不能递归 编译器 理论 转换单元 我们写好的每个源文件(.cpp,.c)将其所包含的头文件(#include &lt;xxx.h&gt;)合并后,称为一个转换单元; 编译器单独的将每一个转换单元生成为对应的对象文件(.obj),对象文件包含了转换单元的机器码和转换单元的引用信息(不在转换单元中定义的对象); 最后链接器将各个转换单元的对象文件链接起来,生成我们的目标程序; 比如在对象文件A中包含了定义在其他转换单元的引用,那么就去其他转换单元的对象文件中寻找这个引用的定义来建立链接,如果在所有的对象文件中都找不到这个定义,那么就会生成一个链接错误. 未定义行为 即我们在编写代码中,C标准未作规定的行为,称为未定义行为,未定义行为的结果是不确定的,具体在不同的编译器下会有不向的效果; 比如 c=2*a++ + ++a*6; 这里先算a还是先算++a就是一个未定义行为 比如: int x=-25602;×=x&gt;2; x的结果在不同的编译器下是不确定的,因为这也属于未定义行为 One Definition Rule 单一性规则 ODR是一系列规则,而不是一个规则,程序中定义的每个对象都对应着自己的规则; 但是基本上来讲任何的变量,函数,类,枚举,模板,概念(C20)在每个转换单元中都只允许有一个定义;非inline的函数或变量(C17),在整个程序中,有且仅有一个定义; 总结: 有多个声明 , 只能有一个定义 名称的链接属性 程序中的变量,函数,结构等都有着自己的名字,这些名字具有不同的链接属性,链接器就是根据这些链接属性来把各个对象文件链接起来的; 链接属性分为以下三种: 内部链接属性:该名称仅仅在本转换单元中有效 外部链接属性:该名称在其他的转换单元中也有效 无链接属性:该名称仅仅能够用于该名称的作用域内访问 define 1234567891011121314151617181920212223#define A B将标识符A定义为B的别名#define整数int整数a&#123;&#125;;取消定义： #undef 定义复杂表达式的宏：#define SUM(X,Y) X+Y#define AVE(X,Y) (X+Y)/2#define BIGGER(X,Y) ((X)&gt;(Y)?(X):(Y))SUM(100,200)AVE(100,200)BIGGER(100,200)#可以将一个标识符参数字符串化#define SHOW(X) std:cout&lt;&lt;#X //字符串SHOW(1234fg);=&gt;std:cout&lt;&lt;&quot;12345fg&quot;##可以连接两个标识符#define T1(X,Y) void X##Y()&#123;std:cout&lt;&lt;#Y;&#125; //连接字符串 使用#define 的方式定义常量并不安全. namespace 有时候为了方便管理,把相关的函数,变量,结构体等会附加到一个命名空间中 namespace t &#123;int value;&#125; 访问这个命名空间的变量 t:value 所有具有链接属性的对象,只要没有定义命名空间,就默认定义在全局命名空间中,全局命名空间中成员的访问不用显示的指定,当局部名称覆盖了全局名称时才需要显式的指定全局命名空间; int a; ::a=250 1234567891011121314151617181920212223242526272829303132333435363738394041424344//全局命名空间的扩展namespace htd&#123;int weight &#123;1980&#125;;&#125;namespace htd&#123;int height&#123;1080&#125;;&#125;第二个htd属于对htd命名空间的扩展,weight和height同属一个命名空间//命名空间拓展namespace htdvoid sendSms() &#123;&#125;void htd:sendSms() &#123;&#125;//命名空间的嵌套namespace htd&#123; void sendSms(); namespace hack &#123; void hackServer(); &#125;&#125;void htd::hack::hackServer() &#123;&#125;void htd::sendSms() &#123;&#125;//未命名空间不给命名空间指定名称,将会声明一个未命名的命名空间namespace &#123;&#125;未命名的命名空间中声明的内容一律为内部链接属性,包括用extern声明的内容,未命名的命名空间仅仅在本转换单元中有效//命名空间的别名namespace htd&#123; void sendSms(); namespace hack&#123; void hackServer(); &#125;&#125;namespace hServer=htd::hack;hSever:hackServer(); 预处理逻辑指令 #ifndef #if #elif 预定义宏 123456//标准预定义宏__func__编译器支持ISO C99和ISO C++11指定的预定义标识符函数的名称 //下面是微软公司做的宏 调试 为了方便调试,在编码风格上: 1 模块化 2 使用能够体现出具体意义的函数名和变量名 3 使用正确的缩进和代码块 4 良好的注释习惯 1补充。。。 assert调试 （断言） 语法: assert(bool表达式); 如果括号内的bool表达式为false 则会调用std:abort()函数 弹出对话框 assert宏需要头文件 cassert 可以通过 #define NDEBUG 关闭 要放在include前 static_assert用于编译时检查条件 static_assert(bool表达式,“错误信息”); C++17新语法： static_assert(bool表达式); 与assert不同,static_assert主要是用来在编译时检查重要的条件 因此检查的bool表达式中,只能用于常量 STL STL介绍 类 OOP 00P(Object Oriented Programming)即面向对象编程,本质上是一种编程思想,通过把我们编程中遇到的事物来抽象成对象来编程;与OOP相关的还有OOD(面向对象设计),00A(面向对分析)等; OOP应当遵循OOD的原则,所有坏的OOP代码基本都是违反了OOD原则 SOLID原则 { 待百度 } 面向对象的特点 封装： 继承： 多态： 定义类 1234class&#123; private://影响后面出现的内容 只能类中使用 public://公开&#125; 成员函数 123456789101112131415161718192021class ROLE&#123; private: int hpRecover;-&gt;&gt;成员变量 void Init() -&gt;&gt;成员函数 &#123; hpRecover=3; &#125; public: int hp;-&gt;&gt;成员变量 int damage; -&gt;&gt;成员变量 void Act(ROLE&amp; role)-&gt;&gt;成员函数 &#123; role.hp-=damage; &#125; void Act(ROLE&amp; role);//外部定义后需要定义成这样&#125;;//在类的外部定义成员函数void ROLE::Act()&#123;...&#125; 空class默认一个内存空间 inline成员函数： （推荐写在头文件里） this指针 成员函数的指针 ， 代表定义的成员本身 const 1234567891011class Rolepublic:int hp;int GetHP() const ;&#123;&#125;int Role::GetHP() const&#123;return hp;&#125;//const对象只能调用const成员函数 const对象不能以任何方式改变,这是const的原则,在这个基本原则下,产生了一些列效应,比如const对象只能调用const成员函数; const对象无法调用别的成员 另外一个我们不注意的变化是,在const成员函数下,this指针也变成了const指针 const类型转换 mutable mutable声明的成员变量可以被const成员函数修改 1234567891011121314class Role&#123;private: int hp; mutable int getHPCount;public: int GetHP0 const ; &#125;int Role:GetHP0 const&#123;getHPCont++;return hp;&#125; 构造函数 在类的定义中有一种特殊的成员函数叫做构造函数.构造函数在类被创建时自动被调用,一般用来创建新的类实例时执行初始化操作构造函数与它所在的类同名,并且没有返回值,任何类都至少有一个构造函数; 1234567891011121314151617181920class ROLE&#123;private: int hpRecover; void lnit0 &#123; hpRecover=3; &#125;public: ROLE() &#123; Init(); &#125; int hp; int damage; void Act(ROLE&amp; role)&#123; role.hp-=damage; &#125;);//跟java一样 ， 构造函数和类同名如果什么都不做 推荐Role() = default; explicit关键字 被explicit关键字修饰的构造函数会禁用类型转换 成员初始化列表 12ROLE(int _lv,int _damage):lv&#123;_lv&#125;, damage&#123;_damage&#125;&#123;&#125; 初始化时，初始化可以这样写快速初始化 效率更高，有时候只能这样去初始化 使用成员初始化列表这样的方式构造类,要注意一个问题,即为成员赋值的顺序不是依据代码的顺序,而是成员变量在类的出现顺序; 委托构造函数初始化列表里不能初始化成员变量且只能调用一次同一个类的构造函数 ROLE(int _lv,int xx):ROLE(_lv) 这种是委托构造，关于lv的都在ROLE这个构造函数里 副本构造函数 编译器为类指定了一个默认的副本构造函数,我们也可以手动指定副本构造函数 Role role1; Role role2(role1); 析构函数 在类中还有一种特殊的成员函数,叫做析构函数,析构函数在类的生命周结束时,被自动调用,一般用来做 扫尾工作 比如释放内存,关闭句柄等等,如果一个类没有定义析构函数,那么编译器会自动添加一个空的析构函数,析构函数只能有一个; 析构函数没有参数,没有返回类型,一般不会手动调用,如果类的析构函数为空,最好使用关键字default来定义,例如: ~ROLE()=default; 静态成员变量 我们可以在类中通过static关键字声明一个类的静态成员变量,类的静态成员变量的特点: 1 所有类的实例中,共享类中的静态成员变量 2 类的静态成员变量在没有类的实例的情况下,依然可以访问 3 类的静态成员变量并不完全属于类 内存空间不属于类 实例类不管多少个，static都不变，被所有实例共享一个内存空间 c++17后 可以 inline static int count&#123;20&#125; 来定义 const static int count&#123;20&#125; 静态成员函数 我们可以利用static关键字声明一个类的静态成员函数,类的静态成员函数有如下特点: (1)不管有没有创建类的实例,都可以访问类的静态成员函数 (2类的静态成员函数不能访问非静态的成员变量 (3)类的静态成员函数不能是const (4)类的静态成员函数不能使用this指针 友元 12345678910111213可以通过friend关键字声明一个函数为某个类的友元函数,友元函数可以访问该类中的所有成员class T&#123; int hp; void ResetHP(); friend void SetHP(T&amp; t);&#125;void SetHP(T&amp; t)&#123; t.ResetHP(); t.hp++;&#125; 俩个类交朋友的话 在另一个类上面声明 class 类名 即可 友元 不建议用 嵌套类 把一个类写在一个类里 12345678910class Role&#123;private: int hp; int mp; class Weapon &#123; int lv; &#125;;我们可以在类的声明中再声明一个类,在类中声明的类称为嵌套类,而声明嵌套类的类称为外层类 作用域 嵌套类的声明在外层类中,因此嵌套类的作用域受外层类限定 假如要在类外声明女个Weapon对象 Role::Weapon mWpon; 嵌套类的作用域受封装属性管辖,即private封装的嵌套类是无法在类外使用的 在类外定义嵌套类 class ROLE::Weapen 在外的类要这么写 。 函数、对象同理 函数指针情况： 123456class Weapon;&#125;;class Role::Weapon&#123;Weapon*CreateWeapon();&#125;Role::Weapon* Role::Weapon::CreateWeapon()&#123; return this; &#125; 嵌套类可以访问外层类的所有成员 外层类仅能访问嵌套类的公有成员 局部类 定义在函数内的类称为局部类 局部类的定义必须写在类内 局部类中不允许使用静态成员变量 局部类可以访问全局变量 嵌套类模块化问题 多文件时。嵌套头文件，类出错 注意头文件 类的成员函数的函数指针 从底层理解类（逆向） {待补充} 重载 运算符重载 在OOP编程中,万物皆对象,我们如何让这些对象也能够像普通类型一样实现加减乘除呢?比如我们学习过的std:string对象 std:string str=&quot;大家好!&quot;; str=str+”才是真的好!&quot;; 要实现这个功能我们就要对运算符+重新进行设计,当我们的对象进行+运算时不再是编译器默认的+预算,而是进入我们指定的函数,这种重新设计运算符规则的技术就称为运算符重载! 语法:返回类型operator运算符0 //例如 bool operator&lt;(const Role&amp; role); 非类成员函数实现需要使用友元定义 即： man&lt;woman == man.operator&lt;(woman) == man&lt;woman 原则和时机 意义 (1）让类也支持原生的运算比如＋-*/ (2）提升对程序的控制权比如重载new delete newdelete[ 备注: 运算符重载的主要目的是为了让目标代码更方便使用和维护，而不是提升开发效率，重载运算符未必能提升开发效率 限制 (1)不能自创运算符比如=== ,=&lt;&gt;=只能重载现有运算符 (2)以下运算符不能重载 (a)对象访问运算符．例如 user.hp (b)作用域解析运算符::例如std::cout ©求大小的运算符sizeof 例如sizeof(int) (d)条件运算符?:例如b=a&gt;c?100:200 (3)不能修改运算符本身的优先级,相关性 (4)在C17后，也不能修改运算符的操作数的计算顺序，在C17前，编译器可以自由选择如何计算（未定义行为) (5)除了delete/delete和new/new外,不能对原生数据类型的其他运算符进行重载，比如把char类型的+定义为- (6)除了new和delete以为，其他运算符的arity(运算符关联的操作数的个数或者是关联的参数）一律不能修改 原则 (1)不要改变运算符本身的意义,比如把加法重载为减法 (2)不建议重载逻辑运算符&amp;&amp; ||,取址运算符&amp; 逗号运算符， 备注:重载后的逻辑运算符将不会进行短路测试，在C17标准前，编译器可以自由决定先计算左操作数还是右操作数,在C17后计算的顺序规定为先计算左再计算右 语法 二元运算符的重载 利用全局函数 返回类型 operator 运算符(类型 左操作数,类型 右操作数） 利用类的成员函数 返回类型 operator 运算符(类型 右操作数) 一元运算符的重载 利用全局函数返回 返回类型 operator 运算符(类型 操作数) 利用类的成员函数 返回类型 operator 运算符() 有的运算符只能重载为类的成员函数,有些运算符只能重载为全局函数,有些运算符既可以重载为类的成员函数又可以重载为全局函数,如果一个运算符既可以重载为成员函数又可以重载为全局函数,我们一般推荐重载为类的成员函数,因为类的成员函数可以是虚函数,单全局函数不能是虚函数,如果这个运算符不修改对象,应该将这个成员函数限定为const 运算符重载的参数一般可以传递值或者引用,大部分情况下,能够传递引用就不要传递值,对于不会修改的值最好是限定为const,某些时候要擅用使用右值引用&amp;&amp;作为参数 运算符重载的返回值一般来说可以是任何类型,但是尽量要符合运算符的原意,比如把&gt;运算符返回指针类型,把+返回bool类型,都不是很好的选择 重载运算符 {待补充} 很多符号 重载类型转换 1 类型转换运算符只能重载为类的成员函数 2 类型转换运算符没有返回值。它的返回值由类型转换的类型来决定 3 语法 `` 4 operator 类型() const {待补充} 什么是隐试类型转换： float x=2 此时2是int型 这是就是隐式类型转换转成float型 重载内存分配 1待补充 继承 假设有一个类animal现在我们基于animal类创造一个新类monkey,那么我们说类animal monkey类的基类(父类),moneky类是anima类的派生类(子类),子类自动继承包含了父类的成员变量以及成员函数! 子类不能继承父类的构造函数,析构函数,重载赋值运算符,虽然不能继承,但是这些内容依然是存在于父类中的。 如果我们继续基于monkey创造一个新类bigMonkey,那么monkey是bigMonkey的直接基类,animal是bigMonkey的间接基类 class 类名:访问属性[public|private|protected] 父类名称 protected: 只有子类和友元可以访问 不想被别人继承的话 后面加 final 修改继承成员的访问属性 可以用using 基类名::成员名 来修改继承来的成员的访问属性 使用proteted和private访问属性有几个好处 可以更好的封装父类成员 可以在子类作为基础进行派生类的时候提供继承控制 将保护属性为private的父类产生的子类作为基类的时候,派生类继承但不能访问构建其父类的基类成员 将保护属性为protected的父类产生的子类作为基类的时候,派生类继承且可以访问其非私有成员 继承访问属性的选择 一般来说,尽量射击类的成员变量为private,如果需要访问这些成员变量,应该提供setter以及getter函数 继承中的构造函数 派生类 构造顺序:先构造基类再构造派生类 (父亲-&gt;儿子) 父本构造函数 一个由另一个来复制. 执行时就不会调用原本的构造函数了 exp: actObject(const actObject&amp; obj) 继承构造函数 通过 using 基类::基类构造函数 可以继承基类构造函数,但是默认构造函数与副本构造函数不会被继承 继承析构函数 先释放派生类,再释放基类 , 与构造顺序相反 当基类和派生类的成员函数同名时,要分俩种情况: 1 函数名相同,参数不同 using 基类::函数名 2 函数名相同,参数相同 基类::函数名 exp: obj.lastObject::lastlastObject::show(); 多重继承 一个类可以拥有多个父类,并且可以继承各个父类的成员 (不推荐用) class xx: public x1 , public x2 &#123;&#125;; 多重继承带来的重复继承问题 问题时继承来的东西重复继承 首先可以强制指定解决√ 另一方法: 虚基类 class xx:public virtual x&#123;&#125;; 意思时只引入一次,第二次不引入 内存角度理解 {深入理解 待补充} 多态 对象多态 exp: 人是动物√ 动物是人× 即第一个第向上转型(父类=&gt;子类 父类表达子类), 第二个是向下转型(子类=&gt;父类 子类表达父类) 12345678910111213141516171819class animal&#123;public: int age; &#125;;class people&#123;public: int money;&#125;main()&#123; peole lz; lz.age = 22; lz.monry=1; animal* anm1=&amp;lz; people* humn=(people*)anm1; //不推荐这样用&#125; 内存切片 exp: 人类转成动物类的时候, 有些东西会丢掉(比如钱), 这就是内存切片 对象多态详解 12345678910111213class moveobj&#123;&#125;;class monstermove:public moveobj&#123;&#125;;monstermove monster;moveobj* _move=&amp;monster;//隐式类型转换 向上转型monstermove* _pmove=&amp;_move; //隐式 向下转型 不允许! 可以强制monstermove* _pmove=(monstermove*)_move;monstermove* _pmove=static_cast&lt;monstermove*&gt;_move; //会检测待补充... 动态强制转换 只能用于多态类 方法多态(多态类) 静态多态 ①函数重载 函数(&amp;类实例化的对象) 从而判断执行哪一个函数 ②函数模板 动态多态 virtual虚函数 告诉派生类 我这个函数是虚的 你需要重写 virtual 放在定义函数的前面 使用条件 virtual只能写在类的内部声明或者定义,不能把virtual写在类的外部定义中 调用类的对象是无法使用虚函数的,必须使用基类指针来实现虚函数的调用 虚函数在派生类和基类中必须具有相同的及参数列表 虚函数在派生类和基类中返回值要求基本一致,但是当返回类型为类类型的指针和引用时除外 虚函数不能是函数模板 类名* 函数名() override 代表我这个函数是继承来的 final 代表不再被继承. 虚函数的执行也是遵循类的生成和销毁的(自我理解) 可以使用 基类::基类函数() 强行调用基类函数 默认实参在基类已经定义了那么派生类的修改是无效的,即使执行派生类的函数 当你通过基类声明派生类对象 基类* p=new 派生类(); 然后释放内存调用析构函数的时候,调用的是基类的析构函数(因为派生函数不是虚函数,你是通过基类声明的对象) 容易造成内存泄漏,所以需要 进行 虚析构函数 , 即可正常. 抽象类 纯虚函数 在实际的项目设计中,可能出现一种情况,父类有N个派生类 比如Animal类派生出Dog和Cat 此时我们在Animal类中是无法确定Move函数的内容的,这个时候为Animal类设计Move函数的内容是无意义的,这种情况下我们可以将Move函数设计为纯虚函数 void virtual Move(=0; =0可以将指定的函数设置为纯虚函数 为什么要定义成纯虚函数 为了利用它的多态性,实现多态 抽象类 有纯虚函数的类 不能用于实体 拥有纯虚函数的类称为抽象类,因为该类的函数没有实现,因此不能创建抽象类的实例,但是却可以使用抽象类的指针和引用作为返回或者参数! 抽象类的构造函数因为不能实际使用,所以一般推荐把抽象类的构造函数定义为protected 抽象类的派生类如果没有定义纯虚函数,则该派生类依然是抽象类 接口类 类中所有(极大部分)函数定义为纯虚函数的类成为接口类 调试 typeid(类型).name 输出类型名字 但是必须要有多态 总结 c++ 的基础还是有些没有总结好,后面补充","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://blogs.leechee.top/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blogs.leechee.top/tags/C-C/"},{"name":"语言","slug":"语言","permalink":"https://blogs.leechee.top/tags/%E8%AF%AD%E8%A8%80/"}]},{"title":"算法基础","slug":"DS笔记","date":"2022-03-16T15:21:13.000Z","updated":"2023-01-11T01:23:51.700Z","comments":true,"path":"posts/fa1802cb/","link":"","permalink":"https://blogs.leechee.top/posts/fa1802cb/","excerpt":"","text":"基础算法 scanf(&quot;%[^\\n]&quot;,a); 载入space [TOC] 基础 排序 快速排序 1 确定分界点 左 右或者中间 2 调整区间 划分成俩部分 大于的和小于的 3 递归处理左右俩段 1234567891011121314void quick_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j), quick_sort(q, j + 1, r);&#125; 求最大值 例: 1234567891011121314151617#include &lt;bits/stdc++.h&gt;int quickfind(int l, int r, int k) &#123; // 前半部分和快排完全相同 if (l &gt;= r) return a[r]; int i = l - 1, j = r + 1, x = a[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i++; while (a[i] &lt; x); do j--; while (a[j] &gt; x); if (i &lt; j) swap(a[i], a[j]); &#125; // 求出 SL 的长度（分界点 - 左边界 + 1） int SL = j - l + 1; // 情况 A if (k &lt;= SL) return quickfind(l, j, k); // 情况 B else return quickfind(j + 1, r, k - SL);&#125; 归并排序 主要思想:分治 (双指针算法) 1.找分界点(中间) mid=(l+r&gt;&gt;1)递归排序左右 2.归并 把俩个有序的数组合并※ 分开后有俩个序列,首先递归将俩个序列各自排序,排序完之后分别有一个指针指向俩个序列的最小值,以第一个序列开始的话,对比俩个序列的值哪一个小,小的就放在新建的res数组里去,然后第一个序列的指针往后移动一位(当俩个数字相同时,随便将一个指针后移).重复,直到一个序列的指针在结尾,那么把另一个序列的数全部放在res后面去即可. 12345678910111213141516171819void merge_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125; or 1234567891011121314151617void merge_sort(int nums[], int left, int right) &#123; if (left &gt;= right) return ; int mid = left + ((right - left) &gt;&gt; 1); merge_sort(nums, left, mid); merge_sort(nums, mid + 1, right); int k = left, l = left, r = mid + 1; while (k &lt;= right) &#123; if ((r &gt; right) || (l &lt;= mid &amp;&amp; nums[l] &lt;= nums[r])) tmp[k++] = nums[l++]; else tmp[k++] = nums[r++]; &#125; for (int i = left; i &lt;= right; ++i) nums[i] = tmp[i];&#125; 二分 12345678910int bsearch(int l,int r)&#123;while(l&lt;=r)&#123;int mid = l+r &gt;&gt;1;if(chekc(mid))r=mid-1;else l = mid + 1;&#125;return l - 1;&#125; 整数 浮点数 高精度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 高精度加法 a,b均为非负整数,下同string add(string a,string b) &#123; string c; int i = a.size()-1,j = b.size()-1,t = 0; while(i&gt;=0||j&gt;=0||t!=0) &#123; if(i&gt;=0) t += a[i--]-&#x27;0&#x27;; if(j&gt;=0) t += b[j--]-&#x27;0&#x27;; c += t%10+&#x27;0&#x27;; t/=10; &#125; return string(c.rbegin(),c.rend());// or reverse(c.begin(),c.end());&#125;// 高精度减法int cmp(string a,string b);string sub(string a,string b) &#123; if(cmp(a,b)==0) return &quot;0&quot;; if(cmp(a,b)==-1) &#123; cout&lt;&lt;&quot;-&quot;; return sub(b,a); &#125; string c; int i = a.size()-1,j = b.size()-1,t = 0; while(i&gt;=0||j&gt;=0||t!=0) &#123; t = a[i--] - t - &#x27;0&#x27;; if(j&gt;=0) t-=b[j--] - &#x27;0&#x27;; c += (t+10)%10 + &#x27;0&#x27;; t = t&lt;0? 1: 0; &#125; while(c.size()&gt;1&amp;&amp;*c.rbegin()==&#x27;0&#x27;) c.erase(c.size()-1); return string(c.rbegin(),c.rend());&#125;// 高精度乘法string mul(string a,int b) &#123; if(a==&quot;0&quot;||b==0) return &quot;0&quot;; string c; int i = a.size()-1,t = 0; while(i&gt;=0||t!=0) &#123; if(i&gt;=0) t+= (a[i--]-&#x27;0&#x27;)*b; c += t%10+&#x27;0&#x27;; t/=10; &#125; return string(c.rbegin(),c.rend());&#125;// 高精度除法string div(string a, int b, int&amp; r) &#123; string c; r = 0; for (int i = 0; i &lt; a.size(); i++) &#123; r = r * 10 + a[i] - &#x27;0&#x27;; c += r / b + &#x27;0&#x27;; r %= b; &#125; while (c.size() &gt; 1 &amp;&amp; c[0] == &#x27;0&#x27;) c.erase(0, 1); return c;&#125;int cmp(string a,string b) &#123; return a==b?0:a.size()&gt;b.size()?1:a.size()&lt;b.size()?-1:a&gt;b?1:-1; // 这句话和下面注释内容等价 // if(a==b) return 0; // if(a.size()&gt;b.size()) return 1; // if(a.size()&lt;b.size()) return -1; // return a&gt;b? 1 : -1;&#125; 前缀和与差分 前缀和 一维 前缀和类似于高中的数组,在求数组前n项和,n~m项和的时候,我们可以使用Sn(前n项和的方式去求出我们所需要部分的长度) S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] 二维 意思同一维 代表求一个面积内某个坐标所对应点的面积 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 差分 -一维-二维 双指针算法 位运算 离散化 补 1234567891011121314151617vector&lt;int&gt; alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置&#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1; // 映射到1, 2, ...n&#125; 区间合并 数据结构 链表与邻接表:树与图的存储 栈和队列 kmp Trie树 12345678910111213141516171819202122232425262728293031int son[N][26], cnt[N], idx;// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量// 插入一个字符串void insert(char *str)&#123; int p = 0; for (int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; &#125; cnt[p] ++ ;&#125;// 查询字符串出现的次数int query(char *str)&#123; int p = 0; for (int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p];&#125; 并查集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970(1)朴素并查集： int p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b);(2)维护size的并查集： int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; size[i] = 1; &#125; // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);(3)维护到祖宗节点距离的并查集： int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) &#123; if (p[x] != x) &#123; int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; &#125; return p[x]; &#125; // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; d[i] = 0; &#125; // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆 12345678910111213141516171819202122232425262728293031323334353637// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;// 交换两个点，及其映射关系void heap_swap(int a, int b)&#123; swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u)&#123; int t = u; if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) &#123; heap_swap(u, t); down(t); &#125;&#125;void up(int u)&#123; while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) &#123; heap_swap(u, u / 2); u &gt;&gt;= 1; &#125;&#125;// O(n)建堆for (int i = n / 2; i; i -- ) down(i); Hash表 模拟散列表 12345678910111213141516171819202122232425262728293031323334353637(1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) &#123; int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; &#125; // 在哈希表中查询某个数是否存在 bool find(int x) &#123; int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; &#125;(2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) &#123; int t = (x % N + N) % N; while (h[t] != null &amp;&amp; h[t] != x) &#123; t ++ ; if (t == N) t = 0; &#125; return t; &#125; 字符串哈希 12345678910111213141516171819核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64// 初始化p[0] = 1;for (int i = 1; i &lt;= n; i ++ )&#123; h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P;&#125;// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125; STL技巧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序pair&lt;int, string&gt; p=make_pair(x,xx);//可以是数字也可以是字符串 pair&lt;int , pair&lt;int , int&gt;&gt;p; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串 string a=&quot;lzzzzzz&quot;; size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址queue, 队列 queue&lt;int&gt; q; q=queue&lt;int&gt;(); size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素priority_queue, 优先队列，默认是大根堆 priority_queue&lt;int&gt; heap; size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] //随机选取set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱(前一个数)和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap exp:map&lt;string,int&gt;a a[&quot;lzz&quot;]=1; cout&lt;&lt;a[&quot;lzz&quot;] -&gt;1 insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，--bitset, 圧位 bitset&lt;10000&gt; s; ~, &amp;, |, ^ &gt;&gt;, &lt;&lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 vector遍历 搜索与图论 DFS与BFS DFS N皇后问题 第一种解法dfs BFS 树与图 存储 1234567891011121314// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;// n个链表的链表头 结点的值是多少 每个节点的next值是多少 // 添加一条边a-&gt;bvoid add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; //&#125;// 初始化idx = 0;memset(h, -1, sizeof h); 遍历 dfs 12345678910int dfs(int u)&#123; st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i];//当前链表里的节点对应图里的编号 if (!st[j]) dfs(j); &#125;&#125; bfs 12345678910111213141516171819queue&lt;int&gt; q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size())&#123; int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; st[j] = true; // 表示点j已经被遍历过 q.push(j); &#125; &#125;&#125; 最短路 最小生成树 二分图：染色法、匈牙利算法 Math More 质数 约数 欧拉函数 快速幂 扩展欧几里得算法 中国剩余定理 高斯消元 组合计数 容斥原理 简单博弈论 动态规划 背包问题 01背包 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n;//所有物品个数int m;//背包容量int v[N], w[N];//v表示体积,w表示价值int f[N][N];//表示所有的状态int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i=1; i&lt;=n; i++) for (int j = 1; j &lt;= m; j++) &#123; f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); &#125; cout &lt;&lt; f[n][m]; return 0;&#125;//转化成一维//f(i)只用到了f(i-1)这层 int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i=1; i&lt;=n; i++) for (int j = m; j &gt;= v[i]; j--) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; cout &lt;&lt; f[m]; return 0;&#125; 完全背包 12345678910111213141516171819202122232425262728293031323334353637//朴素做法#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1010;int n,m;int v[N],w[N];int f[N][n];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for (int i = 1; i &lt;= n; i ++ ) cin &gt; v[i] &gt;&gt;w[i]; for (int i = 1; i &lt;= n; i ++ ) for (int j = 0; j &lt;= m; j ++ ) for (int k =0; k * v[i] &lt;= j; k ++ ) f[i][j] = max(f[i][j]，f[i - 1][j - v[i]* k] + w[i] * k); cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125;//优化成二维for (int i = 1; i &lt;= n; i ++ ) cin &gt; v[i] &gt;&gt;w[i]; for (int i = 1; i &lt;= n; i ++ ) for (int j = 0; j &lt;= m; j ++ ) &#123; f[i][j]=f[i-1][j]; if(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); &#125;//优化成一维int f[N];for (int i = 1; i &lt;= n; i ++ ) for (int j = v[i]; j &lt;= m; j ++ ) &#123; f[j]=max(f[j],f[j-v[i]]+w[i]); &#125; 完全背包 暴力 12345678```## 线性DP### 数字三角形 给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 输入格式 第一行包含整数n，表示数字三角形的层数。 接下来n行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。 输出格式 输出一个整数，表示最大的路径数字和。 数据范围 1 ≤ n ≤ 500, −10000 ≤ 三角形中的整数 ≤ 10000 输入样例： 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 输出样例： 30 ![](https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220326165232.png) ### 最长上升子序列 ![](https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220326165740.png) ![](https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220327011837.png) ## 区间DP ### 石子合并 ![](https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220327022354.png) ![](https://cdn.jsdelivr.net/gh/zhezheup/picture-house/20220327024625.png) ## 计数类DP ## 数位统计DP ## 状态压缩DP ## 树形DP ## 记忆化搜索 # 贪心 # 时空复杂度","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://blogs.leechee.top/categories/DataStructure/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blogs.leechee.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://blogs.leechee.top/tags/%E6%8E%92%E5%BA%8F/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.leechee.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Ubuntu20.04美化","slug":"Ubuntu美化","date":"2022-02-13T15:21:13.000Z","updated":"2023-01-11T01:58:45.436Z","comments":true,"path":"posts/7eea43f6/","link":"","permalink":"https://blogs.leechee.top/posts/7eea43f6/","excerpt":"","text":"[TOC] 主题https://www.pling.com/s/Gnome 扩展https://extensions.gnome.org/ 配置 登陆 Ubuntu 账号，开启 Livepatch 功能 点击 Ubuntu Single-On 就会弹出登陆页面了，这里也可以先不登陆，直接点击跳过，后面再登陆。 也可以通过在已安装软件列表里面搜索 Software &amp; Updates 软件，如下图，打开后登陆 Ubuntu 账号。 这里有问题,先不看 美化 安装必要软件 12345sudo apt install gnome-tweak-toolsudo apt-get install gnome-shell-extensions删掉原来的ubuntu-dock (emmmm)sudo apt-get autoremove --purge gnome-shell-extension-ubuntu-dock -y 用浏览器打开扩展插件商店，地址：https://extensions.gnome.org/ 下载主题McMojave https://www.gnome-look.org/p/1275087/ icon theme https://www.gnome-look.org/s/Gnome/p/1348081 自己找 然后解压放在/usr/share/themes和icons下面 然后在gnome里面使用就可以","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.leechee.top/categories/Linux/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://blogs.leechee.top/tags/%E8%AE%B0%E5%BD%95/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blogs.leechee.top/tags/ubuntu/"}]},{"title":"ROS1","slug":"ros基础","date":"2022-02-05T15:21:13.000Z","updated":"2023-01-11T01:58:22.873Z","comments":true,"path":"posts/f85532d9/","link":"","permalink":"https://blogs.leechee.top/posts/f85532d9/","excerpt":"","text":"[TOC] 小记 12345678910111213-如何移植别人的工程:在根目录 catkin_make 后 ,会报错,然后修改的地方在build里,需要更改Cmake.txt以及 Makefile ,再补上所需要的依赖,就可以了安装依赖:rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y #自己修改rosdep install --from-paths ~/catkin_ws/src --ignore-src -r------- NEW 123source /opt/ros/noetic/setup.bashecho &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 常见操作指令 查找： rosc/roscd：切换当前工作目录到ros的某个程序包 rosls：按程序包的名称执行ls命令 catkin_ctreate_pkg：创建功能包 catkin_make：编译ROS工作空间，该src空间下所有程序包以及其子包都会被编译 roscore：启动管理器 rosrun：运行ROS程序包中的可执行文件 roslaunch：启动roscore，本地结点和远程结点，设置服务器参数（ssh） roslaunch package_name filename.launch：启动包中的一个文件 rospack：获取程序包有关信息 rospack find：返回程序包的路径 rospack list：获取所有的程序包 rosdep：rosdep install package_name 可以下载安装ROS 程序包所需要的系统依赖项 roswtf：可以检查ROS系统并尝试发现问题 rostopic -h：查看所有Topic操作 rostopic list：获取所有的Topic列表 rosrun rqt_plot rqt_plot：图形化显示Topic rostopic echo ‘topic namae’：查看某个Topic的信息 video 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102catkin_create_pkg usb_cam std_msgs roscpp cv_bridge sensor_msgs image_transport img_publisher.cpp#include &lt;ros/ros.h&gt;#include &lt;image_transport/image_transport.h&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/calib3d.hpp&gt;#include &lt;cv_bridge/cv_bridge.h&gt;#include &lt;iostream&gt; int main(int argc, char** argv)&#123; ros::init(argc, argv, &quot;img_publisher&quot;); ros::NodeHandle nh; image_transport::ImageTransport it(nh); image_transport::Publisher pub = it.advertise(&quot;camera/image&quot;, 1); cv::VideoCapture cap; cv::Mat frame; int deviceID=0; if(argc&gt;1) deviceID=argv[1][0]-&#x27;0&#x27;; int apiID=cv::CAP_ANY; cap.open(deviceID+apiID); if(!cap.isOpened())&#123; std::cerr&lt;&lt;&quot;ERROR! Unable to open camera&quot;&lt;&lt;std::endl; return -1; &#125; ros::Rate loop_rate(30); while (nh.ok()) &#123; cap.read(frame); if(!frame.empty())&#123; sensor_msgs::ImagePtr msg = cv_bridge::CvImage(std_msgs::Header(), &quot;bgr8&quot;, frame).toImageMsg(); pub.publish(msg); &#125; ros::spinOnce(); loop_rate.sleep(); &#125; return 0;&#125;img_viewer.cpp#include &lt;ros/ros.h&gt;#include &lt;image_transport/image_transport.h&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;cv_bridge/cv_bridge.h&gt; void imageCallback(const sensor_msgs::ImageConstPtr&amp; msg)&#123; try &#123; cv::imshow(&quot;view&quot;, cv_bridge::toCvShare(msg, &quot;bgr8&quot;)-&gt;image); &#125; catch (cv_bridge::Exception&amp; e) &#123; ROS_ERROR(&quot;Could not convert from &#x27;%s&#x27; to &#x27;bgr8&#x27;.&quot;, msg-&gt;encoding.c_str()); &#125;&#125; int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;img_viewer&quot;); ros::NodeHandle nh; cv::namedWindow(&quot;view&quot;); cv::startWindowThread(); image_transport::ImageTransport it(nh); image_transport::Subscriber sub = it.subscribe(&quot;camera/image&quot;, 1, imageCallback); ros::spin(); cv::destroyWindow(&quot;view&quot;); return 0;&#125;find_package(catkin REQUIRED COMPONENTS cv_bridge image_transport roscpp sensor_msgs std_msgs)find_package(OpenCV REQUIRED) include_directories( $&#123;catkin_INCLUDE_DIRS&#125; $&#123;OpenCV_INCLUDE_DIRS&#125;) add_executable(img_publisher src/img_publisher.cpp)add_executable(img_viewer src/img_viewer.cpp) target_link_libraries(img_publisher $&#123;catkin_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;)target_link_libraries(img_viewer $&#123;catkin_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;) &lt;build_depend&gt;opencv2&lt;/build_depend&gt;&lt;build_export_depend&gt;opencv2&lt;/build_export_depend&gt;&lt;exec_depend&gt;opencv2&lt;/exec_depend&gt; https://github.com/thinkexist1989/ROS-Academy-for-Beginners/tree/noetic","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.leechee.top/categories/Linux/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://blogs.leechee.top/tags/%E8%AE%B0%E5%BD%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blogs.leechee.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"ROS机器人","slug":"ROS机器人","permalink":"https://blogs.leechee.top/tags/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/"}]},{"title":"C++基础再学习","slug":"Cplus补充","date":"2022-02-01T15:21:13.000Z","updated":"2023-01-11T01:24:42.566Z","comments":true,"path":"posts/fd31ca55/","link":"","permalink":"https://blogs.leechee.top/posts/fd31ca55/","excerpt":"","text":"C基础再学习 PS:之前学了一点,不过只在opencv简单使用,算法题和面试题,包括ROS等,随着python的不断壮大,python似乎是更好用的工具.不过C还是挺重要的,对于嵌入式领域还是需要的. [TOC] 枚举类型 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓&quot;枚举&quot;是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： 123456enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数]&#125; 枚举变量; 如果枚举没有初始化, 即省掉&quot;=整型常数&quot;时, 则从第一个标识符开始。 例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。 12enum color &#123; red, green, blue &#125; c;c = blue; 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。 enum color &#123; red, green=5, blue &#125;; 在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。 整数常量 123456785 // 十进制0213 // 八进制 0x4b // 十六进制 30 // 整数 30u // 无符号整数 30l // 长整数 30ul // 无符号长整数 类型限定符 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 C++存储类 auto(c++17开始弃用) 自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 C98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C17 中已删除这一用法。 根据初始化表达式自动推断被声明的变量的类型，如： 1234auto f=3.14; //doubleauto s(&quot;hello&quot;); //const char*auto z = new auto(9); // int*auto x1 = 5, x2 = 5.0, x3=&#x27;r&#x27;;//错误，必须是初始化为同一类型 register(c++17开始弃用) register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。 &#123; register int miles; &#125; 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 static存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。 1234567891011121314151617181920212223#include &lt;iostream&gt; // 函数声明 void func(void); static int count = 10; /* 全局变量 */ int main()&#123; while(count--) &#123; func(); &#125; return 0;&#125;// 函数定义void func( void )&#123; static int i = 5; // 局部静态变量 i++; std::cout &lt;&lt; &quot;变量 i 为 &quot; &lt;&lt; i ; std::cout &lt;&lt; &quot; , 变量 count 为 &quot; &lt;&lt; count &lt;&lt; std::endl;&#125; 当上面的代码被编译和执行时，它会产生下列结果： extern存储类 extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示： 第一个文件：main.cpp 12345678910#include &lt;iostream&gt; int count ;extern void write_extern(); int main()&#123; count = 5; write_extern();&#125; 第二个文件：support.cpp 12345678#include &lt;iostream&gt; extern int count; void write_extern(void)&#123; std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;&#125; 这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示： 1$ g++ main.cpp support.cpp -o write 这会产生 write 可执行程序，尝试执行 write，它会产生下列结果： 12$ ./writeCount is 5 mutable存储类 mutable 说明符仅适用于类的对象.它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 thread_local (C++11)存储类 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。 thread_local 说明符可以与 static 或 extern 合并。 可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。 以下演示了可以被声明为 thread_local 的变量： 1234567891011thread_local int x; // 命名空间下的全局变量class X&#123; static thread_local std::string s; // 类的static成员变量&#125;;static thread_local std::string X::s; // X::s 是需要定义的 void foo()&#123; thread_local std::vector&lt;int&gt; v; // 本地变量&#125; Lambda 函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下: 1[capture](parameters)-&gt;return-type&#123;body&#125; 例如： 1[](int x, int y)&#123; return x &lt; y ; &#125; 如果没有返回值可以表示为： 1[capture](parameters)&#123;body&#125; 例如： 1[]&#123; ++global_x; &#125; 在一个更为复杂的例子中，返回类型可以被明确的指定如下： 1[](int x, int y) -&gt; int &#123; int z = x + y; return z + x; &#125; 本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。 如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定： 123456[] // 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;] // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入： 1[this]() &#123; this-&gt;someFunc(); &#125;(); 字符串 数组类型 字符串实际上是使用 null 字符 \\0 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 其实，不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 \\0 放在字符串的末尾。 C++ 中有大量的函数用来操作以 null 结尾的字符串: 序号 函数 &amp; 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如: string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2; 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 #include &lt;cstring&gt; String类型 关于面向对象: exampl: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; int main ()&#123; string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2 str3 = str1 + str2; cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度 len = str3.size(); cout &lt;&lt; &quot;str3.size() : &quot; &lt;&lt; len &lt;&lt; endl; return 0;&#125; 123str3 : runoobstr1 + str2 : runoobgooglestr3.size() : 12 C++引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 和指针的区别: 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如： 1int i = 17; 我们可以为 i 声明引用变量，如下所示： 12int&amp; r = i;double&amp; s = d; 在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用： 123456789101112131415161718192021222324#include &lt;iostream&gt; using namespace std; int main ()&#123; // 声明简单的变量 int i; double d; // 声明引用变量 int&amp; r = i; double&amp; s = d; i = 5; cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r &lt;&lt; endl; d = 11.7; cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s &lt;&lt; endl; return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1234Value of i : 5Value of i reference : 5Value of d : 11.7Value of d reference : 11.7 引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念： 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 I/O 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 延申待补充… C++面向对象 C++高级","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://blogs.leechee.top/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blogs.leechee.top/tags/C-C/"},{"name":"语言","slug":"语言","permalink":"https://blogs.leechee.top/tags/%E8%AF%AD%E8%A8%80/"}]},{"title":"日常效率Tips","slug":"Normal Tips","date":"2022-01-10T15:21:13.000Z","updated":"2023-01-13T03:27:25.157Z","comments":true,"path":"posts/6c0c8dda/","link":"","permalink":"https://blogs.leechee.top/posts/6c0c8dda/","excerpt":"","text":"Github 替换github.com 为 hub.fastgit.org Vim 批量替换: :%s/abc/123/g c (用c可以确认是否替换) 编辑文件:(默认模式下) 指令 描述 i 在当前光标所在字符的前面，转为编辑模式。 I 在当前光标所在行的行首转换为编辑模式。 a 在当前光标所在字符的后面，转为编辑模式。 A 在光标所在行的行尾，转换为编辑模式。 o 在当前光标所在行的下方，新建一行，并转为编辑模式。 O 在当前光标所在行的上方，新建一行，并转为编辑模式。 查找: /xxx n 在同一个方向重复上一次搜索命令 N 在反方向重复上一次搜索命令 选中 单词开头或者结尾 (在v模式下) 按e进行选择 Linux 配置ssh sudo apt install openssh-server service ssh start 重新连接Ubuntu联网指令： sudo /etc/init.d/network-manager restart 重新挂载共享文件夹 sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000 搜wifi: sudo iw dev wlan0 scan | grep SSID 交叉编译树莓派gcc： arm-linux-gnueabihf-gcc 树莓派安全关机： sudo shutdown -h now 树莓派重启： sudo reboot 树莓派传输文件使用fillzeila：前面加上 sftp:// 树莓派拍照： raspistill -o image.jpg 监控 :8080 安装软件: ``sudo dpkg -itar xvf xxx **Linux查看pdf：**zathura **LINUX解压文件：**tar xvf xxx` 摄像头推流： /usr/local/bin/mjpg_streamer -i &quot;/usr/local/lib/mjpg-streamer/input_uvc.so -n -f 30 -r 1280x720&quot; -o &quot;/usr/local/lib/mjpg-streamer/output_http.so -p 8080 -w /usr/local/share/mjpg-streamer/www&quot; 临时路径： export LD_LIBRARY_PATH=/home/lz/face/samplecode/ASFTestDemo/linux_so/:$LD_LIBRARY_PATH opencv: 编译时 加 pkg-config --cflags --libs opencv 云服务器 防火墙操作 firewall-cmd --list-all 列出所有端口号白名单 firewall-cmd --add-port=8888/tcp --permanent 添加一个8888端口为白名单 firewall-cmd --reload 更新防火墙操作 Windows 百度文库下载: 网址baidu后面加三个v Typora+七牛云配置: 12345678910111213141516&#123; &quot;picBed&quot;: &#123; &quot;uploader&quot;: &quot;qiniu&quot;, &quot;qiniu&quot;: &#123; &quot;accessKey&quot;: &quot;&quot;, &quot;secretKey&quot;: &quot;&quot;, &quot;bucket&quot;: &quot;&quot;, // 存储空间名 &quot;url&quot;: &quot;&quot;, // 自定义域名 &quot;area&quot;: &quot;&quot;, // 存储区域编号 &quot;options&quot;: &quot;&quot;, // 网址后缀，比如？imgslim &quot;path&quot;: &quot;img/&quot; // 自定义存储路径，比如 img/ &#125; &#125;, &quot;picgoPlugins&quot;: &#123;&#125;&#125; pyhton conda install 问题 终端中输入代码： 1conda config --add channels conda-forge 再通过conda或者pip安装自己需要的包就不会再出问题了。 注意channel不一定是conda-forge，根据你需要安装包的类型，具体包属于那个类型可以通过代码来查看： 1anaconda search -t conda 要安装的包 当然啦如果你需要安装的包比较少也可以直接按照上面给出链接的博客方法进行操作 conda activate tensorflow conda create -n tensorflow python=3.8.5 Windows pip install 1pip install 包名 -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com 下载问题 CSDN 使用: f12 conslo 输入 1234567891011121314151617181920212223242526272829303132333435363738394041// 将主要内容移动到 body$(&quot;body&quot;).prepend($(&quot;main&quot;)); // 移除掉body中的其他节点// 不移除脚本和 style 是因为要保持样式$.each($(&quot;body&quot;).children(), function(index, obj) &#123; var tag = obj.tagName; if (!(tag==&quot;MAIN&quot; || tag==&quot;SCRIPT&quot; || tag==&quot;STYLE&quot;)) &#123; obj.remove(); &#125; &#125;); // 内容宽度为页面的100% $(&quot;main&quot;).css(&quot;width&quot;, &quot;100%&quot;);// 移除掉用户信息工具栏$(&quot;#toolBarBox&quot;).remove();//如果有专栏，去掉专栏if ( $(&quot;#blogColumnPayAdvert&quot;).length &gt; 0 )&#123; $(&quot;#blogColumnPayAdvert&quot;).remove();&#125;//去掉作者栏$(&quot;.article-info-box&quot;).remove();//除去相关推荐对你有帮助吗栏$(&quot;#recommendNps&quot;).remove();//除去评价栏$(&quot;#pcCommentBox&quot;).remove();//除去底部$(&quot;.template-box&quot;).remove();$(&quot;.blog-footer-bottom&quot;).remove();$(&quot;.recommend-box&quot;).remove();//如果有链接元素，循环点击图片链接if ( $(&quot;.look-more-preCode&quot;).length &gt; 0 )&#123; $.each($(&quot;.look-more-preCode&quot;), function(index, obj) &#123; obj.click();&#125;);&#125; // 进行打印，保存PDF// 设置 500 毫秒等待时间是因为要等待页面设置完成// 否则页面可能会有部分样式没有加载出来setTimeout(function()&#123;window.print()&#125;, 500);","categories":[{"name":"Tips","slug":"Tips","permalink":"https://blogs.leechee.top/categories/Tips/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blogs.leechee.top/tags/C-C/"},{"name":"Tips","slug":"Tips","permalink":"https://blogs.leechee.top/tags/Tips/"},{"name":"Windows","slug":"Windows","permalink":"https://blogs.leechee.top/tags/Windows/"},{"name":"Linux","slug":"Linux","permalink":"https://blogs.leechee.top/tags/Linux/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://blogs.leechee.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"记录","slug":"记录","permalink":"https://blogs.leechee.top/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"博客文章Title","slug":"文章Tips","date":"2022-01-01T15:21:13.000Z","updated":"2023-01-11T01:20:56.160Z","comments":true,"path":"posts/57b0fba5/","link":"","permalink":"https://blogs.leechee.top/posts/57b0fba5/","excerpt":"","text":"Front-matter 是markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。 Page Front-matter 用于頁面配置 Post Front-matter 用于文章頁配置 123456789101112131415---title:date:updated:type:comments:description:keywords:top_img:mathjax:katex:aside:aplayer:highlight_shrink:--- 笔记 12345678910111213141516171819202122232425262728293031323334353637383940414243444546---title:date:updated:tags:categories:keywords:description:top_img:comments:cover:缩略图toc:toc_number:toc_style_simple:copyright:copyright_author:copyright_author_href:copyright_url:copyright_info:mathjax:katex:aplayer:highlight_shrink:aside:---another:::::::::::::::::::---title: date: author: img: /medias/banner/7.jpgcoverImg: /medias/banner/7.jpgtop: truecover: truetoc: truepassword: 5f15b28ffe43f8be4f239bdd9b69af9d80dbafcb20a5f0df5d1677a120ae9110mathjax: truesummary: 自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要tags:- Hexo- Github- categories:- --- 新.md 12345678910111213141516171819202122232425262728293031---title: Copyright-beautify # 文章名称date: 2021-03-02 13:52:46 # 文章发布日期updated: 2021-03-02 13:52:46 # 文章更新日期copyright_author: Nesxc # 作者覆写copyright_url: #https://www.nesxc.com/post/hexocc.html # 原文链接覆写license: # 许可协议名称覆写license_url: # 许可协议链接覆写author: img: coverImg: top: falsecover: falsetoc: truemathjax: falsepassword:summary:tags:categories:sticky: 1 #置顶用 越大置顶优先级越大aside: false &lt;-- 关闭侧边栏title: 文章标题date: 创建日期updated: 更新日期cover: 文章封面description: 文章描述swiper_index: 1 #置顶轮播图顺序，需填非负整数，数字越大越靠前comments: false #关闭评论subtitle: 左上角显示description: 提示-&gt;左上角--- 其他 给 js 脚本加上 defer 和 ansyc 属性来实现异步加载，例如： 123bottom: - &lt;script defer https://unpkg.zhimg.com/vue@2.6.11&quot;&gt;&lt;/script&gt; - &lt;script async src=&quot;https://cdn.jsdelivr.net/gh/zjwo/CDN/js/pyq/pyq.min.js&quot;&gt;&lt;/script&gt;","categories":[{"name":"HexoPost","slug":"HexoPost","permalink":"https://blogs.leechee.top/categories/HexoPost/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blogs.leechee.top/tags/hexo/"},{"name":"post","slug":"post","permalink":"https://blogs.leechee.top/tags/post/"}]},{"title":"远程控制项目一些问题","slug":"远程控制项目问题","date":"2021-03-25T15:21:13.000Z","updated":"2023-01-11T01:23:12.161Z","comments":true,"path":"posts/8d1f2d1/","link":"","permalink":"https://blogs.leechee.top/posts/8d1f2d1/","excerpt":"","text":"[TOC] 项目开发 配置启动项为mianCRTstartup , 子系统为控制窗口格式 网络编程 初始Windows socket 设计类,main之前单线程执行 问题 如果声明的类被拿去声明变量怎么办? -&gt;单例 通过单例,很多初始化不用管,封装在单例里 类 静态成员 方法 需要this 静态方法没有this指针 因为是全局访问的 public 静态成员也一样 都是公用的(必须通过显式方式进行初始化) 网络: 包的封装 包的设计 : 很多个数据, 设定一到俩个字节的包头,用四个字节作为长度(太长的话保留四个字节),后面就是数据,一般用一到俩个字节作为一个命令,在包的最后保留俩个字节做一个校验 . 包头:固定的,比如FFFF \\ FFFE (因为不太常见) , 收到时,开始一个个去找,如果找不到就跳过 , (如果缓冲区有残留,那么残留的数据需要被跳过,就需要包头) , (嗅探包的原因,数据杂乱,渗透测试用) , (其他应用的误发). 然后读包长度,为了安全可以加校验(比如和校验,将包头和长度以外的数据都加起来,溢出的部分不要了,另外的比如CRC这种). 具体做法: 命令设计 驱动信息 目录信息 屏幕图像 鼠标处理 打开文件 下载文件 锁机 解锁 显示文字 删除文件 客户端开发 项目创建 控件布局 网络编程 消息设计 文件展示 图像显示 鼠标控制 其他功能 问题 单例模式: RALL机制 打包问题: #prama pack(push)问题 : exp: FFFE 07000000 0100 432C44 B300 包头:FFFE 07000000:整个长度 0100:命令俩个字节 文件驱动方式: 需求:处理文件 需要知道在哪个分区,makedriverinfo来回复 D:\\my_ws\\c_ws\\control_ws\\control_client\\ClientSocket.h(202) : atlTraceGeneral - m_sock : 192 D:\\my_ws\\c_ws\\control_ws\\control_client\\control_clientDlg.cpp(171) : atlTraceGeneral - Client Send ret 1 D:\\my_ws\\c_ws\\control_ws\\control_ws\\ServerSocket.h(161) : atlTraceGeneral - m_client = 188 D:\\my_ws\\c_ws\\control_ws\\control_ws\\control_ws.cpp(437) : atlTraceGeneral - Acceptclirnt return true D:\\my_ws\\c_ws\\control_ws\\control_ws\\ServerSocket.h(184) : atlTraceGeneral - recv len : 10 D:\\my_ws\\c_ws\\control_ws\\control_client\\ClientSocket.h(202) : atlTraceGeneral - m_sock : 556 D:\\my_ws\\c_ws\\control_ws\\control_client\\control_clientDlg.cpp(171) : atlTraceGeneral - Client Send ret 1 D:\\my_ws\\c_ws\\control_ws\\control_client\\control_clientDlg.cpp(173) : atlTraceGeneral - Client ack : -1 D:\\my_ws\\c_ws\\control_ws\\control_ws\\ServerSocket.h(161) : atlTraceGeneral - m_client = 508 D:\\my_ws\\c_ws\\control_ws\\control_ws\\control_ws.cpp(437) : atlTraceGeneral - Acceptclirnt return true D:\\my_ws\\c_ws\\control_ws\\control_ws\\ServerSocket.h(185) : atlTraceGeneral - recv len : 12 D:\\my_ws\\c_ws\\control_ws\\control_ws\\control_ws.cpp(439) : atlTraceGeneral - dealcommand ret : 12 困难: 设计的时候没有考虑周全关于文件执行 getfilepath只允许前几个 新加功能很麻烦 找错误很久 显示文件有丢失 断点发现发送没有问题 接收这边有问题 首先从设计上来讲一般没有什么问题,从俩方面下手,首先确保传输的数据是没有问题的,在服务端端加日志,打印了传输的数量并且打印了文件, 客户端一样 俩端去比对 如果数据没有问题 那就是显示有问题 : 结果是数据的问题 对不上号 count和包 , 开始调试, 不能调试就加日志, 一开始是index标志的问题 ,被覆盖 加了static没有用 , 又发现是buffer的问题, 另一个问题是服务端发完了,但是我这边接收端还有大量的数据 , 缓冲的数据还没有用完 ,所以当receive length为0的时候还不能结束,继续加条件,要缓冲也为0. 大文件传输解决 1 下载 : 耗时问题 为了避免很多时间卡住, 当窗口启动的时候是有一个线程的,线程主要是做一个循环,这个循环就叫做消息循环,包括点击文件下载都是消息循环,如果下载函数执行3s,那么整个消息循环都会被卡住3s,一直卡住,后面的消息就无法再处理了, 每个循环的开始首先是取消息,然后是处理消息,然后继续投递消息,无限制的去轮回, 长时间卡住就会死掉,所以为什么要加线程: 当初发的时候,会另外起一个线程去跑3s,而主线程消息循环并不受影响 那么在线程里面使用updatedata的时候,为什么会崩溃呢? 因为是在子线程去调用的,它会去验证是不是一个线程(是不是一致),断言,防止多线程去更改控件,所以哦我们使用了sendmessage,为什么它可以呢? sendmessage的原则是 ,我投递一个消息,投递到主线程,主线程去处理,所以在线程校验的时候会通过,然后给一个返回值, 不会崩掉. 2 自定义消息 : 自定义消息id , 每次+1 , (这是windwosAPI) ,","categories":[{"name":"Project","slug":"Project","permalink":"https://blogs.leechee.top/categories/Project/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://blogs.leechee.top/tags/%E8%AE%B0%E5%BD%95/"},{"name":"项目","slug":"项目","permalink":"https://blogs.leechee.top/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"心得","slug":"心得","permalink":"https://blogs.leechee.top/tags/%E5%BF%83%E5%BE%97/"}]},{"title":"嵌入式基础","slug":"嵌入式基础","date":"2021-02-01T15:21:13.000Z","updated":"2023-01-13T03:27:31.892Z","comments":true,"path":"posts/5c8c37e6/","link":"","permalink":"https://blogs.leechee.top/posts/5c8c37e6/","excerpt":"","text":"[TOC] 预览: 操作 ``/etc/init.d/rcS` 是6ull开发板的开机脚本文件 echo &quot;7 4 1 7&quot; &gt; /proc/sys/kernel/printk 开启内核打印信息 开发板挂载: mount -t nfs -o nolock,vers=3 192.168.2.125:/home/book/nfs_rootfs /mnt umount /mnt if busy NAT的话: mount -t nfs -o nolock,vers=3,port=2049,mountport=9999 192.x.x.x:/home/book/nfs_rootfs /mnt mount命令用来挂载各种支持的文件系统协议到某个目录下。 mount成功之后，开发板在/mnt目录下读写文件时，实际上访问的就是Ubuntu中的/home/book/nfs_rootfs目录，所以开发板和Ubuntu之间通过NFS可以很方便地共享文件。 在开发过程中，在Ubuntu中编译好程序后放入/home/book/nfs_rootfs目录，开发板mount nfs后就可以直接使用/mnt下的文件。 网络 123nmcli r wifi onnmcli dev wifinmcli dev wifi connect &quot;DRLyyds&quot; password &quot;19407010220&quot; ifname wlan0 官方 1234567891011121314151617181920212223242526移除GUI: mv /etc/init.d/S07hmi /root reboot重新加载驱动rmmod 8723bu.komodprobe 8723bu移除其它控制ps -ef | grep &quot;wpa&quot;292 root /usr/sbin/wpa_supplicant -ukill -9 292rm /etc/wpa_supplicant.conf3.执行wifi链接操作ifconfig wlan0 upiw dev wlan0 scan |grep SSID//wpa_passphrase HUAWEI zihezihe &gt;&gt; /etc/wpa_supplicant.conf-/etc/wpa_supplicant.confctrl_interface=/var/run/wpa_supplicantctrl_interface_group=0update_config=1network=&#123; ssid=&quot;DRLyyds&quot; psk=&quot;19407010220&quot;&#125;-wpa_supplicant -B -iwlan0 -c /etc/wpa_supplicant.confiw wlan0 linkudhcpc -i wlan0ping -I wlan0 www.baidu.com 设置交叉编译工具链: vim ~/.bashrc 永久生效 123export ARCH=armexport CROSS_COMPILE=arm-buildroot-linux-gnueabihf-export PATH=$PATH:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin 一些命令 udhcpc : 获取ip 用网线的时候用 make之后, 可以使用make menuconfig来查看命令 状况 然后make 100ask_imx6ull_pro_ddr512m_systemV_qt5_defconfig make all 编译成功后文件输出路径为 output/images 1234567891011121314151617181920212223buildroot2020.02.x ├── output​ ├── images ​ ├── 100ask_imx6ull-14x14.dtb &lt;--设备树文件 ​ ├── rootfs.ext2 &lt;--ext2格式根文件系统​ ├── rootfs.ext4 -&gt; rootfs.ext2 &lt;--ext2格式根文件系统 ​ ├── rootfs.tar ​ ├── rootfs.tar.bz2 &lt;--打包并压缩的根文件系统，用于NFSROOT启动​ ├── 100ask-imx6ull-pro-512d-systemv-v1.img &lt;--完整的系统镜像(可以用来烧写emmc和sd卡)​ ├── u-boot-dtb.imx &lt;--u-boot镜像​ └── zImage &lt;--内核镜像 烧写裸机文件: imx是烧写EMMC, img是烧写到sdCard parsec 入门 Linux启动流程 IMX6ULL启动流程 reset 开发板复位启动 -&gt; rom 板子只读内存 -&gt;加载UBOOT 去加载 第一段bootloader引导程序 -&gt; uboot里有启动参数(环境变量)来启动kernel -&gt; kernel + dtb 设备树 -&gt; 启动Rootfs 跟文件系统 -&gt; app 使用mount挂载 mount -t nfs -o nolock,vers=3 192.168.2.125:/home/book/nfs_rootfs /mnt mount -t nfs -o intr,nolock,rsize=1024,wsize=1024 192.168.2.125:/home/book/nfs_rootfs /mnt 挂载ubuntu的nfs目录到开发板/mnt目录下，挂载成功后使用df -h命令查看所有挂载。 编译内核镜像-设备树 编译内核模块-&gt;nfs挂载-&gt;传输到开发板 reboot即可使用新的 zImage镜像 *.dtb设备树 /lib/modules模块 编译UBOOT make distclean 删除之前缓存 -&gt; make mx6ull_14x14_evk_defconfig -&gt; make Linux shell会去环境变量读取 可以通过echo SPATH 查看 ls: -l(long 显示完整信息) -a(显示隐藏文件) -h(列出大小) cp: r：recursive，递归地，即复制所有文件 f：force，强制覆盖 d：如果源文件为链接文件，也只是把它作为链接文件复制过去，而不是复制实际文件 rm: r：recursive，递归地，即删除所有文件 f：force，强制删除 12345678910111213141516171819chgrp：改变文件所属用户组 -R : 进行递归的持续更改，也连同子目录下的所有文件、目录都更新成为这个用户组之意。常常用在更改 某一目录内所有文件的情况。chown：改变文件所有者chmod：改变文件的权限 r: 4或0 ② w: 2或0 ③ x: 1或0 这3种权限的取值相加后，就是权限的数字表示。 例如：文件a的权限为“-rwxrwx---”，它的数值表示为： ① owner = rwx = 4+2+1 = 7 ② group = rwx = 4+2+1 = 7 ③ others = --- = 0+0 +0 = 0 使用u、g、o三个字母代表user、group、others 3中身份。此外a代表all，即所有身份。 范例： chmod u=rwx,go=rx .bashrc 也可以增加或去除某种权限，“+”表示添加权限，“-”表示去除权限： chmod a+w .bashrc chmod a-x .bashrc 查找\\搜索命令 find find 目录名 选项 查找条件 用来查找文件 例: find /home/book/dira/ -name &quot; test1.txt &quot; ! - 查找最近几天(几个小时)之内(之前)有变动的文件 $ find /home/book -mtime -2 //查找/home目录下两天内有变动的文件。 grep grep命令的作用是查找文件中符合条件的字符串，其格式如下： grep [选项] [查找模式] [文件名] grep -rn &quot;字符串&quot; 文件名 r(recursive)：递归查找 n(number)：显示目标位置的行号 可以加入-w全字匹配。 1234可以在grep的结果中再次执行grep搜索，比如搜索包含有ABC的头文件，可执行如下命令：$ grep “ABC” * -nR | grep “\\.h”上述命令把第1个命令“grep “ABC” * -nR”通过管道传给第2个命令。即第2个命令在第1个命令的结果中搜索。 vi 学习见 -&gt; 日常技巧 查找命令或应用程序的所在位置 which pwd //定位到/bin/pwd whereis pwd //可得到可执行程序的位置和手册页的位置 GCC GCC 编译选项 常用选项 描述 -E 预处理，开发过程中想快速确定某个宏可以使用“-E -dM” -c 把预处理、编译、汇编都做了，但是不链接 -o 指定输出文件 -I 指定头文件目录 -L 指定链接时库文件目录 -l 指定链接哪一个库文件 其他有用的选项: 12345gcc -E main.c // 查看预处理结果，比如头文件是哪个gcc -E -dM main.c &gt; 1.txt // 把所有的宏展开，存在1.txt里gcc -Wp,-MD,abc.dep -c -o main.o main.c // 生成依赖文件abc.dep，后面Makefile会用echo &#x27;main()&#123;&#125;&#x27;| gcc -E -v - // 它会列出头文件目录、库目录(LIBRARY_PATH) 制作, 使用动态库 | 静态库 123456789101112131415161718192021动态库:制作、编译：gcc -c -o main.o main.cgcc -c -o sub.o sub.cgcc -shared -o libsub.so sub.o sub2.o sub3.o(可以使用多个.o生成动态库)gcc -o test main.o -lsub -L /libsub.so/所在目录/运行：① 先把libsub.so放到Ubuntu的/lib目录，然后就可以运行test程序。② 如果不想把libsub.so放到/lib，也可以放在某个目录比如/a，然后如下执行：export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/a ./test静态库:gcc -c -o main.o main.cgcc -c -o sub.o sub.car crs libsub.a sub.o sub2.o sub3.o(可以使用多个.o生成静态库)gcc -o test main.o libsub.a (如果.a不在当前目录下，需要指定它的绝对或相对路径)运行：不需要把静态库libsub.a放到板子上。注意:执行arm-linux-gnueabihf-gcc -c -o sub.o sub.c交叉编译需要在最后面加上 -fPIC参数。 GCC编译过程 （1）预处理 C/C++源文件中，以“#”开头的命令被称为预处理命令，如包含命令“#include”、宏定义命令“#define”、条件编译命令“#if”、“#ifdef”等。预处理就是将要包含(include)的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码，最后将这些东西输出到一个“.i”文件中等待进一步处理。 （2）编译 编译就是把C/C++代码(比如上述的“.i”文件)“翻译”成汇编代码，所用到的工具为cc1(它的名字就是cc1，x86有自己的cc1命令，ARM板也有自己的cc1命令)。 （3）汇编 汇编就是将第二步输出的汇编代码翻译成符合一定格式的机器代码，在Linux系统上一般表现为ELF目标文件(OBJ文件)，用到的工具为as。x86有自己的as命令，ARM版也有自己的as命令，也可能是xxxx-as（比如arm-linux-as）。 “反汇编”是指将机器代码转换为汇编代码，这在调试程序时常常用到。 （4）链接 链接就是将上步生成的OBJ文件和系统库的OBJ文件、库文件链接起来，最终生成了可以在特定平台运行的可执行文件，用到的工具为ld或collect2。 编译过程常用选项: 常用选项 描述 -E 预处理，开发过程中想快速确定某个宏可以使用“-E -dM” -c 把预处理、编译、汇编都做了，但是不链接 -o 指定输出文件 -I 指定头文件目录 -L 指定链接时库文件目录 -l 指定链接哪一个库文件 总体选项 （1）-c 预处理、编译和汇编源文件，但是不作链接，编译器根据源文件生成OBJ文件。缺省情况下，GCC通过用’.o’替换源文件名的后缀’.c’，‘.i’，`.s’等，产生OBJ文件名。可以使用-o选项选择其他名字。GCC忽略-c选项后面任何无法识别的输入文件。 （2）-S 编译后即停止，不进行汇编。对于每个输入的非汇编语言文件，输出结果是汇编语言文件。缺省情况下，GCC通过用`.s’替换源文件名后缀 ‘.c’，'.i’等等，产生汇编文件名。可以使用-o选项选择其他名字。GCC忽略任何不需要汇编的输入文件。 （3）-E 预处理后即停止，不进行编译。预处理后的代码送往标准输出。 （4）-o file 指定输出文件为file。无论是预处理、编译、汇编还是链接，这个选项都可以使用。如果没有使用-o 选项，默认的输出结果是：可执行文件为a.out；修改输入文件的名称是source.suffix，则它的OBJ文件是source.o，汇编文件是 source.s，而预处理后的C源代码送往标准输出。 （5）-v 显示制作GCC工具自身时的配置命令；同时显示编译器驱动程序、预处理器、编译器的版本号。 Makefile demo: 1234hello: hello.cgcc -o hello hello.cclean:rm -f hello 完善Makefile 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253第1个Makefile，简单粗暴，效率低：test : main.c sub.c sub.h gcc -o test main.c sub.c第2个Makefile，效率高，相似规则太多太啰嗦，不支持检测头文件：test : main.o sub.o gcc -o test main.o sub.omain.o : main.c gcc -c -o main.o main.csub.o : sub.c gcc -c -o sub.o sub.c clean: rm *.o test -f第3个Makefile，效率高，精炼，不支持检测头文件：test : main.o sub.o gcc -o test main.o sub.o%.o : %.c //%是通配符 gcc -c -o $@ $&lt;clean: rm *.o test -f第4个Makefile，效率高，精炼，支持检测头文件(但是需要手工添加头文件规则)：test : main.o sub.o gcc -o test main.o sub.o%.o : %.c gcc -c -o $@(代表目标文件) $&lt;(代表第一个依赖)sub.o : sub.hclean: rm *.o test -f第5个Makefile，效率高，精炼，支持自动检测头文件：objs := main.o sub.otest : $(objs) gcc -o test $^(表示所有的依赖)# 需要判断是否存在依赖文件# .main.o.d .sub.o.ddep_files(依赖文件) := $(foreach f, $(objs), .$(f).d)dep_files := $(wildcard $(dep_files))# 把依赖文件包含进来ifneq ($(dep_files),) (如果这个变量不等于空) include $(dep_files)endif%.o : %.c gcc -Wp,-MD,.$@.d -c -o $@ $&lt;clean: rm *.o test -fdistclean: rm $(dep_files) *.o test -f ----CFLAGS(编译参数) = -Werr (把所有警告都当作错误) -I(指定头文件目录) . -Iinclude(默认头文件目录) **假想目标 : ** .PHONY **即时变量 延时变量 : ** export A := xxx 定义时就确定 B = xxx 使用时才确定 ?= 延时变量 只有在第一次定义才起效 += 是即时还是延时取决于前面的定义 函数 1234目标(target)…: 依赖(prerequiries)…&lt;tab&gt;命令(command)如果“依赖文件”比“目标文件”更加新，那么执行“命令”来重新生成“目标文件”。命令被执行的2个条件：依赖文件比目标文件新，或是 目标文件还没生成。 $(foreach var,list,text) 对list中的每一个元素，取出来赋给var，然后把var改为text所描述的形式。 123例子：objs := a.o b.odep_files := $(foreach f, $(objs), .$(f).d) // 最终 dep_files := .a.o.d .b.o.d $(wildcard pattern) pattern所列出的文件是否存在，把存在的文件都列出来。 12例子：src_files := $( wildcard *.c) // 最终 src_files中列出了当前目录下的所有.c文件 $(filter pattern..., text) $(filter-out pattern..., text) 在text中取出符合patten格式的值 (不符合) $(patsubst pattern, replacement, $(var)) 从列表中取出每一个值, 如果符合pattern, 则替换为replacement gcc -M c.c 打印出依赖 gcc -M -MF c.d c.c 把依赖写入文件c.d gcc -c -o c.o c.c -MD -MF c.d 编译c.o, 把依赖写入文件c.d 通用Makefile使用 目录: D:\\imx6ull\\01_all_series_quickstart\\04_嵌入式Linux应用开发基础知识\\source\\05_general_Makefile\\Makefile_and_readme 待补充 文件IO 如果要访问真实的文件(SD卡 等等) 需要挂载 可以 cat /proc/mounts 看是否自动挂载 使用mount /dev/sda1 /mnt 来手动挂载到mnt目录下 有些文件是虚拟的,Linux内核提供虚拟文件系统,根据虚拟文件系统里面的文件可以查看内核的一些信息/sys 其他为驱动文件, 通过函数去直接操作硬件 在Linux内核有俩种驱动,字符设备驱动’c’(ls -al 第一个字母) 块设备’b’ 主设备号 次设备号 (通过这些来确定到底是哪一个驱动 哪一个硬件) 不是通用的函数：ioctl/mmap 俩个复制文件的demo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135这个是用 write / read 方式 02 #include &lt;sys/types.h&gt;03 #include &lt;sys/stat.h&gt;04 #include &lt;fcntl.h&gt;05 #include &lt;unistd.h&gt;06 #include &lt;stdio.h&gt;0708 /*09 * ./copy 1.txt 2.txt10 * argc = 311 * argv[0] = &quot;./copy&quot;12 * argv[1] = &quot;1.txt&quot;13 * argv[2] = &quot;2.txt&quot;14 */15 int main(int argc, char **argv)16 &#123;17 int fd_old, fd_new;18 char buf[1024];19 int len;2021 /* 1. 判断参数 */22 if (argc != 3)23 &#123;24 printf(&quot;Usage: %s &lt;old-file&gt; &lt;new-file&gt;\\n&quot;, argv[0]);25 return -1;26 &#125;2728 /* 2. 打开老文件 */29 fd_old = open(argv[1], O_RDONLY);30 if (fd_old == -1)31 &#123;32 printf(&quot;can not open file %s\\n&quot;, argv[1]);33 return -1;34 &#125;3536 /* 3. 创建新文件 */37 fd_new = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);38 if (fd_new == -1)39 &#123;40 printf(&quot;can not creat file %s\\n&quot;, argv[2]);41 return -1;42 &#125;4344 /* 4. 循环： 读老文件-写新文件 */45 while ((len = read(fd_old, buf, 1024)) &gt; 0)46 &#123;47 if (write(fd_new, buf, len) != len)48 &#123;49 printf(&quot;can not write %s\\n&quot;, argv[2]);50 return -1;51 &#125;52 &#125;5354 /* 5. 关闭文件 */55 close(fd_old);56 close(fd_new);5758 return 0;59 &#125;这个使用 mmap方式02 #include &lt;sys/types.h&gt;03 #include &lt;sys/stat.h&gt;04 #include &lt;fcntl.h&gt;05 #include &lt;unistd.h&gt;06 #include &lt;stdio.h&gt;07 #include &lt;sys/mman.h&gt;0809 /*10 * ./copy 1.txt 2.txt11 * argc = 312 * argv[0] = &quot;./copy&quot;13 * argv[1] = &quot;1.txt&quot;14 * argv[2] = &quot;2.txt&quot;15 */16 int main(int argc, char **argv)17 &#123;18 int fd_old, fd_new;19 struct stat stat;20 char *buf;2122 /* 1. 判断参数 */23 if (argc != 3)24 &#123;25 printf(&quot;Usage: %s &lt;old-file&gt; &lt;new-file&gt;\\n&quot;, argv[0]);26 return -1;27 &#125;2829 /* 2. 打开老文件 */30 fd_old = open(argv[1], O_RDONLY);31 if (fd_old == -1)32 &#123;33 printf(&quot;can not open file %s\\n&quot;, argv[1]);34 return -1;35 &#125;3637 /* 3. 确定老文件的大小 */38 if (fstat(fd_old, &amp;stat) == -1)39 &#123;40 printf(&quot;can not get stat of file %s\\n&quot;, argv[1]);41 return -1;42 &#125;4344 /* 4. 映射老文件 */45 buf = mmap(NULL, stat.st_size, PROT_READ, MAP_SHARED, fd_old, 0);46 if (buf == MAP_FAILED)47 &#123;48 printf(&quot;can not mmap file %s\\n&quot;, argv[1]);49 return -1;50 &#125;5152 /* 5. 创建新文件 */53 fd_new = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);54 if (fd_new == -1)55 &#123;56 printf(&quot;can not creat file %s\\n&quot;, argv[2]);57 return -1;58 &#125;5960 /* 6. 写新文件 */61 if (write(fd_new, buf, stat.st_size) != stat.st_size)62 &#123;63 printf(&quot;can not write %s\\n&quot;, argv[2]);64 return -1;65 &#125;6667 /* 5. 关闭文件 */68 close(fd_old);69 close(fd_new);7071 return 0;72 &#125; 系统调用函数怎么进入内核? 应用程序通过 open/read/write 进而去访问设备、文件。 进入到内核kernel, 对于普通文件,会使用文件系统去读取对应的磁盘, 对于硬件, 会去找到内核中对应的驱动程序调用相关的程序 调用过程 这些关于文件的函数一般是由glibc提供的,以及其他不同版本的C库(ucibc), open这些要去打开文件需要依赖操作系统提供的功能(怎么进入Linux内核), 可以把内核当作另外一个APP , 这个app不能去调用另外一个app里面的函数 open函数里面会放一条指令, 比如在32为cpu,会使用swi指令, 对于64位cpu, 使用svc指令, 一旦执行这些指令, 就会触发CPU的异常, 会导致CPU跳到某个地址里面去执行系统里面的代码, 这时候操作系统就会去执行对应的sys_open sys_read函数, 对于read , write 函数也是如此. 那么它怎么知道app触发这个异常是为了去调用sys_open或者是sys_read, glibc在实现sys这些系统调用的时候, 会使用这些命令(swi等)来触发异常, 并且传入不同的参数给内核, 内核根据不同的参数来分辨是想调用哪个 glibc里面怎么传递参数给内核呢? 最开始用的old abi 二进制接口(老的API), 在执行swi指令的时候可以在这条指令后面跟一个数值, 内核执行这个swi的异常处理函数时会把后面的数值取出来, 根据里面的值知道要去调用什么函数. 后来又有改进,使用EABI, 不在swi里面传参数了, 它事先在 R7 寄存器(汇编) 里面存入那些值, 当发生异常的时候,内核会去R7寄存器得到这些值, 进而得到去执行sys的什么函数 对于64位,使用svc指令, 通过X8寄存器传入, 内核里面有一个系统函数调用指针数组, sys_call_table内核把库函数传进来的值处理之后, 用这个值作为下标, 在这个数组里面对应的函数.(阅读glibc的源码,内核源码) app调用openread导致内核的sys_openread被调用,那么内核的sys_openread会做什么事情呢 Linux软件架构 在linux系统软件架构可以分为4个层次（从低到高分别为）： 1.引导加载程序 ​ 引导加载程序（Bootloader）是固化在硬件Flash中的一段引导代码，用于完成硬件的一些基本配置，引导内核启动。 ​ 同时，Bootloader会在自身与内核分区之间存放一些可设置的参数（Boot parameters），比如IP地址，串口波特率，要传递给内核的命令行参数。 2.系统内核 ​ 系统内核（Kernel）是整个操作系统的最底层，它负责整个硬件的驱动，以及提供各种系统所需的核心功能，包括防火墙机制、是否支持LVM或Quota等文件系统等等，如果内核不认识某个最新的硬件，那么硬件也就无法被驱动，你也就无法使用该硬件。计算机真正工作的东西其实是硬件，例如数值运算要使用到CPU、数据储存要使用到硬盘、图形显示会用到显示适配器、音乐发声要有音效芯片、连接Internet 可能需要网络卡等等。内核就是控制这些芯片如何工作。 3.文件系统 ​ Linux文件系统（File System）中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。 ​ 文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。 4.用户程序 ​ 用户应用程序（Application）为了完成某项或某几项特定任务而被开发运行于操作系统之上的计算机程序。 Linux启动过程 正常启动过程中，Bootloader首先运行，然后将内核复制到内存中（或者在固态存储设备上直接运行，但是效率较低），并在内存某个固定的地址（包括地址与参数的结构）设置好要传递给内核的参数，最后运行内核。内核启动后，挂载（mount）根文件系统（Root filesystem），启动文件系统中的应用程序。 上电 ——&gt; Bootloader —[传递参数]—&gt; 加载内核 ——&gt; 内核挂载根文件系统 ——&gt;执行应用程序 如何理解Bootloader与Kernel 操作系统内核本身就是一个裸机程序，和我们学的uboot和其他裸机程序没有本质的区别；事实上，不少U-Boot源码就是根据相应的Linux内核源程序进行简化而形成的，尤其是一些设备的驱动程序。如果我们去琢磨U-Boot源码的注释，便会轻易的发现这一情况。 区别就是操作系统运行起来后可以分为应用层（用户态）和内核层（内核态），分层后，两层的权限不同（实现的原理是基于CPU的模式切换），内存访问和设备操作的管理上更加精细（内核可以随便方位各种硬件，而应用程序只能被限制的访问硬件和内存地址）。 以ARM处理器为例，除用户模式外，其余6种工作模式都属于特权模式： 用户模式（USR）：正常程序执行模式，不能直接切换到其他模式 系统模式（SYS）：运行操作系统的特权任务，与用户模式类似，但具有可以直接切换到其他模式等特权 快中断模式（FIQ）：支持高速数据传输及通道处理，FIQ异常响应时进入此模式 中断模式（IRQ）：用于通用中断处理，IRQ异常响应时进入此模式 管理模式（SVC）：操作系统保护模式，系统复位和软件中断响应时进入此模式（由系统调用执行软中断SWI命令触发） 中止模式（ABT）：用于支持虚拟内存和/或存储器保护，在ARM7TDMI没有大用处 未定义模式（UND）：支持硬件协处理器的软件仿真，未定义指令异常响应时进入此模式 Linux内核态是从ARM的SVC即管理模式下启动的，但在某些情况下、如：硬件中断、程序异常（被动）等情况下进入ARM的其他特权模式，这时仍然可以进入内核态（因为就是可以操作内核了）；同样，Linux用户态是从ARM用户模式启动的，但当进入ARM系统模式时、仍然可以操作Linux用户态程序（进入用户态，如init进程的启动过程）。 即：Linux内核从ARM的SVC模式下启动，但内核态不仅仅指ARM的SVC模式（还包括可以访问内核空间的所有ARM模式）；Linux用户程序从ARM的用户模式启动，但用户态不仅仅指ARM的用户模式。 直观来看：uboot的镜像是u-boot.bin，Linux系统的镜像是zImage，这两个东西其实都是裸机程序镜像。从系统启动的角度来讲，内核和uboot都是裸机程序。 文件系统 概念 Linux文件系统中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。这种机制有利于用户和操作系统的交互。 尽管内核是 Linux 的核心，但文件却是用户与操作系统交互所采用的主要工具。这对 Linux 来说尤其如此，这是因为在 UNIX 传统中，它使用文件 I/O 机制管理硬件设备和数据文件 虚拟文件系统、根文件系统和文件系统 VFS： Linux支持多种文件系统类型，因为它将底层与应用层分隔开；而提供统一的接口支持应用层对于不同实现的文件系统的访问，这个统一的接口称为虚拟文件系统VFS。 kernel中以VFS去支持各种文件系统，如yaffs，ext3，cramfs等等。yaffs/yaffs2是专为嵌入式系统使用NAND型闪存而设计的一种日志型文件系统。在内核中以VFS来屏蔽各种文件系统的接口不同，以VFS向kernel提供一个统一的接口。 根文件系统 文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。以“/”为顶级目录的文件系统称为根文件系统。 Linux启动时，第一个必须挂载的是根文件系统；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。系统正常挂载根文件系统之后可以自动或手动挂载其他的文件系统（根文件系统是其他文件的最终挂载点）。因此，一个系统中可以同时存在不同的文件系统。 也就是说： 根文件系统可以是任何kernel支持的文件系统类型(ext4,yaffs等)。 但它必须包含linux内核启动时所必需的文件(根文件系统必需存在的目录 /dev /bin /sbin 等等)，不然系统启动会失败。 根文件系统是之所以有个根(/)字,是因为它是linux系统启动时挂载(mount,所谓挂载：就是在内存中创建一个虚拟的文件对应具体的存储空间分区的过程,挂载时不会保存信息,下次启动时得重新挂载)的第一个文件系统,启动完成后可以自动(配置etc/fstab)或者手动的方式将其它文件系统(分区)挂载到根文件系统中。 其他文件系统 不同的文件系统类型有不同的特点，因而根据存储设备的硬件特性、系统需求等有不同的应用场合。在嵌入式Linux应用中，主要的存储设备为 RAM(DRAM, SDRAM)和ROM(常采用FLASH存储器)，常用的基于存储设备的文件系统类型包括：jffs2, yaffs, cramfs, romfs, ramdisk,initramfs, ramfs/tmpfs,ubifs等。 uboot与根文件系统的关系 早期的uboot没有分区的概念，uboot只知道应该将什么数据烧写到存储介质的什么区间中。 （也就是说，对于uboot来看，只有起始地址结束地址等，A～B地址放内核，C～D地址放文件系统，即：规定哪个地址区间放内核或者文件系统等） 虽然此后，uboot中渐渐也有了MTD等管理分区部分的功能。尽管如此，不影响我们的学习理解。 总结 cpu首先执行位于0地址的uboot，uboot启动以后初始化一些资源，告诉内核有关的参数并引导内核，内核通过事先添加对于某种文件系统类型的支持驱动（相当于一小段程序），读取uboot等boot loader在指定的区域烧写制作好的文件系统镜像，内核解析并挂载成根文件系统，并在此基础上，通过VFS再挂载不同的文件系统类型，完成启动以后，再去管理有关的资源（包括应用程序） 应用编程 Framebuffer(ioctl mmap) bpp: 每个像素用多少位来表示它的颜色 首地址+偏移地址=确定出位于哪里 假设fb_base是APP执行mmap后得到的Framebuffer地址 求偏移地址: y*line_width+x*pixel_width(这就时偏移地址) + fb_base = 绝对地址 可以用以下公式算出(x,y)坐标处像素对应的Framebuffer地址： (x，y)像素起始地址=fb_base+(xres*bpp/8)y + xbpp/8 一行的宽度: xres * bpp/8 一个像素宽度: bpp/8 ioctl ioctl是设备驱动程序中对设备的I/O通道进行管理的函数 。所谓对I/O通道进行管理，就是对设备的一些特性进行控制 ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数来控制设备的I/O通道。 头文件：#include &lt;sys/ioctl.h&gt; 函数原型： int ioctl(int fd, unsigned long request, ...); 函数说明： ① fd 表示文件描述符； ② request表示与驱动程序交互的命令，用不同的命令控制驱动程序输出我们需要的数据； ③ … 表示可变参数arg，根据request命令，设备驱动程序返回输出的数据。 ④ 返回值：打开成功返回文件描述符，失败将返回-1。 ioctl的作用非常强大、灵活。不同的驱动程序内部会实现不同的ioctl，APP可以使用各种ioctl跟驱动程序交互：可以传数据给驱动程序，也可以从驱动程序中读出数据。 mmap 12345678910111213141516#include &lt;sys/mman.h&gt;函数原型：void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);函数说明：① addr表示指定映射的內存起始地址，通常设为 NULL表示让系统自动选定地址，并在成功映射后返回该地址；② length表示将文件中多大的内容映射到内存中；③ prot 表示映射区域的保护方式，可以为以下4种方式的组合a. PROT_EXEC 映射区域可被执行b. PROT_READ 映射区域可被读出c. PROT_WRITE 映射区域可被写入d. PROT_NONE 映射区域不能存取④ Flags 表示影响映射区域的不同特性，常用的有以下两种a. MAP_SHARED 表示对映射区域写入的数据会复制回文件内，原来的文件会改变。b. MAP_PRIVATE 表示对映射区域的操作会产生一个映射文件的复制，对此区域的任何修改都不会写回原来的文件内容中。⑤ 返回值：若成功映射，将返回指向映射的区域的指针，失败将返回-1。 映射framebuffer, framebuffer时驱动程序分配的, 应用程序想要去使用必须使用mmap映射到用户空间, 应用程序得到LCD的参数并且得到framebuffer的地址之后就可以在上面操作了. 描点函数demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535428 void lcd_put_pixel(int x, int y, unsigned int color(传入RGB888))29 &#123;30 unsigned char *pen_8 = fb_base+y*line_width+x*pixel_width;31 unsigned short *pen_16;32 unsigned int *pen_32;3334 unsigned int red, green, blue;3536 pen_16 = (unsigned short *)pen_8;37 pen_32 = (unsigned int *)pen_8;3839 switch (var.bits_per_pixel)40 &#123;41 case 8:42 &#123;43 *pen_8 = color;44 break;45 &#125;46 case 16:47 &#123;48 /* 565 */49 red = (color &gt;&gt; 16) &amp; 0xff;50 green = (color &gt;&gt; 8) &amp; 0xff;51 blue = (color &gt;&gt; 0) &amp; 0xff;52 color = ((red &gt;&gt; 3) &lt;&lt; 11) | ((green &gt;&gt; 2) &lt;&lt; 5) | (blue &gt;&gt; 3);//保证绿颜色高六位 //保证蓝颜色高五位53 *pen_16 = color;54 break;55 &#125;56 case 32:57 &#123;58 *pen_32 = color;59 break;60 &#125;61 default:62 &#123;63 printf(&quot;can&#x27;t surport %dbpp\\n&quot;, var.bits_per_pixel);64 break;65 &#125;66 &#125;67 &#125;第28行中传入的color表示颜色，它的格式永远是0x00RRGGBB，即RGB888。当LCD是16bpp时，要把color变量中的R、G、B抽出来再合并成RGB565格式。第30行计算(x,y)坐标上像素对应的Framebuffer地址。第43行，对于8bpp，color就不再表示RBG三原色了，这涉及调色板的概念，color是调色板的值。第49～51行，先从color变量中把R、G、B抽出来。第52行，把red、green、blue这三种8位颜色值，根据RGB565的格式，只保留red中的高5位、green中的高6位、blue中的高5位，组合成一个新的16位颜色值。第53行，把新的16位颜色值写入Framebuffer。第58行，对于32bpp，颜色格式跟color参数一致，可以直接写入Framebuffer。 /* 清屏: 全部设为白色 */96 memset(fbmem, 0xff, screen_size);9798 /* 随便设置出100个为红色 */99 for (i = 0; i &lt; 100; i++)100 lcd_put_pixel(var.xres/2+i, var.yres/2, 0xFF0000); 文字显示 字符编码 ASCII 常用字母就26个，区分大小写、加上标点符号也没超过127个，每个字符用一个字节来表示就足够了。一个字节的7位就可以表示128个数值，在ASCII码中最高位永远是0。 ANSI ASNI是ASCII的扩展，向下包含ASCII。对于ASCII字符仍以一个字节来表示，对于非ASCII字符则使用2字节来表示。 在中国大陆地区，ANSI的默认编码是GB2312；在港澳台地区默认编码是BIG5。以数值“0xd0d6”为例，对于GB2312编码它表示“中”；对于BIG5编码它表示“笢”。所以对于ANSI编码的TXT文件，如果你打开它发现乱码，那么还得再次细分它的具体编码。 UNICODE 在ANSI标准中，很多种文字都有自己的编码标准，汉字简体字有GB2312、繁体字有BIG5，这难免同一个数值对应不同字符。比如数值“0xd0d6”，对于GB2312编码它表示“中”；对于BIG5编码它表示“笢”。这造成了使用ANSI编码保存的文件，不适合跨地区交流。 UNICODE编码就是解决这类问题：对于地球上任意一个字符，都给它一个唯一的数值。 UNICODE仍然向下兼容ASCII，但是对于其他字符会有对应的数值，比如对于“中”、“笢”，它们的数值分别是：0x4e2d、0x7b22 UNICODE中的数值范围是0x0000至0x10FFFF，有1,114,111即100多万个数值，可以表示100多万个字符，足够地球人使用了。 ASCII字符显示 中文字符显示 如果不指定“-finput-charset”，GCC就会默认C程序的编码方式为UTF-8，即使你是以ANSI格式保存，也会被当作UTF-8来对待。 对于编译出来的可执行程序，可以指定它里面的字符是以什么方式编码，可以使用以下的选项编译器： -fexec-charset=GB231 -fexec-charset=UTF-8 如果不指定“-fexec-charset”，GCC就会默认编译出的可执行程序中字符的编码方式为UTF-8。 如果“-finput-charset”与“-fexec-charset”不一样，编译器会进行格式转换。 待补充… 交叉编译程序：以freetype为例 使用buildroot来给ARM板编译程序、编译库会很简单,这里freetype在编译 安装一些小程序很有用 库相关知识 编译程序时去哪找头文件？ 系统目录：就是交叉编译工具链里的某个include目录； 也可以自己指定：编译时用 “ -I dir ”选项指定。 链接时去哪找库文件？ 系统目录：就是交叉编译工具链里的某个lib目录； 也可以自己指定：链接时用 “ -L dir ”选项指定。 运行时去哪找库文件？ 系统目录：就是板子上的/lib、/usr/lib目录； 也可以自己指定：运行程序用环境变量LD_LIBRARY_PATH指定。 运行时不需要头文件，所以头文件不用放到板子上 库的问题 这是链接程序时出现的问题 系统目录：就是交叉编译工具链里的某个lib目录, 也可以自己指定：链接时用 -L dir选项指定 怎么确定“系统目录”？执行下面命令确定目录： echo 'main()&#123;&#125;'| arm-buildroot-linux-gnueabihf-gcc -E -v – 它会列出头文件目录、库目录(LIBRARY_PATH)，你编译出库文件时，可以把它放入系统库目录。 运行问题 系统目录：就是板子上的/lib、/usr/lib目录 也可以自己指定： 运行程序用环境变量LD_LIBRARY_PATH指定，执行以下的命令 123export LD_LIBRARY_PATH=/xxx_dir ; ./test或LD_LIBRARY_PATH=/xxx_dir ./test 交叉编译 如果交叉编辑工具链的前缀是arm-buildroot-linux-gnueabihf-，比如arm-buildroot-linux-gnueabihf-gcc，交叉编译开源软件时，如果它里面有configure 123./configure --host=arm-buildroot-linux-gnueabihf(这里自己修改) --prefix=$PWD/tmpmakemake install 就可以在当前目录的tmp目录下看见bin, lib, include等目录，里面存有可执行程序、库、头文件。 程序运行不需要头文件 freetype Freetype是开源的字体引擎库，它提供统一的接口来访问多种字体格式文件，从而实现矢量字体显示。我们只需要移植这个字体引擎，调用对应的API接口，提供字体文件，就可以让freetype库帮我们取出关键点、实现闭合曲线，填充颜色，达到显示矢量字体的目的。 一个文字的显示过程可以概括如下： 123456789① 给定一个字符可以确定它的编码值(ASCII、UNICODE、GB2312)；② 设置字体大小；③ 根据编码值，从文件头部中通过charmap找到对应的关键点(glyph)，它会根据字体大小调整关键点；④ 把关键点转换为位图点阵；⑤ 在LCD上显示出来 如何使用freetype库，总结出下列步骤： 1234567891011121314151617① 初始化：FT_InitFreetype② 加载(打开)字体Face：FT_New_Face③ 设置字体大小：FT_Set_Char_Sizes 或 FT_Set_Pixel_Sizes④ 选择charmap：FT_Select_Charmap⑤ 根据编码值charcode找到glyph_index：glyph_index = FT_Get_Char_Index（face，charcode）⑥ 根据glyph_index取出glyph：FT_Load_Glyph（face，glyph_index）⑦ 转为位图：FT_Render_Glyph⑧ 移动或旋转:FT_Set_Transform⑨ 最后显示出来。 上面的⑤⑥⑦可以使用一个函数代替：FT_Load_Char(face, charcode, FT_LOAD_RENDER)，它就可以得到位图。 demo: 如果想在代码中能直接使用UNICODE值，需要使用wchar_t，宽字符, 占四个字节 注意：如果test_wchar.c是以ANSI(GB2312)格式保存，那么需要使用以下命令来编译： gcc -finput-charset=GB2312 -fexec-charset=UTF-8 -o test_wchar test_wchar.c 显示一行文字 笛卡尔坐标系: 在LCD的坐标系中，原点在屏幕的左上角。对于笛卡尔坐标系，原点在左下角。freetype使用笛卡尔坐标系，在显示时需要转换为LCD坐标系。 从下图可知，X方向坐标值是一样的。 在Y方向坐标值需要换算，假设LCD的高度是V。 在LCD坐标系中坐标是(x, y)，那么它在笛卡尔坐标系中的坐标值为(x, V-y)。 反过来也是一样的，在笛卡尔坐标系中坐标是(x, y)，那么它在LCD坐标系中坐标值为(x, V-y)。 具体函数见文档393页. 输入系统 外设都是输入设备,Linux系统为了统一管理这些输入设备，实现了一套能兼容所有输入设备的框架：输入系统。驱动开发人员基于这套框架开发出程序，应用开发人员就可以使用统一的API去使用设备。 框架 假设用户程序直接访问/dev/input/event0设备节点，或者使用tslib访问设备节点，数据的流程如下： 1234567891011① APP发起读操作，若无数据则休眠；② 用户操作设备，硬件上产生中断；③ 输入系统驱动层对应的驱动程序处理中断： 读取到数据，转换为标准的输入事件，向核心层汇报。 所谓输入事件就是一个“struct input_event”结构体。④ 核心层可以决定把输入事件转发给上面哪个handler来处理： 从handler的名字来看，它就是用来处输入操作的。有多种handler，比如：evdev_handler(常用)、 kbd_handler、joydev_handler等等。 最常用的是evdev_handler：它只是把input_event结构体保存在内核buffer等，APP来读取时就原原本本地返回。它支持多个APP同时访问输入设备，每个APP都可以获得同一份输入事件。 当APP正在等待数据时，evdev_handler会把它唤醒，这样APP就可以返回数据。⑤ APP对输入事件的处理： APP获得数据的方法有2种：直接访问设备节点(比如/dev/input/event0,1,2,...)，或者通过tslib、libinput这类库来间接访问设备节点。这些库简化了对数据的处理。 内核中怎么表示一个输入设备？ 使用input_dev结构体来表示输入设备，它的内容如下： 驱动程序上报的数据含义三项重要内容 type 表示数据是哪一类型的, 比如EV_KEY(表示按键类) 当type=0表示是同步事件 表示硬件已经上报了所有数据 code 按键类事件里面是哪一个按键? 硬件上报的是哪个按键 value 值, 比如0(松开) 1(按下) 2(长按) 事件之间的界线 APP读取数据时，可以得到一个或多个数据，比如一个触摸屏的一个触点会上报X、Y位置信息，也可能会上报压力值。 APP怎么知道它已经读到了完整的数据？ 驱动程序上报完一系列的数据后，会上报一个“同步事件”，表示数据上报完毕。APP读到“同步事件”时，就知道已经读完了当前的数据。 得到一系列的输入事件，就是一个一个“struct input_event”，它定义如下： 每个输入事件input_event中都含有发生时间：timeval表示的是“自系统启动以来过了多少时间”，它是一个结构体，含有“tv_sec、tv_usec”两项(即秒、微秒)。 调试技巧 入设备的设备节点名为/dev/input/eventX(也可能是/dev/eventX，X表示0、1、2等数字)。查看设备节点，可以执行以下命令： ls /dev/input/* -l 或 ls /dev/event* -l 怎么知道这些设备节点对应什么硬件呢？可以在板子上执行以下命令： cat /proc/bus/input/devices 这条指令的含义就是获取与event对应的相关设备信息，可以看到类似以下的结果： 这里的I、N、P、S、U、H、B对应的每一行是什么含义: 123456789101112I:id of the device(设备ID) 该参数由结构体struct input_id来进行描述N:name of the device 设备名称P:physical path to the device in the system hierarchy 系统层次结构中设备的物理路径。S:sysfs path 位于sys文件系统的路径U:unique identification code for the device(if device has it) 设备的唯一标识码H:list of input handles associated with the device. 与设备关联的输入句柄列表。B:bitmaps(位图) PROP:device properties and quirks(设备属性) EV:types of events supported by the device(设备支持的事件类型) KEY:keys/buttons this device has(此设备具有的键/按钮) MSC:miscellaneous events supported by the device(设备支持的其他事件) LED:leds present on the device(设备上的指示灯) 比如上图中“B: EV=b”用来表示该设备支持哪类输入事件。b的二进制是1011，bit0、1、3为1，表示该设备支持0、1、3这三类事件，即EV_SYN、EV_KEY、EV_ABS。 再举一个例子，“B: ABS=2658000 3”如何理解？ 它表示该设备支持EV_ABS这一类事件中的哪一些事件。这是2个32位的数字：0x2658000、0x3，高位在前低位在后，组成一个64位的数字：“0x2658000,00000003”，数值为1的位有：0、1、47、48、50、53、54，即：0、1、0x2f、0x30、0x32、0x35、0x36,对应一些宏. 命令读取 调试输入系统时，直接执行类似下面的命令，然后操作对应的输入设备即可读出数据： hexdump /dev/input/event0 上图中的type为3，对应EV_ABS；code为0x35对应ABS_MT_POSITION_X；code为0x36对应ABS_MT_POSITION_Y。 上图中还发现有2个同步事件：它的type、code、value都为0。表示电容屏上报了2次完整的数据。 不用库开发应用 输入系统支持完整的API操作 : 支持这些机制：阻塞、非阻塞、POLL/SELECT、异步通知。 APP访问硬件的几种方式 123456789① 时不时进房间看一下：查询方式简单，但是累② 进去房间陪小孩一起睡觉，小孩醒了会吵醒她：休眠-唤醒不累，但是妈妈干不了活了③ 妈妈要干很多活，但是可以陪小孩睡一会，定个闹钟：poll方式要浪费点时间，但是可以继续干活。妈妈要么是被小孩吵醒，要么是被闹钟吵醒。④ 妈妈在客厅干活，小孩醒了他会自己走出房门告诉妈妈：异步通知妈妈、小孩互不耽误。 通过ioctl获取设备信息，ioctl的参数如下： int ioctl(int fd, unsigned long request, ...); 查询方式 APP调用open函数时，传入“O_NONBLOCK”表示“非阻塞”。 APP调用read函数读取数据时，如果驱动程序中有数据，那么APP的read函数会返回数据，否则也会立刻返回错误。 休眠-唤醒方式 APP调用open函数时，不要传入“O_NONBLOCK”。 APP调用read函数读取数据时，如果驱动程序中有数据，那么APP的read函数会返回数据；否则APP就会在内核态休眠，当有数据时驱动程序会把APP唤醒，read函数恢复执行并返回数据给APP。 POLL/SELECT方式 POLL机制、SELECT机制是完全一样的，只是APP接口函数不一样。在调用poll、select函数时可以传入“超时时间”。在这段时间内，条件合适时(比如有数据可读、有空间可写)就会立刻返回，否则等到“超时时间”结束时返回错误。 APP先调用open函数时。APP不是直接调用read函数，而是先调用poll或select函数，这2个函数中可以传入“超时时间”。它们的作用是：如果驱动程序中有数据，则立刻返回；否则就休眠。在休眠期间，如果有人操作了硬件，驱动程序获得数据后就会把APP唤醒，导致poll或select立刻返回；如果在“超时时间”内无人操作硬件，则时间到后poll或select函数也会返回。 poll/select函数可以监测多个文件，可以监测多种事件： 事件类型 说明 POLLIN 有数据可读 POLLRDNORM 等同于POLLIN POLLRDBAND Priority band data can be read，有优先级较较高的“band data”可读 Linux系统中很少使用这个事件 POLLPRI 高优先级数据可读 POLLOUT 可以写数据 POLLWRNORM 等同于POLLOUT POLLWRBAND Priority data may be written POLLERR 发生了错误 POLLHUP 挂起 POLLNVAL 无效的请求，一般是fd未open 在调用poll函数时，要指明： ① 你要监测哪一个文件：哪一个fd ② 你想监测这个文件的哪种事件：是POLLIN、还是POLLOUT 最后，在poll函数返回时，要判断状态。 1代码补充 异步通知方式 所谓异步通知，就是APP可以忙自己的事，当驱动程序用数据时它会主动给APP发信号，这会导致APP执行信号处理函数。 1234567① 谁发：驱动程序发② 发什么：信号③ 发什么信号：SIGIO④ 怎么发：内核里提供有函数⑤ 发给谁：APP，APP要把自己告诉驱动⑥ APP收到后做什么：执行信号处理函数⑦ 信号处理函数和信号，之间怎么挂钩：APP注册信号处理函数 除了注册SIGIO的处理函数，APP还要做什么事？想想这几个问题： ① 内核里有那么多驱动，你想让哪一个驱动给你发SIGIO信号？ APP要打开驱动程序的设备节点。 ② 驱动程序怎么知道要发信号给你而不是别人？ APP要把自己的进程ID告诉驱动程序。 ③ APP有时候想收到信号，有时候又不想收到信号： 应该可以把APP的意愿告诉驱动：设置Flag里面的FASYNC位为1，使能“异步通知”。 tslib tslib是一个触摸屏的开源库，可以使用它来访问触摸屏设备，可以给输入设备添加各种“filter”(过滤器，就是各种处理)，地址是：http://www.tslib.org/。 编译tslib后，可以得到libts库，还可以得到各种工具：较准工具、测试工具。 具体待补充. 网络通信 数据传输，都有三个要素 ：源、目的、长度。 待补充 多线程 待补充 串口 UART：通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，简称串口 参数 波特率：一般选波特率都会有9600,19200,115200等选项。其实意思就是每秒传输这么多个比特位数(bit)。 起始位:先发出一个逻辑”0”的信号，表示传输数据的开始。 数据位：可以是5~8位逻辑”0”或”1”。如ASCII码（7位），扩展BCD码（8位）。小端传输。 校验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。 停止位：它是一个字符数据的结束标志。 如何发送数据 要发送数据时，CPU控制(UART单元)内存要发送的数据通过FIFO传给UART里面的移位器(诸位发送)，依次将数据发送出去，在发送完成后产生中断提醒CPU传输完成。 接收数据时，获取接收引脚的电平，逐位放进接收移位器，再放入FIFO，程序再从FIFO中把数据取出来写入内存。在接收完成后产生中断提醒CPU传输完成。 TTY体系中设备节点的差别 设备节点 含义 /dev/ttyS0、/dev/ttySAC0 串口 /dev/tty1、/dev/tty2、/dev/tty3、…… 虚拟终端设备节点 /dev/tty0 前台终端 /dev/tty 程序自己的终端，可能是串口、也可能是虚拟终端 /dev/console 控制台，又内核的cmdline参数确定 TTY /Terminal /Console /UART 下图中两条红线之内的代码被称为TTY子系统。它既支持UART，也支持键盘、显示器，还支持更复杂的功能(比如伪终端) ctrl + alt +f4(x) 切换 关于 /dev/ttyN 通过内核的cmdline来指定，比如: console=ttyS0 console=tty 更多: TTY驱动框架 TTY这一层帮你屏蔽了不同输入输出设备的差别,串口 键盘等的驱动程序肯定会向上注册某个结构体, 再TTY这层使用同一个接口访问不同的设备 虚拟终端: 对于同一套键盘和显示器, 它可以对应不同的个虚拟终端, 对于虚拟终端又抽象出了一层 virtual terminal(串口没有这个) , 有很多个虚拟终端, 驱动程序得到键盘信息时会发送给前排的虚拟终端, 应用程序要显示的数据也会存入某一个buffer, 要显示时再从buffer中取出来, 行规程 也叫做回显 echo, 比较有意思 : 说的是在键盘上输入一个字符所发生的事情. 删除的话,删除命令(就是字节对应的编码) 发送到后,驱动上报行规成, 它把buf中的lsa删除掉a,然后将删除命令再发送回去, 所谓删除a只是显示效果, 串口工具还是接收到了4个字节的数据: l s a 退格键 回车键: 一样的,…, 将buf中的数据上传给APP(shell), 把结果再发给行规成,再发给串口驱动,然后PC显示. Linux串口应用编程 串口怎么插 这个位置是串口,靠 串口API 在Linux系统中，操作设备的统一接口就是：open/ioctl/read/write。对于UART，又在ioctl之上封装了很多函数，主要是用来设置行规程。 所以对于UART，编程的套路就是： open -&gt; 设置行规程，比如波特率、数据位、停止位、检验位、RAW模式、一有数据就返回 -&gt; read/write 怎么设置行规程？行规程的参数用结构体termios来表示,把这个结构体构造好之后再发给驱动程序. 这些函数在名称上有一些惯例： `` tc：terminal contorl cf: control flflag` 函数名 作用 tcgetattr get terminal attributes，获得终端的属性(获得驱动程序参数) tcsetattr set terminal attributes，修改终端参数 tcflflush 清空终端未完成的输入/输出请求及数据 cfsetispeed sets the input baud rate，设置输入波特率 cfsetospeed sets the output baud rate，设置输出波特率 cfsetspeed 同时设置输入、输出波特率 需要设置好termios中的参数. 实例(回环) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;termios.h&gt;#include &lt;stdlib.h&gt;/* set_opt(fd,115200,8,&#x27;N&#x27;,1) */int set_opt(int fd,int nSpeed, int nBits, char nEvent, int nStop)&#123; struct termios newtio,oldtio; if ( tcgetattr( fd,&amp;oldtio) != 0) &#123; //获得驱动程序中默认的参数 perror(&quot;SetupSerial 1&quot;); return -1; &#125; //清除 使用原始模式 bzero( &amp;newtio, sizeof( newtio ) ); newtio.c_cflag |= CLOCAL | CREAD; newtio.c_cflag &amp;= ~CSIZE; newtio.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG); /*Input*/ newtio.c_oflag &amp;= ~OPOST; /*Output*/ switch( nBits ) &#123; case 7: newtio.c_cflag |= CS7; break; case 8: newtio.c_cflag |= CS8; break; &#125; switch( nEvent ) &#123; case &#x27;O&#x27;: newtio.c_cflag |= PARENB; newtio.c_cflag |= PARODD; newtio.c_iflag |= (INPCK | ISTRIP); break; case &#x27;E&#x27;: newtio.c_iflag |= (INPCK | ISTRIP); newtio.c_cflag |= PARENB; newtio.c_cflag &amp;= ~PARODD; break; case &#x27;N&#x27;: newtio.c_cflag &amp;= ~PARENB; break; &#125; switch( nSpeed ) &#123; case 2400: cfsetispeed(&amp;newtio, B2400); cfsetospeed(&amp;newtio, B2400); break; case 4800: cfsetispeed(&amp;newtio, B4800); cfsetospeed(&amp;newtio, B4800); break; case 9600: cfsetispeed(&amp;newtio, B9600); cfsetospeed(&amp;newtio, B9600); break; case 115200: cfsetispeed(&amp;newtio, B115200); cfsetospeed(&amp;newtio, B115200); break; default: cfsetispeed(&amp;newtio, B9600); cfsetospeed(&amp;newtio, B9600); break; &#125; if( nStop == 1 ) newtio.c_cflag &amp;= ~CSTOPB; else if ( nStop == 2 ) newtio.c_cflag |= CSTOPB; newtio.c_cc[VMIN] = 1; /* 读数据时的最小字节数: 没读到这些数据我就不返回! */ newtio.c_cc[VTIME] = 0; /* 等待第1个数据的时间: * 比如VMIN设为10表示至少读到10个数据才返回, * 但是没有数据总不能一直等吧? 可以设置VTIME(单位是10秒) * 假设VTIME=1，表示: * 10秒内一个数据都没有的话就返回 * 如果10秒内至少读到了1个字节，那就继续等待，完全读到VMIN个数据再返回 */ tcflush(fd,TCIFLUSH); if((tcsetattr(fd,TCSANOW,&amp;newtio))!=0) &#123; perror(&quot;com set error&quot;); return -1; &#125; //printf(&quot;set done!\\n&quot;); return 0;&#125;int open_port(char *com)&#123; int fd; //fd = open(com, O_RDWR|O_NOCTTY|O_NDELAY); fd = open(com, O_RDWR|O_NOCTTY);//打开某个设备节点 O_NOCTTY:程序打开串口之后不要把这个串口用作控制终端(serial连接就是控制终端,输入字符转换成某些信号去控制) if (-1 == fd)&#123; return(-1); &#125; //fcntl(fd,F_SETEL, FNDELAY); 读数据时不等待, 没有数据就返回0 if(fcntl(fd, F_SETFL, 0)&lt;0) /* 设置串口为阻塞状态*/ //读写数据不成功就会休眠 &#123; printf(&quot;fcntl failed!\\n&quot;); return -1; &#125; return fd;&#125;/* * ./serial_send_recv &lt;dev&gt;(设备节点) */int main(int argc, char **argv)&#123; int fd; int iRet; char c; /* 1. open *///打开 /* 2. setup * 115200,8N1 * RAW mode * return data immediately *///设置 /* 3. write and read */ if (argc != 2) &#123; printf(&quot;Usage: \\n&quot;); printf(&quot;%s &lt;/dev/ttySAC1 or other&gt;\\n&quot;, argv[0]); return -1; &#125; fd = open_port(argv[1]); if (fd &lt; 0) &#123; printf(&quot;open %s err!\\n&quot;, argv[1]); return -1; &#125; iRet = set_opt(fd, 115200, 8, &#x27;N&#x27;, 1);//设置参数波特率11520 数据位8 不用校验位 停止位1 if (iRet) &#123; printf(&quot;set port err!\\n&quot;); return -1; &#125; printf(&quot;Enter a char: &quot;); while (1) &#123; scanf(&quot;%c&quot;, &amp;c); iRet = write(fd, &amp;c, 1); iRet = read(fd, &amp;c, 1); if (iRet == 1) printf(&quot;get: %02x %c\\n&quot;, c, c); else printf(&quot;can not get data\\n&quot;); &#125; return 0;&#125; 读数据时的最小字节数设置为0: 为什么第一遍打印俩遍错误呢? 输入a, 将a保存在行规程, 回车键继续发送至行规程, 才会去唤醒应用程序, scanf被唤醒得到了a, 把a发给另一个串口, 串口1开始接收(一位一位), 所以write发送了,但是read没有接受, 返回0, 第二个字符时enter, 又没有读到数据, 输入字符b, read读到a(行规程里第一个数据) 主要问题是write确实可以发送出去, 但是串口没有得到数据呢(没有上报给驱动程序), read返回0, 所以要设置读到最小字节为1, 没有数据的话永远等待(等待时间设置) I2C I2C框架 一个芯片里面有一个或者多个I2C控制器, 一个I2C控制器上面可以挂载一个或者多个I2C设备, 访问这些设备需要去寻址, 所以使用I2C总线来操作设备时, 首先得知道设备的设备地址, 知道后就可以跟他收发数据了. I2C总线只需要2条线：时钟线SCL、数据线SDA. 在I2C总线的SCL、SDA线上，都有上拉电阻 APP(open/read/write) 设备驱动程序(例如EEPROM存储设备 TS触摸屏设备) 控制驱动程序 协议 控芯片引出两条线SCL(SCK),SDA线，在一条I2C总线上可以接很多I2C设备，我们还会放一个上拉电阻 123456简单的例子，来解释一下IIC的传输协议： 老师说开始了，表示开始信号(start) 老师提醒某个学生要发球，表示发送地址和方向(address/read/write) 老师发球/接球，表示数据的传输 收到球要回应：回应信号(ACK) 老师说结束，表示IIC传输结束(P) 写操作 主芯片要发出一个start信号 然后发出一个设备地址(用来确定是往哪一个芯片写数据)，方向(读/写，0表示写，1表示读) 从设备回应(用来确定这个设备是否存在)，然后就可以传输数据 主设备发送一个字节数据给从设备，并等待回应 每传输一字节数据，接收方要有一个回应信号（确定数据是否接受完成)，然后再传输下一个数据。 数据发送完之后，主芯片就会发送一个停止信号。 下图：白色背景表示&quot;主→从&quot;，灰色背景表示&quot;从→主&quot; 读操作 主芯片要发出一个start信号 然后发出一个设备地址(用来确定是往哪一个芯片写数据)，方向(读/写，0表示写，1表示读) 从设备回应(用来确定这个设备是否存在)，然后就可以传输数据 从设备发送一个字节数据给主设备，并等待回应 每传输一字节数据，接收方要有一个回应信号（确定数据是否接受完成)，然后再传输下一个数据。 数据发送完之后，主芯片就会发送一个停止信号。 下图：白色背景表示&quot;主→从&quot;，灰色背景表示&quot;从→主&quot; 信号 I2C协议中数据传输的单位是字节，也就是8位。但是要用到9个时钟：前面8个时钟用来传输8数据，第9个时钟用来传输回应信号。传输时，先传输最高位(MSB)。 开始信号（S）：SCL为高电平时，SDA山高电平向低电平跳变，开始传送数据。 结束信号（P）：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。 响应信号(ACK)：接收器在接收到8位数据后，在第9个时钟周期，拉低SDA SDA上传输的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化 细节 如何在SDA上实现双向传输？ 主芯片通过一根SDA线既可以把数据发给从设备，也可以从SDA上读取数据，连接SDA线的引脚里面必然有两个引脚（发送引 脚/接受引脚）。 主、从设备都可以通过SDA发送数据，肯定不能同时发送数据，怎么错开时间？ 在9个时钟里， 前8个时钟由主设备发送数据的话，第9个时钟就由从设备发送数据； 前8个时钟由从设备发送数据的话，第9个时钟就由主设备发送数据。 双方设备中，某个设备发送数据时，另一方怎样才能不影响SDA上的数据？ 设备的SDA中有一个三极管，使用开极/开漏电路(三极管是开极，CMOS管是开漏，作用一样)，如下图： 123当某一个芯片不想影响SDA线时，那就不驱动这个三极管想让SDA输出高电平，双方都不驱动三极管(SDA通过上拉电阻变为高电平)想让SDA输出低电平，就驱动三极管 举例(双向传输) 主设备发送（8bit）给从设备 前8个clk 从设备不要影响SDA，从设备不驱动三极管 主设备决定数据，主设备要发送1时不驱动三极管，要发送0时驱动三极管 第9个clk，由从设备决定数据 主设备不驱动三极管 从设备决定数据，要发出回应信号的话，就驱动三极管让SDA变为0 从这里也可以知道ACK信号是低电平 从上面的例子，就可以知道怎样在一条线上实现双向传输，这就是SDA上要使用上拉电阻的原因。 为何SCL也要使用上拉电阻？ 在第9个时钟之后，如果有某一方需要更多的时间来处理数据，它可以一直驱动三极管把SCL拉低。 当SCL为低电平时候，大家都不应该使用IIC总线，只有当SCL从低电平变为高电平的时候，IIC总线才能被使用。 当它就绪后，就可以不再驱动三极管，这是上拉电阻把SCL变为高电平，其他设备就可以继续使用I2C总线了。 对于IIC协议它只能规定怎么传输数据，数据是什么含义由从设备决定。 SMBus协议 SMBus: System Management Bus，系统管理总线。 1234SMBus最初的目的是为智能电池、充电电池、其他微控制器之间的通信链路而定义的。SMBus也被用来连接各种设备，包括电源相关设备，系统传感器，EEPROM通讯设备等等。SMBus 为系统和电源管理这样的任务提供了一条控制总线，使用 SMBus 的系统，设备之间发送和接收消息都是通过 SMBus，而不是使用单独的控制线，这样可以节省设备的管脚数。SMBus是基于I2C协议的，SMBus要求更严格，SMBus是I2C协议的子集。 跟一般的I2C协议的差别  VDD的极限值不一样 I2C协议：范围很广，甚至讨论了高达12V的情况 SMBus：1.8V~5V  最小时钟频率、最大的Clock Stretching Clock Stretching含义：某个设备需要更多时间进行内部的处理时，它可以把SCL拉低占住I2C总线 I2C协议：时钟频率最小值无限制，Clock Stretching时长也没有限制 SMBus：时钟频率最小值是10KHz，Clock Stretching的最大时间值也有限制  地址回应(Address Acknowledge) 一个I2C设备接收到它的设备地址后，是否必须发出回应信号？ I2C协议：没有强制要求必须发出回应信号 SMBus：强制要求必须发出回应信号，这样对方才知道该设备的状态：busy，failed，或是被移除了  REPEATED START Condition(重复发出S信号) 比如读EEPROM时，涉及2个操作： 把存储地址发给设备 and 读数据 在写、读之间，可以不发出P信号，而是直接发出S信号：这个S信号就是REPEATED START  SMBus协议明确了数据的传输格式 I2C协议：它只定义了怎么传输数据，但是并没有定义数据的格式，这完全由设备来定义 SMBus：定义了几种数据格式(下面分析) I2C Block Write 和 I2C SMBus Block Write 的区别L: 传输过程会不会传输Byte Count值 I2C系统重要结构体 使用一句话概括I2C传输：APP通过I2C Controller与I2C Device传输数据。 在Linux中： 怎么表示I2C Controller 一个芯片里可能有多个I2C Controller，比如第0个、第1个、…… 对于使用者，只要确定是第几个I2C Controller即可 使用i2c_adapter表示一个I2C BUS，或称为I2C Controller(使用面向对象的方式) 里面有2个重要的成员： nr：第几个I2C BUS(I2C Controller) i2c_algorithm，里面有该I2C BUS的传输函数，用来收发I2C数据 i2c_adapter i2c_algorithm 怎么表示I2C Device 一个I2C Device，一定有设备地址 它连接在哪个I2C Controller上，即对应的i2c_adapter是什么 使用i2c_client来表示一个I2C Device 怎么表示要传输的数据 在上面的i2c_algorithm结构体中可以看到要传输的数据被称为：i2c_msg i2c_msg i2c_msg中的flags用来表示传输方向：bit 0等于I2C_M_RD表示读，bit 0等于0表示写 一个i2c_msg要么是读，要么是写 举例：设备地址为0x50的EEPROM，要读取它里面存储地址为0x10的一个字节，应该构造几个i2c_msg？ 要构造2个i2c_msg 第一个i2c_msg表示写操作，把要访问的存储地址0x10发给设备 第二个i2c_msg表示读操作 代码如下 12345678910111213u8 data_addr = 0x10; i8 data; struct i2c_msg msgs[2]; msgs[0].addr = 0x50; msgs[0].flags = 0; msgs[0].len = 1; msgs[0].buf = &amp;data_addr; msgs[1].addr = 0x50; msgs[1].flags = I2C_M_RD; msgs[1].len = 1; msgs[1].buf = &amp;data; 内核怎么传输数据 使用一句话概括I2C传输： APP通过I2C Controller与I2C Device传输数据 APP通过i2c_adapter与i2c_client传输i2c_msg 内核函数i2c_transfer i2c_msg里含有addr，所以这个函数里不需要i2c_client int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num) 无需编写驱动直接访问设备_I2C-Tools介绍 APP访问硬件肯定是需要驱动程序的，对于I2C设备，内核提供了驱动程序 drivers/i2c/i2c-dev.c ，通过它可以直接使用下面的I2C控制器 驱动程序来访问I2C设备 使用一句话概括I2C传输：APP通过I2C Controller与I2C Device传输数据。 所以使用I2C-Tools时也需要指定： 哪个I2C控制器(或称为I2C BUS、I2C Adapter) 哪个I2C设备(设备地址) 数据：读还是写、数据本身 12345678910111213141516171819AP3216C是红外、光强、距离三合一的传感器，以读出光强、距离值为例，步骤如下：复位：往寄存器0写入0x4使能：往寄存器0写入0x3读光强：读寄存器0xC、0xD得到2字节的光强读距离：读寄存器0xE、0xF得到2字节的距离值AP3216C的设备地址是0x1E，假设节在I2C BUS0上，操作命令如下：i2cdetect 查看当前i2c设备用法: i2cdetect 0 或者 i2cdetect -l使用SMBus协议i2cset -f -y 0 0x1e 0 0x4 i2cset -f -y 0 0x1e 0 0x3 i2cget -f -y 0 0x1e 0xc w i2cget -f -y 0 0x1e 0xe w 使用I2C协议i2ctransfer -f -y 0 w2@0x1e 0 0x4 i2ctransfer -f -y 0 w2@0x1e 0 0x3 i2ctransfer -f -y 0 w1@0x1e 0xc r2 i2ctransfer -f -y 0 w1@0x1e 0xe r2 访问I2C设备的俩种方式 I2C-Tools可以通过SMBus来访问I2C设备，也可以使用一般的I2C协议来访问I2C设备。 使用一句话概括I2C传输：APP通过I2C Controller与I2C Device传输数据。 在APP里，有这几个问题： 怎么指定I2C控制器？ i2c-dev.c提供为每个I2C控制器(I2C Bus、I2C Adapter)都生成一个设备节点：/dev/i2c-0、/dev/i2c-1等待 open某个/dev/i2c-X节点，就是去访问该I2C控制器下的设备 怎么指定I2C设备？ 通过ioctl指定I2C设备的地址 ioctl(fifile, I2C_SLAVE, address) 如果该设备已经有了对应的设备驱动程序，则返回失败 ioctl(fifile, I2C_SLAVE_FORCE, address) 如果该设备已经有了对应的设备驱动程序 但是还是想通过i2c-dev驱动来访问它 则使用这个ioctl来指定I2C设备地址 怎么传输数据？ 两种方式 一般的I2C方式：ioctl(fifile, I2C_RDWR, &amp;rdwr) SMBus方式：ioctl(fifile, I2C_SMBUS, &amp;args) 源码 i2c方式 SMBus方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;sys/ioctl.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/i2c-dev.h&gt;#include &lt;i2c/smbus.h&gt;#include &quot;i2cbusses.h&quot;#include &lt;time.h&gt;/* ./at24c02 &lt;i2c_bus_number&gt; w &quot;100ask.taobao.com&quot; * ./at24c02 &lt;i2c_bus_number&gt; r */int main(int argc, char **argv)&#123; unsigned char dev_addr = 0x50;//设备地址 unsigned char mem_addr = 0;//存储空间地址 unsigned char buf[32]; int file; char filename[20]; unsigned char *str; int ret; struct timespec req; if (argc != 3 &amp;&amp; argc != 4) &#123; printf(&quot;Usage:\\n&quot;); printf(&quot;write eeprom: %s &lt;i2c_bus_number&gt; w string\\n&quot;, argv[0]); printf(&quot;read eeprom: %s &lt;i2c_bus_number&gt; r\\n&quot;, argv[0]); return -1; &#125; file = open_i2c_dev(argv[1][0]-&#x27;0&#x27;, filename, sizeof(filename), 0); if (file &lt; 0) &#123; printf(&quot;can&#x27;t open %s\\n&quot;, filename); return -1; &#125; if (set_slave_addr(file, dev_addr, 1)) &#123; printf(&quot;can&#x27;t set_slave_addr\\n&quot;); return -1; &#125; if (argv[2][0] == &#x27;w&#x27;) &#123; // write str: argv[3] str = argv[3]; req.tv_sec = 0; req.tv_nsec = 20000000; /* 20ms */ while (*str) &#123; // mem_addr, *str // mem_addr++, str++ ret = i2c_smbus_write_byte_data(file, mem_addr, *str); if (ret) &#123; printf(&quot;i2c_smbus_write_byte_data err\\n&quot;); return -1; &#125; // wait tWR(10ms) nanosleep(&amp;req, NULL); mem_addr++; str++; &#125; ret = i2c_smbus_write_byte_data(file, mem_addr, 0); // string end char if (ret) &#123; printf(&quot;i2c_smbus_write_byte_data err\\n&quot;); return -1; &#125; &#125; else &#123; // read ret = i2c_smbus_read_i2c_block_data(file, mem_addr, sizeof(buf), buf); if (ret &lt; 0) &#123; printf(&quot;i2c_smbus_read_i2c_block_data err\\n&quot;); return -1; &#125; buf[31] = &#x27;\\0&#x27;; printf(&quot;get data: %s\\n&quot;, buf); &#125; return 0; &#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://blogs.leechee.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blogs.leechee.top/tags/C-C/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://blogs.leechee.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"学习","slug":"学习","permalink":"https://blogs.leechee.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"嵌入式驱动","slug":"嵌入式驱动入门","date":"2021-01-05T15:21:13.000Z","updated":"2023-01-11T01:57:43.235Z","comments":true,"path":"posts/5c8c37e6/","link":"","permalink":"https://blogs.leechee.top/posts/5c8c37e6/","excerpt":"","text":"[TOC] Hello World 回顾 文件IO 应用程序去调用glibc所提供的open read write函数,最终会进入到内核里面, 调用到内核里的sysopen sysread函数 访问普通文件: 普通文件访问代码, 经过文件系统操作 访问驱动程序: 调用驱动程序对应代码 驱动程序也提供函数 drv_open drv_read函数, 当应用程序去打开某个设备节点,最终会调用驱动程序提供的函数 如何编写驱动程序? ① 确定主设备号，也可以让内核分配(0 是让内核分配) ② 定义自己的file_operations结构体 ③ 实现对应的drv_open/drv_read/drv_write等函数，填入file_operations结构体 ④ 把file_operations结构体告诉(注册)内核：register_chrdev [这里可以看成是一个数组, 需要注册进某个位置,需要主设备号 和副设备号] ⑤ 谁来注册驱动程序啊？得有一个入口函数(去注册驱动函数)：安装驱动程序时，就会去调用这个入口函数 ⑥ 有入口函数就应该有出口函数：卸载驱动程序时，出口函数调用unregister_chrdev (从数组里面去掉) ⑦ 其他完善：提供设备信息，自动创建设备节点：class_create, device_create 驱动怎么操作硬件？通过ioremap映射寄存器的物理地址得到虚拟地址，读写虚拟地址。 驱动怎么和APP传输数据？通过copy_to_user、copy_from_user这2个函数。 内核中的表示 应用程序调用open函数打开一个文件时, 得到一个整数返回值, 整数会对应内核中的一个结构体(struct file) 打开某个设备节点时, 会根据这个设备节点的主设备号, 在内核的数组里面找到file_operations结构体, 这个结构体里面有驱动程序的open read函数等等, 会去调用这个结构体里面的函数 可以猜测，我们使用open打开文件时，传入的flags、mode等参数会被记录在内核中对应的struct file结构体里(f_flags、f_mode)： int open(const char *pathname, int flags, mode_t mode); 去读写文件时，文件的当前偏移地址也会保存在struct file结构体的f_pos成员里。 实例 参考driver/char中的程序，包含头文件，写框架，传输数据： ​ A. 驱动中实现open, read, write, release，APP调用这些函数时，都打印内核信息 ​ B. APP调用write函数时，传入的数据保存在驱动中 ​ C. APP调用read函数时，把驱动中保存的数据返回给APP 可以参考misc.c 是一个比较经典的字符驱动程序 驱动程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/major.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/seq_file.h&gt;#include &lt;linux/stat.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/tty.h&gt;#include &lt;linux/kmod.h&gt;#include &lt;linux/gfp.h&gt;/* 1. 确定主设备号 */static int major = 0; //让内核给我们分配static char kernel_buf[1024];static struct class *hello_class;#define MIN(a, b) (a &lt; b ? a : b)/* 3. 实现对应的open/read/write等函数，填入file_operations结构体 */static ssize_t hello_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)&#123; int err; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); err = copy_to_user(buf, kernel_buf, MIN(1024, size));//给用户空间的buf return MIN(1024, size);&#125;static ssize_t hello_drv_write (struct file *file, const char __user *buf, size_t size, loff_t *offset)&#123; int err; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); err = copy_from_user(kernel_buf, buf, MIN(1024, size)); return MIN(1024, size);&#125;static int hello_drv_open (struct inode *node, struct file *file)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); return 0;&#125;static int hello_drv_close (struct inode *node, struct file *file)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); return 0;&#125;//static 防止污染命名空间/* 2. 定义自己的file_operations结构体 */static struct file_operations hello_drv = &#123; .owner = THIS_MODULE, .open = hello_drv_open, .read = hello_drv_read, .write = hello_drv_write, .release = hello_drv_close,&#125;;/* 4. 把file_operations结构体告诉内核：注册驱动程序 *//* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */static int __init hello_init(void)&#123; int err; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); major = register_chrdev(0, &quot;hello&quot;, &amp;hello_drv); /* /dev/hello */ //返回主设备号 hello_class = class_create(THIS_MODULE, &quot;hello_class&quot;); err = PTR_ERR(hello_class); if (IS_ERR(hello_class)) &#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, &quot;hello&quot;); return -1; &#125; device_create(hello_class, NULL, MKDEV(major, 0), NULL, &quot;hello&quot;); /* /dev/hello */ return 0;&#125;/* 6. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数 */static void __exit hello_exit(void)&#123; printk(&quot;%s %s line %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); device_destroy(hello_class, MKDEV(major, 0)); class_destroy(hello_class); unregister_chrdev(major, &quot;hello&quot;);&#125;/* 7. 其他完善：提供设备信息，自动创建设备节点 */module_init(hello_init);//修饰成入口函数module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;);//遵守GPL协议 测试程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556测试程序要实现写、读功能：A. ./hello_drv_test -w wiki.100ask.net // 把字符串“wiki.100ask.net”发给驱动程序B. ./hello_drv_test -r // 把驱动中保存的字符串读回来#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;/* * ./hello_drv_test -w abc * ./hello_drv_test -r */int main(int argc, char **argv)&#123; int fd; char buf[1024]; int len; /* 1. 判断参数 */ if (argc &lt; 2) &#123; printf(&quot;Usage: %s -w &lt;string&gt;\\n&quot;, argv[0]); printf(&quot; %s -r\\n&quot;, argv[0]); return -1; &#125; /* 2. 打开文件 */ fd = open(&quot;/dev/hello&quot;, O_RDWR); if (fd == -1) &#123; printf(&quot;can not open file /dev/hello\\n&quot;); return -1; &#125; /* 3. 写文件或读文件 */ if ((0 == strcmp(argv[1], &quot;-w&quot;)) &amp;&amp; (argc == 3)) &#123; len = strlen(argv[2]) + 1; len = len &lt; 1024 ? len : 1024; write(fd, argv[2], len); &#125; else &#123; len = read(fd, buf, 1024); buf[1023] = &#x27;\\0&#x27;; printf(&quot;APP read : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; 那么怎么去编译驱动程序和测试程序呢 1234567891011121314151617181920# 1. 使用不同的开发板内核时, 一定要修改KERN_DIR# 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:# 2.1 ARCH, 比如: export ARCH=arm64# 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-# 2.3 PATH, 比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin # 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,# 请参考各开发板的高级用户使用手册KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4all: make -C $(KERN_DIR) M=`pwd` modules #进入到内核目录 编译当前目录的xx.o文件 编译成驱动程序 $(CROSS_COMPILE)gcc -o hello_drv_test hello_drv_test.c #bclean: make -C $(KERN_DIR) M=`pwd` modules clean rm -rf modules.order rm -f hello_drv_testobj-m += hello_drv.o 然后make 注意配置 将生成ko文件和 可执行文件传到板子 使用insmod xx.ko 来装载驱动 cat /proc/devices 来查看驱动是否添加 lsmod 查看内核中已经加载的驱动程序 ls /dev/xx -l 查看我们的设备节点 (主设备号等等) rmmod 卸载驱动 知识补充 module_init/module_exit的实现 register_chrdev的内部实现 class_destroy/device_create浅析 GPIO GPIO引脚操作方法 GPIO: General-purpose input/output，通用的输入输出口 GPIO模块一般结构 ​ a. 有多组GPIO，每组有多个GPIO ​ b. 使能：电源/时钟 ​ c. 模式(Mode)：引脚可用于GPIO或其他功能 ​ d. 方向：引脚Mode设置为GPIO时，可以继续设置它是输出引脚，还是输入引脚 ​ e. 数值：对于输出引脚，可以设置寄存器让它输出高、低电平 对于输入引脚，可以读取寄存器得到引脚的当前电平 1234567891011举例子:一个芯片, 有n组GPIO, 每组gpio里面有若干个引脚, 我们以目的为导向,想让一个引脚输出高低电平.从数据流向反向来看:②数据来自io_mux(多路选择器), 一个引脚又可能来自gpio模块,也有可能来自uart,所以在这里需要去选择引脚来自 于哪里,这称为引脚的模式选择 pins_mode①假设这个引脚来自gpio模块,需要使能gpio模块,需要去设置power/clock control Enable为了省电,这些模块有可能默认下是关闭的,使用的话要设置p/c control来向这些模块提供电源,提供clock③设置引脚的输入输出功能(方向)④设置数据让他输出高低电平这些操作都需要读写寄存器配图如下 GPIO寄存器操作 操作寄存器原则: 不要去影响到其他位 举例: 数据寄存器 想让一个引脚输出高电平,需要把这个寄存器的bit0设置为1 ①读出这个寄存器的值 val = data_reg (读出来) ②修改这个值,让这个bit0等于1 val = val | 1 (修改) ③写回去 datareg_reg = val (写) 能不能直接写呢? data_reg = 1 不可以, bit0 = 1了,但是bit1 2 3都被修改了. 影响到了其他位 更高效的办法: (set-and-clear protocal)有些处理器,对于这个寄存器又引出了俩个寄存器, 一个是设置寄存器set_reg,清除寄存器clr_reg(和set_reg同理)设置bit0等于1,可以去把寄存器读出来修改bit0写回去也可以直接操作这个寄存器bit0=1就可以了 set_reg=1或者 0和2 set_reg=(1)|(1&lt;&lt;2), 等于0的寄存器没有任何效果,等于1的位会影响实际的数据寄存器 IMX6ULL的GPIO操作 拿到新的芯片,需要去看芯片手册,找到gpio章节, GPIO的控制涉及4大模块：CCM、IOMUXC、GPIO模块本身，框图如下： CCM: Clock Controller Module (时钟控制模块) IOMUXC : IOMUX Controller，IO复用控制器 GPIO: General-purpose input/output，通用的输入输出口 CCM 设定某个寄存器来使能某一组IO IOMUXC 设置寄存器来选择某个引脚(每个引脚对应俩个寄存器:MUX_CTL用来选择脚功能 PAD_CTL是否使用上拉 下拉电阻等 等信息) 设置gpio里面的寄存器 设置gpio.GDIR让这个引脚工作于输入或者输出模式 输出模式:把值写道gpio.DR寄存器, 让这个引脚输出高低电平 输入模式: 读gpio.PSR寄存器, 得到这个引脚当前状态 其他都是中断相关的 设置IOMUXC 来把某个引脚设置GPIO功能 看芯片手册 地址: 基地址 + 偏移地址 = 绝对地址 编程–读GPIO ① 设置CCM_CCGRx寄存器中某位使能对应的GPIO模块 // 默认是使能的 ② 设置IOMUX来选择引脚用于GPIO ③ 设置GPIOx_GDIR中某位为0，把该引脚设置为输入功能 ④ 读GPIOx_DR或GPIOx_PSR得到某位的值（读GPIOx_DR返回的是GPIOx_PSR的值） 编程–写GPIO ① 设置CCM_CCGRx寄存器中某位使能对应的GPIO模块 // 默认是使能的 ② 设置IOMUX来选择引脚用于GPIO ③ 设置GPIOx_GDIR中某位为1，把该引脚设置为输出功能 ④ 写GPIOx_DR某位的值 需要注意的是，你可以设置该引脚的loopback(回环)功能，这样就可以从GPIOx_PSR中读到引脚的有实电平；你从GPIOx_DR中读回的只是上次设置的值，它并不能反应引脚的真实电平，比如可能因为硬件故障导致该引脚跟地短路了，你通过设置GPIOx_DR让它输出高电平并不会起效果。 LED驱动 先看原理图 GPIO5_3 再看芯片手册：使能GPIO5 对于IMX6ULL，GPIO5默认使能，无需设置 CCM_CCGR1地址：0x020C4000 + 0x6C 设置GPIO5_3为GPIO 需要配置为gpio模式gpio5_IO03, 需要设置IOMUXC寄存器 设置GPIO5_3为输出 将gpio_gdir设置成1 变成输出引脚 设置GPIOB0的输出电平 gpio5_DR 输出1就在这一位写入1 字符设备驱动框架 在Linux系统中, 应用程序只能通过一些标准的接口open read 等访问文件,进而访问驱动程序, 最终访问到硬件 应用程序要调用open,那么就提供驱动程序的open函数 LED驱动模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/poll.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/wait.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;asm/io.h&gt;static int major;static struct class *led_class;static ssize_t led_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos)&#123; char val; /* copy_from_user : get data from app */ copy_from_user(&amp;val, buf, 1); /* to set gpio register寄存器: out 1/0 */ if (val) &#123; /* set gpio to let led on */ &#125; else &#123; /* set gpio to let led off */ &#125; return 1;&#125;static int led_open(struct inode *inode, struct file *filp)&#123; /* enable gpio * configure pin as gpio * configure gpio as output */ return 0;&#125;static struct file_operations led_fops = &#123; .owner = THIS_MODULE, .write = led_write, .open = led_open,&#125;;/* 入口函数 */static int __init led_init(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); major = register_chrdev(0, &quot;100ask_led&quot;, &amp;led_fops); //led_open write都要访问gpio的寄存器, 都要用到虚拟地址, 虚拟地址在哪里映射呢? /* ioremap */ led_class = class_create(THIS_MODULE, &quot;myled&quot;); device_create(led_class, NULL, MKDEV(major, 0), NULL, &quot;myled&quot;); /* /dev/myled */ return 0;&#125;static void __exit led_exit(void)&#123; device_destroy(led_class, MKDEV(major, 0)); class_destroy(led_class); unregister_chrdev(major, &quot;100ask_led&quot;);&#125;module_init(led_init);module_exit(led_exit);MODULE_LICENSE(&quot;GPL&quot;); 以IMX6ULL为例的LED驱动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/poll.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/wait.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/device.h&gt;#include &lt;asm/io.h&gt;static int major;static struct class *led_class;/* registers */// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 地址：0x02290000 + 0x14static volatile unsigned int *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;// GPIO5_GDIR 地址：0x020AC004 设置功能static volatile unsigned int *GPIO5_GDIR; //GPIO5_DR 地址：0x020AC000 设置输出高低电平static volatile unsigned int *GPIO5_DR;static ssize_t led_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos)&#123; char val; int ret; /* copy_from_user : get data from app */ ret = copy_from_user(&amp;val, buf, 1); /* to set gpio register: out 1/0 */ if (val) &#123; /* set gpio to let led on */ *GPIO5_DR &amp;= ~(1&lt;&lt;3); &#125; else &#123; /* set gpio to let led off */ *GPIO5_DR |= (1&lt;&lt;3); &#125; return 1;&#125;static int led_open(struct inode *inode, struct file *filp)&#123; /* enable gpio5 * configure gpio5_io3 as gpio * configure gpio5_io3 as output */ *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 &amp;= ~0xf;//清掉最低的4位 *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 |= 0x5;//101 *GPIO5_GDIR |= (1&lt;&lt;3); return 0;&#125;static struct file_operations led_fops = &#123; .owner = THIS_MODULE, .write = led_write, .open = led_open,&#125;;/* 入口函数 */static int __init led_init(void)&#123; printk(&quot;%s %s %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__); major = register_chrdev(0, &quot;100ask_led&quot;, &amp;led_fops); /* ioremap 映射*/ // IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 地址：0x02290000 + 0x14 IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(0x02290000 + 0x14, 4); //ioremap映射的时候以页为单位 ,4k // GPIO5_GDIR 地址：0x020AC004 GPIO5_GDIR = ioremap(0x020AC004, 4); //GPIO5_DR 地址：0x020AC000 GPIO5_DR = ioremap(0x020AC000, 4); led_class = class_create(THIS_MODULE, &quot;myled&quot;); device_create(led_class, NULL, MKDEV(major, 0), NULL, &quot;myled&quot;); /* /dev/myled */ return 0;&#125;static void __exit led_exit(void)&#123; iounmap(IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3); iounmap(GPIO5_GDIR); iounmap(GPIO5_DR); device_destroy(led_class, MKDEV(major, 0)); class_destroy(led_class); unregister_chrdev(major, &quot;100ask_led&quot;);&#125;module_init(led_init);module_exit(led_exit);MODULE_LICENSE(&quot;GPL&quot;); 怎么访问寄存器 知道寄存器的地址. int *p = addr 读取寄存器是为了访问硬件 volatile: 对寄存器操作不能去优化 告诉编译器不要随便优化我 驱动程序中不可以使用物理地址来访问寄存器, 需要映射成虚拟地址 测试代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;v// ledtest /dev/myled on// ledtest /dev/myled offint main(int argc, char **argv)&#123; int fd; char status = 0; if (argc != 3) &#123; printf(&quot;Usage: %s &lt;dev&gt; &lt;on|off&gt;\\n&quot;, argv[0]); printf(&quot; eg: %s /dev/myled on\\n&quot;, argv[0]); printf(&quot; eg: %s /dev/myled off\\n&quot;, argv[0]); return -1; &#125; // open fd = open(argv[1], O_RDWR); if (fd &lt; 0) &#123; printf(&quot;can not open %s\\n&quot;, argv[0]); return -1; &#125; // write if (strcmp(argv[2], &quot;on&quot;) == 0) &#123; status = 1; &#125; write(fd, &amp;status, 1); return 0; &#125; LED驱动程序框架 字符设备驱动框架 对于LED驱动，我们想要什么样的接口？ LED驱动要怎么写，才能支持多个板子？分层 把驱动拆分为通用的框架(leddrv.c)、具体的硬件操作(board_X.c)： 在leddrv.c里面调用单板提供的led初始化函数,调用单板提供的ctl函数, 每个单板都实现这俩个同名的函数. 当想给A提供驱动程序时, 编译leddrv.c和board_A.c 以面向对象的思想，改进代码： 抽象出一个结构体： 抽象出一个led_operations结构体, 里面有初始化函数有控制函数, 单板实现下图所示结构体(右边), 里面有初始化成员有控制成员 等于自己的函数. 上层的leddrv.c代码调用底层提供的结构体, 调用里面的函数, 当编译驱动程序时, 要把公共部分和单板部分编译成一个.ko文件. 1234struct led_operations &#123;int (*init) (int which); /* 初始化LED,which-哪个LED */int (*ctl) (int which, int status); /* 控制LED,which-哪个LED，status:1-亮,0-灭*/&#125;; 每个单板相关的board_X.c实现自己的led_operations结构体，供上层的leddrv.c调用： 代码(以面向对象为例) D:\\imx6ull\\01_all_series_quickstart\\05_嵌入式Linux驱动开发基础知识\\source\\02_led_drv\\01_led_drv_template 具体单板的LED驱动 怎么写LED驱动程序 ① 看原理图确定引脚，确定引脚输出什么电平才能点亮/熄灭LED ② 看主芯片手册，确定寄存器操作方法：哪些寄存器？哪些位？地址是？ ③ 编写驱动：先写框架，再写硬件操作的代码 注意：在芯片手册中确定的寄存器地址被称为物理地址，在Linux内核中无法直接使用。需要使用内核提供的ioremap把物理地址映射为虚拟地址，使用虚拟地址。 123456789101112131415161718192021222324252627282930313233ioremap函数的使用：物理地址映射为虚拟地址① 函数原型： void __iomem *ioremap(resource_size_t res_cokkie, size_t size)使用时，要包含头文件：#include &lt;asm/io.h&gt; ② 它的作用：把物理地址phys_addr开始的一段空间(大小为size)，映射为虚拟地址；返回值是该段虚拟地址的首地址。 virt_addr = ioremap(phys_addr, size);实际上，它是按页(4096字节)进行映射的，是整页整页地映射的。假设phys_addr = 0x10002，size=4，ioremap的内部实现是：a. phys_addr按页取整，得到地址0x10000b. size按页取整，得到4096c. 把起始地址0x10000，大小为4096的这一块物理地址空间，映射到虚拟地址空间， 假设得到的虚拟空间起始地址为0xf0010000d. 那么phys_addr = 0x10002对应的virt_addr = 0xf0010002③ 不再使用该段虚拟地址时，要iounmap(virt_addr)： void iounmap(volatile void __iomem *cokkie)volatile的使用：① 编译器很聪明，会帮我们做些优化，比如：int a;a = 0; // 这句话可以优化掉，不影响a的结果a = 1;② 有时候编译器会自作聪明，比如：int *p = ioremap(xxxx, 4); // GPIO寄存器的地址*p = 0; // 点灯，但是这句话被优化掉了*p = 1; // 灭灯③ 对于上面的情况，为了避免编译器自动优化，需要加上volatile，告诉它“这是容易出错的，别乱优化”：volatile int *p = ioremap(xxxx, 4); // GPIO寄存器的地址*p = 0; // 点灯，这句话不会被优化掉*p = 1; // 灭灯 为什么需要ioremap? 运行右上角代码俩次, 那么在内存中必定有俩份代码, 同一份程序运行时打印出来的全局变量地址一样嘛? 如图, A保存在物理地址addrA上, B保存在物理地址addrB上, 但是他们打印的地址都是一样的, 显然代码打印的并不是物理地址,打印的是CPU看到的虚拟地址, CPU使用同一个地址addr来访问这俩个程序, 运行程序A时, MMU里面会有一个pid, 根据A的进程号 把CPU这个addr转换成程序A这个变量的物理地址, 对B也一样. 对于程序A和B, 虽然CPU发出的是同一份地址, 他们的进程号不一样导致了他们的物理地址不一样. 由MMU实现从虚拟地址到物理地址的转换. MMU: 内存管理单元. 地址映射 权限保护 : 各个程序地址间需要有互相隔离的作用,也不能去直接访问硬件. CPU发出的addr, 能不能访问到硬件得由MMU来决定. 对内核也是一样的, 内核能不能访问到硬件也是由MMU来决定, MMU把物理地址映射成虚拟地址, 内核才能使用虚拟地址去访问这些硬件. 程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/major.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/seq_file.h&gt;#include &lt;linux/stat.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/tty.h&gt;#include &lt;linux/kmod.h&gt;#include &lt;linux/gfp.h&gt;#include &lt;asm/io.h&gt;#include &quot;led_opr.h&quot;static volatile unsigned int *CCM_CCGR1 ;static volatile unsigned int *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;static volatile unsigned int *GPIO5_GDIR ;static volatile unsigned int *GPIO5_DR ;static int board_demo_led_init (int which) /* 初始化LED, which-哪个LED */ &#123; unsigned int val; //printk(&quot;%s %s line %d, led %d\\n&quot;, __FILE__, __FUNCTION__, __LINE__, which); if (which == 0) &#123; if (!CCM_CCGR1) &#123; CCM_CCGR1 = ioremap(0x20C406C, 4); IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(0x2290014, 4); GPIO5_GDIR = ioremap(0x020AC000 + 0x4, 4); GPIO5_DR = ioremap(0x020AC000 + 0, 4); &#125; /* GPIO5_IO03 */ /* a. 使能GPIO5 * set CCM to enable GPIO5 * CCM_CCGR1[CG15] 0x20C406C * bit[31:30] = 0b11 */ *CCM_CCGR1 |= (3&lt;&lt;30); /* b. 设置GPIO5_IO03用于GPIO * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 * to configure GPIO5_IO03 as GPIO * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 0x2290014 * bit[3:0] = 0b0101 alt5 */ val = *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;//这样只做一次读操作 val &amp;= ~(0xf); val |= (5); *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = val; /* b. 设置GPIO5_IO03作为output引脚 * set GPIO5_GDIR to configure GPIO5_IO03 as output * GPIO5_GDIR 0x020AC000 + 0x4 * bit[3] = 0b1 */ *GPIO5_GDIR |= (1&lt;&lt;3); &#125; return 0;&#125;static int board_demo_led_ctl (int which, char status) /* 控制LED, which-哪个LED, status:1-亮,0-灭 */&#123; //printk(&quot;%s %s line %d, led %d, %s\\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &quot;on&quot; : &quot;off&quot;); if (which == 0) &#123; if (status) /* on: output 0*/ &#123; /* d. 设置GPIO5_DR输出低电平 * set GPIO5_DR to configure GPIO5_IO03 output 0 * GPIO5_DR 0x020AC000 + 0 * bit[3] = 0b0 */ *GPIO5_DR &amp;= ~(1&lt;&lt;3); &#125; else /* off: output 1*/ &#123; /* e. 设置GPIO5_IO3输出高电平 * set GPIO5_DR to configure GPIO5_IO03 output 1 * GPIO5_DR 0x020AC000 + 0 * bit[3] = 0b1 */ *GPIO5_DR |= (1&lt;&lt;3); &#125; &#125; return 0;&#125;static struct led_operations board_demo_led_opr = &#123; .num = 1, .init = board_demo_led_init, .ctl = board_demo_led_ctl,&#125;;struct led_operations *get_board_led_opr(void)&#123; return &amp;board_demo_led_opr;&#125; 驱动设计的思想 Linux驱动 = 驱动框架 + 硬件操作 = 驱动框架 + 单片机 面向对象 字符设备驱动程序抽象出一个file_operations结构体； 我们写的程序针对硬件部分抽象出led_operations结构体。 分层 上下分层，比如我们前面写的LED驱动程序就分为2层： ① 上层实现硬件无关的操作，比如注册字符设备驱动：leddrv.c ② 下层实现硬件相关的操作，比如board_A.c实现单板A的LED操作 通过分层的思想, 写不同板子的时候比较省时省力. 只需专注单板硬件操作 分离 在之前实现的单板程序中, 一些函数变量和芯片给绑定太紧了, 换一个灯啥的换一个引脚就需要重新编写代码 在board_A.c中，实现了一个led_operations，为LED引脚实现了初始化函数、控制函数： 12345static struct led_operations board_demo_led_opr = &#123; .num = 1, .init = board_demo_led_init, .ctl = board_demo_led_ctl,&#125;; 如果硬件上更换一个引脚来控制LED怎么办？你要去修改上面结构体中的init、ctl函数。 实际情况是，每一款芯片它的GPIO操作都是类似的。比如：GPIO1_3、GPIO5_4这2个引脚接到LED： GPIO1_3属于第1组，即GPIO1。 有方向寄存器DIR、数据寄存器DR等，基础地址是addr_base_addr_gpio1。 设置为output引脚：修改GPIO1的DIR寄存器的bit3。 设置输出电平：修改GPIO1的DR寄存器的bit3。 GPIO5_4属于第5组，即GPIO5。 有方向寄存器DIR、数据寄存器DR等，基础地址是addr_base_addr_gpio5。 设置为output引脚：修改GPIO5的DIR寄存器的bit4。 设置输出电平：修改GPIO5的DR寄存器的bit4。 既然引脚操作那么有规律，并且这是跟主芯片相关的，那可以针对该芯片写出比较通用的硬件操作代码。 比如board_A.c使用芯片chipY，那就可以写出：chipY_gpio.c，它实现芯片Y的GPIO操作，适用于芯片Y的所有GPIO引脚。 使用时，我们只需要在board_A_led.c中指定使用哪一个引脚即可。 程序结构如下： 某款芯片可以写出gpio程序去支持所有gpio的操作,当想操作某一个引脚的时候, 告诉它需要用哪个gpio. 左右分离,左边定义资源,右边是硬件通用代码 以面向对象的思想，在board_A_led.c中实现led_resouce结构体，它定义“资源”──要用哪一个引脚。 在chipY_gpio.c中仍是实现led_operations结构体，它要写得更完善，支持所有GPIO。 代码查看文件夹\\source\\02_led_drv\\03_led_drv_template_seperate 总线设备驱动模型 驱动编写的方法 传统写法 定义file_operation结构体,在里面提供应用程序要用到的函数, 在驱动程序里提供对应的openread等,然后在驱动程序里操作那些寄存器就可以了. 使用哪个引脚，怎么操作引脚，都写死在代码中。 最简单，不考虑扩展性，可以快速实现功能。 修改引脚时，需要重新编译。 总线设备驱动模型 硬件资源用一个平台platform_device来表示(定义了引脚,寄存器), 对于硬件的操作放在platform_driver里面(固定的驱动程序) 用一个总线Bus来管理, 总线的左边是device, 右边是drv.他们俩俩匹配, 这是对分离的设计思想更好的实现. 以前抽象出了led_resource,只能支持led. 现在在platform_device可以存入各种资源 设备树 存在dts文件,存入了驱动的引脚等信息, 会被编译成dtb文件传递给内核, 内核会解析这个文件并构造出一系列的platform_device. 即dts、dtb是放在内核之外的,保持了Linux代码优雅, 即总线设备模型和设备树是类似的,并不涉及驱动程序的核心(分配设置注册file_operation,ioremap操作寄存器), 设备仅仅是指定硬件使用哪些引脚,哪个资源. Bus/Dev/Drv模型 首先在内核里面有一个总线platform_bus_type, 这个总线是一个虚拟的总线,它有俩个链表, 左边是设备链表,右边是驱动链表,当我们去注册一个平台设备时,就会放入左边的链表, 注册一个平台driver时放入右边的链表. 这些结构体放入链表之后就会马上跟对方的成员一一比较, 比如: 将一个platform_device注册进内核里面, 同时会把drv里面一个个比较一下, 如果匹配成功就会调用内个drv里面的probe函数. 当注册一个platform_driver时,同时也会去和设备链表一一比较, 如果匹配成功就调用drv里面的probe函数去处理内个device. 如何知道是否匹配成功? 总线这里platform_bus_type里有一个match函数, 用来判断dev和drv是否匹配. dev里面有成员name和driver_override(非它不嫁), drv里面name放在struct device_driver driver成员里面, 还有数组id_table,表示能支持哪些设备. 比较过程: dev里面如果定义了driver_override,就会根据这个名字去查找drv, 如果drv里的name等于的话表示找到. 如果没有定义driver_override就进行第二次比较, 如果drv的id_table不是空的, 就使用dev的name跟id_table里每一项进行比较, 如果吻合的话就表明这俩项是匹配的, 如果id_table为空或者匹配不成功就会用dev里的name和drv里的name去比较(实际中这种比较用的比较多,id_table也多,但使用driver_override比较少). 启动过程是怎么启动的? 无论是注册平台dev还是平台drv,都会先放入链表然后从另外的链表把对方的每个成员一一比较 调用关系 123456789101112131415161718192021platform_device_registerplatform_device_add device_add bus_add_device // 放入链表 bus_probe_device // probe枚举设备，即找到匹配的(dev, drv) device_initial_probe __device_attach bus_for_each_drv(...,__device_attach_driver,...) __device_attach_driver driver_match_device(drv, dev) // 是否匹配 driver_probe_device // 调用drv的probeplatform_driver_register__platform_driver_register driver_register bus_add_driver // 放入链表 driver_attach(drv) bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach); __driver_attach driver_match_device(drv, dev) // 是否匹配 driver_probe_device // 调用drv的probe 程序编写 ①分配/设置/注册platform_device结构体 在里面定义所用资源，指定设备名字。 ②分配/设置/注册platform_driver结构体 在其中的probe函数里，分配/设置/注册file_operations结构体，并从platform_device中确实所用硬件资源。 指定platform_driver的名字。 LED驱动[总线设备驱动模型] 需要实现的框架 代码 12\\source\\02_led_drv\\04_led_drv_template_bus_dev_drv 需要不断熟悉!!! 驱动内部调用流程 led_dev.c的入口函数开始, register_chrdev [ led_dev里面有led_drv_open/read函数,但是没有和硬件挂钩, p_led_opr结构体还是空的 ] -&gt;创建类 设备相关board_A_led.c [ 入口函数里面去注册platform_device_register ] chip_demo_gpio.c [ 入口函数里面注册platform_driver_register并且调用register_led_operations向上层(leddrv.c)提供了led的操作函数,主要在platform_driver里面的probe函数,当platform_driver和同名的platform_device同名之后,chip_demo_gpio_led_probe函数就被调用 ( 从平台设备里面获得资源, 把那些引脚记录下来同时调用led_device_create函数创建device,这样系统会帮我们创建设备节点,应用程序才可以打开节点 ) ] 应用程序打开节点之后,就会进入最上一层调用open函数 ( led_drv_open ), 调用init进入到底层init函数(board_demo_led_init)","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://blogs.leechee.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blogs.leechee.top/tags/C-C/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://blogs.leechee.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"学习","slug":"学习","permalink":"https://blogs.leechee.top/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Drivers","slug":"Drivers","permalink":"https://blogs.leechee.top/tags/Drivers/"}]},{"title":"Hello Hex","slug":"hello-world","date":"2021-01-01T15:21:13.000Z","updated":"2023-01-11T14:18:53.645Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"https://blogs.leechee.top/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"HexoPost","slug":"HexoPost","permalink":"https://blogs.leechee.top/categories/HexoPost/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blogs.leechee.top/tags/hexo/"},{"name":"post","slug":"post","permalink":"https://blogs.leechee.top/tags/post/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.leechee.top/categories/Linux/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://blogs.leechee.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C/C++","slug":"C-C","permalink":"https://blogs.leechee.top/categories/C-C/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://blogs.leechee.top/categories/DataStructure/"},{"name":"Tips","slug":"Tips","permalink":"https://blogs.leechee.top/categories/Tips/"},{"name":"HexoPost","slug":"HexoPost","permalink":"https://blogs.leechee.top/categories/HexoPost/"},{"name":"Project","slug":"Project","permalink":"https://blogs.leechee.top/categories/Project/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blogs.leechee.top/tags/Linux/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://blogs.leechee.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blogs.leechee.top/tags/ubuntu/"},{"name":"C/C++","slug":"C-C","permalink":"https://blogs.leechee.top/tags/C-C/"},{"name":"QT","slug":"QT","permalink":"https://blogs.leechee.top/tags/QT/"},{"name":"项目","slug":"项目","permalink":"https://blogs.leechee.top/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"unbuntu","slug":"unbuntu","permalink":"https://blogs.leechee.top/tags/unbuntu/"},{"name":"高并发","slug":"高并发","permalink":"https://blogs.leechee.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"C++","slug":"C","permalink":"https://blogs.leechee.top/tags/C/"},{"name":"语言","slug":"语言","permalink":"https://blogs.leechee.top/tags/%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"https://blogs.leechee.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://blogs.leechee.top/tags/%E6%8E%92%E5%BA%8F/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blogs.leechee.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"记录","slug":"记录","permalink":"https://blogs.leechee.top/tags/%E8%AE%B0%E5%BD%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blogs.leechee.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"ROS机器人","slug":"ROS机器人","permalink":"https://blogs.leechee.top/tags/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"name":"Tips","slug":"Tips","permalink":"https://blogs.leechee.top/tags/Tips/"},{"name":"Windows","slug":"Windows","permalink":"https://blogs.leechee.top/tags/Windows/"},{"name":"hexo","slug":"hexo","permalink":"https://blogs.leechee.top/tags/hexo/"},{"name":"post","slug":"post","permalink":"https://blogs.leechee.top/tags/post/"},{"name":"心得","slug":"心得","permalink":"https://blogs.leechee.top/tags/%E5%BF%83%E5%BE%97/"},{"name":"学习","slug":"学习","permalink":"https://blogs.leechee.top/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Drivers","slug":"Drivers","permalink":"https://blogs.leechee.top/tags/Drivers/"}]}